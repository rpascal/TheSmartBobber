<html>
<head>
<title>EAGLE Help Version 9.3.0</title>
<style type="text/css"><!-- h1 { background-color: #CCCCCC; color: #0050B0; } pre { background-color: #EEEEEE; } mb { font-weight: bold; font-family: courier; background-color: #EEEEEE; }--></style>
</head>
<body>
<table width=100% cellspacing=0 border=0><tr>
<td align=left>EAGLE Help Version 9.3.0</td>
<td align=right><font size=-1>
<i>Copyright &copy; 2019 Autodesk, Inc. All rights reserved Copyright</i>
</font></td></tr></table>

<h1>Index</h1>
<ul>
<li><a href=#1>General Help</a>
<li><a href=#2>Configuring EAGLE</a>
<li><a href=#3>Command Line Options</a>
<li><a href=#4>Quick Introduction</a>
<ul>
<li><a href=#5>Control Panel and Editor Windows</a>
<li><a href=#6>Entering Parameters and Values</a>
<li><a href=#7>Drawing a Schematic</a>
<li><a href=#8>Creating a Hierarchical Schematic</a>
<li><a href=#9>Checking the Schematic</a>
<li><a href=#10>Generating a Board from a Schematic</a>
<li><a href=#11>Checking the Layout</a>
<li><a href=#12>Creating a Library Device</a>
</ul>
<li><a href=#13>Control Panel</a>
<ul>
<li><a href=#14>Context Menus</a>
<li><a href=#15>Directories</a>
<li><a href=#16>Backup</a>
<li><a href=#17>User Interface</a>
<li><a href=#18>Data collection and use</a>
<li><a href=#19>Proxy settings</a>
<li><a href=#20>Check for Update</a>
</ul>
<li><a href=#21>Keyboard and Mouse</a>
<ul>
<li><a href=#22>Selecting objects in dense areas</a>
</ul>
<li><a href=#23>Editor Windows</a>
<ul>
<li><a href=#24>Library Editor</a>
<ul>
<li><a href=#25>Edit Library Object</a>
</ul>
<li><a href=#26>Board Editor</a>
<li><a href=#27>Schematic Editor</a>
<li><a href=#28>Text Editor</a>
</ul>
<li><a href=#29>Editor Commands</a>
<ul>
<li><a href=#30>Command Syntax</a>
<li><a href=#31>ADD</a>
<li><a href=#32>ADDMODEL</a>
<li><a href=#33>ALIGN</a>
<li><a href=#34>ARC</a>
<li><a href=#35>ASSIGN</a>
<li><a href=#36>ATTRIBUTE</a>
<li><a href=#37>AUTO</a>
<li><a href=#38>BOARD</a>
<li><a href=#39>BUS</a>
<li><a href=#40>BREAKOUTBUS</a>
<li><a href=#41>CHANGE</a>
<li><a href=#42>PAINTROLLER</a>
<li><a href=#43>CIRCLE</a>
<li><a href=#44>CLASS</a>
<li><a href=#45>CLOSE</a>
<li><a href=#46>CONNECT</a>
<li><a href=#47>COPY</a>
<li><a href=#48>CUT</a>
<li><a href=#49>DELETE</a>
<li><a href=#50>DESCRIPTION</a>
<li><a href=#51>DIMENSION</a>
<li><a href=#52>DISPLAY</a>
<li><a href=#53>DRC</a>
<li><a href=#54>EDIT</a>
<li><a href=#55>ERC</a>
<li><a href=#56>ERRORS</a>
<li><a href=#57>EXPORT</a>
<li><a href=#58>FANOUT</a>
<li><a href=#59>FRAME</a>
<li><a href=#60>GATESWAP</a>
<li><a href=#61>GRID</a>
<li><a href=#62>GROUP</a>
<li><a href=#63>HELP</a>
<li><a href=#64>HOLE</a>
<li><a href=#65>INFO</a>
<li><a href=#66>INVOKE</a>
<li><a href=#67>JUNCTION</a>
<li><a href=#68>LABEL</a>
<li><a href=#69>VPROBE</a>
<li><a href=#70>VPPROBE</a>
<li><a href=#71>LAUNCH</a>
<li><a href=#72>LAYER</a>
<li><a href=#73>LINE</a>
<li><a href=#74>LOCK</a>
<li><a href=#75>MAPTOMODEL</a>
<li><a href=#76>MANUFACTURING</a>
<li><a href=#77>MARK</a>
<li><a href=#78>MEANDER</a>
<li><a href=#79>MENU</a>
<li><a href=#80>MIRROR</a>
<li><a href=#81>MITER</a>
<li><a href=#82>MODULE</a>
<li><a href=#83>MOVE</a>
<li><a href=#84>NAME</a>
<li><a href=#85>NET</a>
<li><a href=#86>OPEN</a>
<li><a href=#87>OPTIMIZE</a>
<li><a href=#88>PACKAGE</a>
<li><a href=#89>PAD</a>
<li><a href=#90>PADARRAY</a>
<li><a href=#91>PASTE</a>
<li><a href=#92>PATTERN</a>
<li><a href=#93>PIN</a>
<li><a href=#94>PINARRAY</a>
<li><a href=#95>PINBREAKOUT</a>
<li><a href=#96>PINTOBUS</a>
<li><a href=#97>PINSWAP</a>
<li><a href=#98>POLYGON</a>
<li><a href=#99>POLYGONIZE</a>
<li><a href=#100>PORT</a>
<li><a href=#101>PREFIX</a>
<li><a href=#102>PRINT</a>
<li><a href=#103>QUIT</a>
<li><a href=#104>RATSNEST</a>
<li><a href=#105>RECT</a>
<li><a href=#106>REDO</a>
<li><a href=#107>REMOVE</a>
<li><a href=#108>REMOVEMODEL</a>
<li><a href=#109>RENAME</a>
<li><a href=#110>REPLACE</a>
<li><a href=#111>RIPUP</a>
<li><a href=#112>ROTATE</a>
<li><a href=#113>ROUTE</a>
<li><a href=#114>RUN</a>
<li><a href=#115>SCRIPT</a>
<li><a href=#116>SET</a>
<li><a href=#117>SHOW</a>
<li><a href=#118>SIGNAL</a>
<li><a href=#119>SLICE</a>
<li><a href=#120>SIM</a>
<li><a href=#121>SIMOPTOGGLE</a>
<li><a href=#122>REPOSITION</a>
<li><a href=#123>SMD</a>
<li><a href=#124>SMDARRAY</a>
<li><a href=#125>SOURCESETUP</a>
<li><a href=#126>DSOURCESETUP</a>
<li><a href=#127>SPLIT</a>
<li><a href=#128>FUSIONSYNC</a>
<li><a href=#129>FUSIONTEAM</a>
<li><a href=#130>TECHNOLOGY</a>
<li><a href=#131>TEXT</a>
<li><a href=#132>EXPORTSTEP</a>
<li><a href=#133>UNDO</a>
<li><a href=#134>UPDATE</a>
<li><a href=#135>USE</a>
<li><a href=#136>VALUE</a>
<li><a href=#137>VARIANT</a>
<li><a href=#138>VIA</a>
<li><a href=#139>WINDOW</a>
<li><a href=#140>WIRE</a>
<li><a href=#141>WRITE</a>
</ul>
<li><a href=#142>Generating Output</a>
<ul>
<li><a href=#143>Printing</a>
<ul>
<li><a href=#144>Printing a Drawing</a>
<li><a href=#145>Printing a Text</a>
<li><a href=#146>Printer Page Setup</a>
</ul>
<li><a href=#147>CAM Processor</a>
<ul>
<li><a href=#148>Main CAM Menu</a>
<li><a href=#149>CAM Processor Job</a>
<li><a href=#150>Output Device</a>
<ul>
<li><a href=#151>Device Parameters</a>
<ul>
<li><a href=#152>Aperture Wheel File</a>
<li><a href=#153>Aperture Emulation</a>
<li><a href=#154>Aperture Tolerances</a>
<li><a href=#155>Drill Rack File</a>
<li><a href=#156>Drill Tolerances</a>
<li><a href=#157>Offset</a>
<li><a href=#158>Printable Area</a>
<li><a href=#159>Pen Data</a>
</ul>
<li><a href=#160>Defining Your Own Device Driver</a>
</ul>
<li><a href=#161>Output File</a>
<li><a href=#162>Flag Options</a>
<li><a href=#163>Layers and Colors</a>
</ul>
<li><a href=#164>Outlines data</a>
</ul>
<li><a href=#165>Group Default ON</a>
<li><a href=#166>Autorouter</a>
<li><a href=#167>Design Checks</a>
<ul>
<li><a href=#168>Design Rules</a>
</ul>
<li><a href=#169>Cross-references</a>
<ul>
<li><a href=#170>Cross-reference labels</a>
<li><a href=#171>Part cross-references</a>
<li><a href=#172>Contact cross-references</a>
</ul>
<li><a href=#173>User Language</a>
<ul>
<li><a href=#174>Writing a ULP</a>
<li><a href=#175>Executing a ULP</a>
<li><a href=#176>Syntax</a>
<ul>
<li><a href=#177>Whitespace</a>
<li><a href=#178>Comments</a>
<li><a href=#179>Directives</a>
<ul>
<li><a href=#180>#include</a>
<li><a href=#181>#require</a>
<li><a href=#182>#usage</a>
</ul>
<li><a href=#183>Keywords</a>
<li><a href=#184>Identifiers</a>
<li><a href=#185>Constants</a>
<ul>
<li><a href=#186>Character Constants</a>
<li><a href=#187>Integer Constants</a>
<li><a href=#188>Real Constants</a>
<li><a href=#189>String Constants</a>
<li><a href=#190>Escape Sequences</a>
</ul>
<li><a href=#191>Punctuators</a>
<ul>
<li><a href=#192>Brackets</a>
<li><a href=#193>Parentheses</a>
<li><a href=#194>Braces</a>
<li><a href=#195>Comma</a>
<li><a href=#196>Semicolon</a>
<li><a href=#197>Colon</a>
<li><a href=#198>Equal Sign</a>
</ul>
</ul>
<li><a href=#199>Data Types</a>
<ul>
<li><a href=#200>char</a>
<li><a href=#201>int</a>
<li><a href=#202>real</a>
<li><a href=#203>string</a>
<li><a href=#204>Type Conversions</a>
<li><a href=#205>Typecast</a>
</ul>
<li><a href=#206>Object Types</a>
<ul>
<li><a href=#207>UL_ARC</a>
<li><a href=#208>UL_AREA</a>
<li><a href=#209>UL_ATTRIBUTE</a>
<li><a href=#210>UL_BOARD</a>
<li><a href=#211>UL_BUS</a>
<li><a href=#212>UL_CIRCLE</a>
<li><a href=#213>UL_CLASS</a>
<li><a href=#214>UL_CONTACT</a>
<li><a href=#215>UL_CONTACTREF</a>
<li><a href=#216>UL_DEVICE</a>
<li><a href=#217>UL_DEVICESET</a>
<li><a href=#218>UL_DIMENSION</a>
<li><a href=#219>UL_ELEMENT</a>
<li><a href=#220>UL_ERROR</a>
<li><a href=#221>UL_FRAME</a>
<li><a href=#222>UL_GATE</a>
<li><a href=#223>UL_GRID</a>
<li><a href=#224>UL_HOLE</a>
<li><a href=#225>UL_INSTANCE</a>
<li><a href=#226>UL_JUNCTION</a>
<li><a href=#227>UL_LABEL</a>
<li><a href=#228>UL_LAYER</a>
<li><a href=#229>UL_LIBRARY</a>
<li><a href=#230>UL_MODULE</a>
<li><a href=#231>UL_MODULEINST</a>
<li><a href=#232>UL_NET</a>
<li><a href=#233>UL_FOOTPRINT (new as of EAGLE 9.1)</a>
<li><a href=#234>UL_PACKAGE3D</a>
<li><a href=#235>UL_PAD</a>
<li><a href=#236>UL_PART</a>
<li><a href=#237>UL_PIN</a>
<li><a href=#238>UL_PINREF</a>
<li><a href=#239>UL_POLYGON</a>
<li><a href=#240>UL_PORT</a>
<li><a href=#241>UL_PORTREF</a>
<li><a href=#242>UL_RECTANGLE</a>
<li><a href=#243>UL_SCHEMATIC</a>
<li><a href=#244>UL_SEGMENT</a>
<li><a href=#245>UL_SHEET</a>
<li><a href=#246>UL_SIGNAL</a>
<li><a href=#247>UL_SMD</a>
<li><a href=#248>UL_SYMBOL</a>
<li><a href=#249>UL_TEXT</a>
<li><a href=#250>UL_VARIANTDEF</a>
<li><a href=#251>UL_VARIANT</a>
<li><a href=#252>UL_VIA</a>
<li><a href=#253>UL_WIRE</a>
</ul>
<li><a href=#254>Definitions</a>
<ul>
<li><a href=#255>Constant Definitions</a>
<li><a href=#256>Variable Definitions</a>
<li><a href=#257>Function Definitions</a>
</ul>
<li><a href=#258>Operators</a>
<ul>
<li><a href=#259>Bitwise Operators</a>
<li><a href=#260>Logical Operators</a>
<li><a href=#261>Comparison Operators</a>
<li><a href=#262>Evaluation Operators</a>
<li><a href=#263>Arithmetic Operators</a>
<li><a href=#264>String Operators</a>
</ul>
<li><a href=#265>Expressions</a>
<ul>
<li><a href=#266>Arithmetic Expression</a>
<li><a href=#267>Assignment Expression</a>
<li><a href=#268>String Expression</a>
<li><a href=#269>Comma Expression</a>
<li><a href=#270>Conditional Expression</a>
<li><a href=#271>Function Call</a>
</ul>
<li><a href=#272>Statements</a>
<ul>
<li><a href=#273>Compound Statement</a>
<li><a href=#274>Expression Statement</a>
<li><a href=#275>Control Statements</a>
<ul>
<li><a href=#276>break</a>
<li><a href=#277>continue</a>
<li><a href=#278>do...while</a>
<li><a href=#279>for</a>
<li><a href=#280>if...else</a>
<li><a href=#281>return</a>
<li><a href=#282>switch</a>
<li><a href=#283>while</a>
</ul>
</ul>
<li><a href=#284>Builtins</a>
<ul>
<li><a href=#285>Builtin Constants</a>
<li><a href=#286>Builtin Variables</a>
<li><a href=#287>Builtin Functions</a>
<ul>
<li><a href=#288>Character Functions</a>
<ul>
<li><a href=#289>is...()</a>
<li><a href=#290>to...()</a>
</ul>
<li><a href=#291>File Handling Functions</a>
<ul>
<li><a href=#292>fileerror()</a>
<li><a href=#293>fileglob()</a>
<li><a href=#294>Filename Functions</a>
<li><a href=#295>Filedata Functions</a>
<li><a href=#296>File Input Functions</a>
<ul>
<li><a href=#297>fileread()</a>
</ul>
</ul>
<li><a href=#298>Mathematical Functions</a>
<ul>
<li><a href=#299>Absolute, Maximum and Minimum Functions</a>
<li><a href=#300>Rounding Functions</a>
<li><a href=#301>Trigonometric Functions</a>
<li><a href=#302>Exponential Functions</a>
</ul>
<li><a href=#303>Miscellaneous Functions</a>
<ul>
<li><a href=#304>Configuration Parameters</a>
<li><a href=#305>country()</a>
<li><a href=#306>exit()</a>
<li><a href=#307>fdlsignature()</a>
<li><a href=#308>language()</a>
<li><a href=#309>lookup()</a>
<li><a href=#310>palette()</a>
<li><a href=#311>sleep()</a>
<li><a href=#312>sort()</a>
<li><a href=#313>status()</a>
<li><a href=#314>system()</a>
<li><a href=#315>Unit Conversions</a>
</ul>
<li><a href=#316>Network Functions</a>
<ul>
<li><a href=#317>neterror()</a>
<li><a href=#318>netget()</a>
<li><a href=#319>netpost()</a>
</ul>
<li><a href=#320>Printing Functions</a>
<ul>
<li><a href=#321>printf()</a>
<li><a href=#322>sprintf()</a>
</ul>
<li><a href=#323>String Functions</a>
<ul>
<li><a href=#324>strchr()</a>
<li><a href=#325>strjoin()</a>
<li><a href=#326>strlen()</a>
<li><a href=#327>strlwr()</a>
<li><a href=#328>strrchr()</a>
<li><a href=#329>strrstr()</a>
<li><a href=#330>strsplit()</a>
<li><a href=#331>strstr()</a>
<li><a href=#332>strsub()</a>
<li><a href=#333>strtod()</a>
<li><a href=#334>strtol()</a>
<li><a href=#335>strupr()</a>
<li><a href=#336>strxstr()</a>
</ul>
<li><a href=#337>URN Functions</a>
<ul>
<li><a href=#338>urnbase()</a>
<li><a href=#339>urnversion()</a>
</ul>
<li><a href=#340>Time Functions</a>
<ul>
<li><a href=#341>time()</a>
<li><a href=#342>timems()</a>
<li><a href=#343>Time Conversions</a>
</ul>
<li><a href=#344>Object Functions</a>
<ul>
<li><a href=#345>clrgroup()</a>
<li><a href=#346>ingroup()</a>
<li><a href=#347>setgroup()</a>
<li><a href=#348>setvariant()</a>
<li><a href=#349>variant()</a>
</ul>
<li><a href=#350>XML Functions</a>
<ul>
<li><a href=#351>xmlattribute(), xmlattributes()</a>
<li><a href=#352>xmlelement(), xmlelements()</a>
<li><a href=#353>xmltags()</a>
<li><a href=#354>xmltext()</a>
</ul>
</ul>
<li><a href=#355>Builtin Statements</a>
<ul>
<li><a href=#356>board()</a>
<li><a href=#357>deviceset()</a>
<li><a href=#358>library()</a>
<li><a href=#359>module()</a>
<li><a href=#360>output()</a>
<li><a href=#361>footprint(), new as of EAGLE 9.1</a>
<li><a href=#362>schematic()</a>
<li><a href=#363>sheet()</a>
<li><a href=#364>symbol()</a>
</ul>
</ul>
<li><a href=#365>Dialogs</a>
<ul>
<li><a href=#366>Predefined Dialogs</a>
<ul>
<li><a href=#367>dlgDirectory()</a>
<li><a href=#368>dlgFileOpen(), dlgFileSave()</a>
<li><a href=#369>dlgMessageBox()</a>
</ul>
<li><a href=#370>Dialog Objects</a>
<ul>
<li><a href=#371>dlgCell</a>
<li><a href=#372>dlgCheckBox</a>
<li><a href=#373>dlgComboBox</a>
<li><a href=#374>dlgDialog</a>
<li><a href=#375>dlgGridLayout</a>
<li><a href=#376>dlgGroup</a>
<li><a href=#377>dlgHBoxLayout</a>
<li><a href=#378>dlgIntEdit</a>
<li><a href=#379>dlgLabel</a>
<li><a href=#380>dlgListBox</a>
<li><a href=#381>dlgListView</a>
<li><a href=#382>dlgPushButton</a>
<li><a href=#383>dlgRadioButton</a>
<li><a href=#384>dlgRealEdit</a>
<li><a href=#385>dlgSpacing</a>
<li><a href=#386>dlgSpinBox</a>
<li><a href=#387>dlgStretch</a>
<li><a href=#388>dlgStringEdit</a>
<li><a href=#389>dlgTabPage</a>
<li><a href=#390>dlgTabWidget</a>
<li><a href=#391>dlgTextEdit</a>
<li><a href=#392>dlgTextView</a>
<li><a href=#393>dlgVBoxLayout</a>
</ul>
<li><a href=#394>Layout Information</a>
<li><a href=#395>Dialog Functions</a>
<ul>
<li><a href=#396>dlgAccept()</a>
<li><a href=#397>dlgRedisplay()</a>
<li><a href=#398>dlgReset()</a>
<li><a href=#399>dlgReject()</a>
<li><a href=#400>dlgSelectionChanged()</a>
</ul>
<li><a href=#401>Escape Character</a>
<li><a href=#402>A Complete Example</a>
</ul>
<li><a href=#403>Supported HTML tags</a>
</ul>
<li><a href=#404>Automatic Backup</a>
<li><a href=#405>File Locking</a>
<li><a href=#406>Forward&amp;Back Annotation</a>
<ul>
<li><a href=#407>Consistency Check</a>
<li><a href=#408>Limitations</a>
</ul>
<li><a href=#409>EAGLE Editions - License</a>
</ul>


<a name=1>
<h1>General Help</h1>
While inside a <a href=#26>board</a>,
<a href=#27>schematic</a>, or
<a href=#24>library</a> editor window,
pressing F1 or entering the command <tt>HELP</tt>
will open the help page for the currently active command.
<p>
You can also display an editor command's help page by entering
<pre>
HELP command
</pre>
replacing "command" with, e.g., <tt>MOVE</tt>, which would display the help
page for the MOVE command.
<p>
Anywhere else, pressing the F1 key will bring up a context sensitive
help page for the menu, dialog or action that is currently active.
<p>
For detailed information on how to get started with EAGLE please read the
following help pages:
<ul>
<li><a href=#4>Quick Introduction</a>
<li><a href=#2>Configuring EAGLE</a>
<li><a href=#3>Command Line Options</a>
<li><a href=#13>Control Panel</a>
</ul>


<a name=2>
<h1>Configuring EAGLE</h1>
Global EAGLE parameters can be adjusted in the
<a href=#13>Control Panel</a>.
<p>
The following editor commands can be used to customize the way EAGLE works.
They can be given either directly from an editor window's command line,
or in the <a href=#115>eagle.scr</a> file.
<h2>User Interface</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Command menu             </td><td width=20><td><a href=#79>MENU</a> command..;</td></tr>
<tr><td>Assign keys              </td><td width=20><td><a href=#35>ASSIGN</a> function_key command..;</td></tr>
<tr><td>Snap function            </td><td width=20><td><a href=#116>SET</a> SNAP_LENGTH number;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> CATCH_FACTOR value;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> SELECT_FACTOR value;</td></tr>
<tr><td>Content of menus         </td><td width=20><td><a href=#116>SET</a> USED_LAYERS name | number;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> WIDTH_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> DIAMETER_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> DRILL_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> SMD_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> SIZE_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> ISOLATE_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> SPACING_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> MITER_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> DLINE_WIDTH_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> DLINE_EXT_WIDTH_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> DLINE_EXT_LENGTH_MENU value..;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> DLINE_EXT_OFFSET_MENU value..;</td></tr>
<tr><td>Bend for wires, lines    </td><td width=20><td><a href=#116>SET</a> WIRE_BEND bend_nr;</td></tr>
<tr><td>Beep on/off              </td><td width=20><td><a href=#116>SET</a> BEEP OFF | ON;</td></tr>
</table>
<h2>Screen Display</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Color for grid lines     </td><td width=20><td><a href=#116>SET</a> COLOR_GRID color;</td></tr>
<tr><td>Color for layer          </td><td width=20><td><a href=#116>SET</a> COLOR_LAYER layer color;</td></tr>
<tr><td>Fill style for layer     </td><td width=20><td><a href=#116>SET</a> FILL_LAYER layer fill;</td></tr>
<tr><td>Grid parameter           </td><td width=20><td><a href=#116>SET</a> MIN_GRID_SIZE pixels;</td></tr>
<tr><td>Min. text size displayed </td><td width=20><td><a href=#116>SET</a> MIN_TEXT_SIZE size;</td></tr>
<tr><td>Display of net lines     </td><td width=20><td><a href=#116>SET</a> NET_LINE_WIDTH width;</td></tr>
<tr><td>Display of pads          </td><td width=20><td><a href=#116>SET</a> DISPLAY_MODE REAL | NODRILL;</td></tr>
<tr><td>                         </td><td width=20><td><a href=#116>SET</a> PAD_NAMES OFF | ON;</td></tr>
<tr><td>Display of bus lines     </td><td width=20><td><a href=#116>SET</a> BUS_LINE_WIDTH width;</td></tr>
<tr><td>DRC fill style           </td><td width=20><td><a href=#116>SET</a> DRC_FILL fill_name;</td></tr>
<tr><td>Polygon processing       </td><td width=20><td><a href=#116>SET</a> POLYGON_RATSNEST OFF | ON;</td></tr>
<tr><td>Vector font              </td><td width=20><td><a href=#116>SET</a> VECTOR_FONT OFF | ON;</td></tr>
</table>
<h2>Mode Parameters</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Package check            </td><td width=20><td><a href=#116>SET</a> CHECK_CONNECTS OFF | ON;</td></tr>
<tr><td>Grid parameters          </td><td width=20><td><a href=#61>GRID</a> options;</td></tr>
<tr><td>Replace mode             </td><td width=20><td><a href=#116>SET</a> REPLACE_SAME NAMES | COORDS;</td></tr>
<tr><td>UNDO Buffer              </td><td width=20><td><a href=#116>SET</a> UNDO_LOG OFF | ON;</td></tr>
<tr><td>Wire/Line Optimizing     </td><td width=20><td><a href=#116>SET</a> OPTIMIZING OFF | ON;</td></tr>
<tr><td>Net wire termination     </td><td width=20><td><a href=#116>SET</a> AUTO_END_NET OFF | ON;</td></tr>
<tr><td>Automatic junctions      </td><td width=20><td><a href=#116>SET</a> AUTO_JUNCTION OFF | ON;</td></tr>
<tr><td>Live DRC                 </td><td width=20><td><a href=#116>SET</a> LIVE_DRC OFF | ON;</td></tr>
<tr><td>Single Layer Mode        </td><td width=20><td><a href=#116>SET</a> SINGLE_LAYER_MODE OFF | ON;</td></tr>
</table>
<h2>Move Modes</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Preserve Angles          </td><td width=20><td><a href=#116>SET</a> MOVE_MODE PRESERVE_ANGLES;</td></tr>
<tr><td>Free                     </td><td width=20><td><a href=#116>SET</a> MOVE_MODE FREE;</td></tr>
<tr><td>Disconnect               </td><td width=20><td><a href=#116>SET</a> MOVE_MODE DISCONNECT;</td></tr>
</table>
<h2>Routing Modes</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Obstacle Mode            </td><td width=20><td><a href=#116>SET</a> OBSTACLE_MODE IGNORE | WALKAROUND | PUSH;</td></tr>
<tr><td>Loop Removal             </td><td width=20><td><a href=#116>SET</a> LOOP_REMOVAL OFF | ON;</td></tr>
</table>
<h2>Ripup Modes</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Default/Normal           </td><td width=20><td><a href=#116>SET</a> Ripup_mode DEFAULT | 0;</td></tr>
<tr><td>Signal                   </td><td width=20><td><a href=#116>SET</a> Ripup_mode SIGNAL | 1;</td></tr>
<tr><td>Connected                </td><td width=20><td><a href=#116>SET</a> Ripup_mode CONNECTED | 2;</td></tr>
<tr><td>Connected on Same Layer  </td><td width=20><td><a href=#116>SET</a> Ripup_mode CONNECTED_SAME_LAYER | 3;</td></tr>
<tr><td>Element to Element       </td><td width=20><td><a href=#116>SET</a> Ripup_mode ELEMENT_ELEMENT | 4;</td></tr>
<tr><td>All Signals              </td><td width=20><td><a href=#116>SET</a> Ripup_mode ALL;</td></tr>
<tr><td>All Polygons             </td><td width=20><td><a href=#116>SET</a> Ripup_mode ALL_POLYGONS;</td></tr>
</table>
<h2>Presettings</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Pad shape                </td><td width=20><td><a href=#41>CHANGE</a> SHAPE shape;</td></tr>
<tr><td>Wire width               </td><td width=20><td><a href=#41>CHANGE</a> WIDTH value;</td></tr>
<tr><td>Pad/via diameter         </td><td width=20><td><a href=#41>CHANGE</a> DIAMETER diameter;</td></tr>
<tr><td>Pad/via/hole drill diam. </td><td width=20><td><a href=#41>CHANGE</a> DRILL value;</td></tr>
<tr><td>Smd size                 </td><td width=20><td><a href=#41>CHANGE</a> SMD width height;</td></tr>
<tr><td>Text height              </td><td width=20><td><a href=#41>CHANGE</a> SIZE value;</td></tr>
<tr><td>Text thickness           </td><td width=20><td><a href=#41>CHANGE</a> RATIO ratio;</td></tr>
<tr><td>Text font                </td><td width=20><td><a href=#41>CHANGE</a> FONT font;</td></tr>
<tr><td>Text alignment           </td><td width=20><td><a href=#41>CHANGE</a> ALIGN align;</td></tr>
<tr><td>Polygon parameter        </td><td width=20><td><a href=#41>CHANGE</a> THERMALS OFF | ON;</td></tr>
<tr><td>Polygon parameter        </td><td width=20><td><a href=#41>CHANGE</a> ORPHANS OFF | ON;</td></tr>
<tr><td>Polygon parameter        </td><td width=20><td><a href=#41>CHANGE</a> ISOLATE distance;</td></tr>
<tr><td>Polygon parameter        </td><td width=20><td><a href=#41>CHANGE</a> POUR SOLID | HATCH | CUTOUT;</td></tr>
<tr><td>Polygon parameter        </td><td width=20><td><a href=#41>CHANGE</a> RANK value;</td></tr>
<tr><td>Polygon parameter        </td><td width=20><td><a href=#41>CHANGE</a> SPACING distance;</td></tr>
<tr><td>Dimension type           </td><td width=20><td><a href=#41>CHANGE</a> DTYPE value;</td></tr>
</table>


<a name=3>
<h1>Command Line Options</h1>
You can call up EAGLE with command line parameters. Use the following format:
<pre>
eagle [ options [ filename [ layer ] ] ]
</pre>
Under Windows EAGLE is also available as a console application (see below).
<h2>Options</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>-Axxx</tt></td>  <td width=20><td>Assembly variant</td></tr>
<tr><td><tt>-Cxxx</tt></td>  <td width=20><td>execute the given Command</td></tr>
<tr><td><tt>-Dxxx</tt></td>  <td width=20><td>Draw tolerance (0.1 = 10%)</td></tr>
<tr><td><tt>-Exxx</tt></td>  <td width=20><td>Drill tolerance (0.1 = 10%)</td></tr>
<tr><td><tt>-Fxxx</tt></td>  <td width=20><td>Flash tolerance (0.1 = 10%)</td></tr>
<tr><td><tt>-N-</tt></td>    <td width=20><td>no command line prompts</td></tr>
<tr><td><tt>-O+</tt></td>    <td width=20><td>Optimize pen movement</td></tr>
<tr><td><tt>-Pxxx</tt></td>  <td width=20><td>plotter Pen (layer=pen)</td></tr>
<tr><td><tt>-Rxxx</tt></td>  <td width=20><td>drill Rack file</td></tr>
<tr><td><tt>-Sxxx</tt></td>  <td width=20><td>Scriptfile</td></tr>
<tr><td><tt>-Uxxx</tt></td>  <td width=20><td>User settings file</td></tr>
<tr><td><tt>-Wxxx</tt></td>  <td width=20><td>aperture Wheel file</td></tr>
<tr><td><tt>-X-</tt></td>    <td width=20><td>eXecute CAM Processor</td></tr>
<tr><td><tt>-c+</tt></td>    <td width=20><td>positive Coordinates</td></tr>
<tr><td><tt>-dxxx</tt></td>  <td width=20><td>Device (-d? for list)</td></tr>
<tr><td><tt>-e-</tt></td>    <td width=20><td>Emulate apertures</td></tr>
<tr><td><tt>-f+</tt></td>    <td width=20><td>Fill pads</td></tr>
<tr><td><tt>-hxxx</tt></td>  <td width=20><td>page Height (inch)</td></tr>
<tr><td><tt>-m-</tt></td>    <td width=20><td>Mirror output</td></tr>
<tr><td><tt>-oxxx</tt></td>  <td width=20><td>Output filename</td></tr>
<tr><td><tt>-pxxx</tt></td>  <td width=20><td>Pen diameter (mm)</td></tr>
<tr><td><tt>-q-</tt></td>    <td width=20><td>Quick plot</td></tr>
<tr><td><tt>-r-</tt></td>    <td width=20><td>Rotate output 90 degrees</td></tr>
<tr><td><tt>-sxxx</tt></td>  <td width=20><td>Scale factor</td></tr>
<tr><td><tt>-u-</tt></td>    <td width=20><td>output Upside down</td></tr>
<tr><td><tt>-vxxx</tt></td>  <td width=20><td>pen Velocity</td></tr>
<tr><td><tt>-wxxx</tt></td>  <td width=20><td>page Width (inch)</td></tr>
<tr><td><tt>-xxxx</tt></td>  <td width=20><td>offset X (inch)</td></tr>
<tr><td><tt>-yxxx</tt></td>  <td width=20><td>offset Y (inch)</td></tr>
</table>
<p>
where <tt>xxx</tt> means that further data, e.g. a file name or a decimal number
needs to be appended to the option character (without space or separated by a space),
as in
<pre>
-Wmywheel.whl
-W mywheel.whl
-e      Aperture emulation on
-e+     dto.
-e-     Aperture emulation off
</pre>
For flag options, a <tt>'-'</tt> means that the option is off by default, while
<tt>'+'</tt> means it is on by default.
<p>
Flag options (e.g. <tt>-e</tt>) can be used without repeating the <tt>'-'</tt> character:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>-ecfm</tt></td>  <td width=20><td>Aperture emulation on, positive oordinates on, fill pads on</td></tr>
<tr><td><tt>-ec-f+</tt></td> <td width=20><td>Aperture emulation on, positive oordinates <b>off</b>, fill pads <b>on</b></td></tr>
</table>
<h2>User settings</h2>
User settings are stored in the <tt>eaglerc</tt> file, which, by default, is stored
in <tt>$CACHE_DIR/settings/X.Y.Z/eaglerc</tt> and is version specific. On the first launch of the new version of EAGLE user is prompted to import settings from the previous versions if they are available.
<p>
$CACHE_DIR is OS dependant:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>Windows</tt></td>  <td width=20><td></td>c:\Users\$UserName\AppData\Roaming\Eagle\settings\X.Y.Z\eaglerc</tr>
<tr><td><tt>MacOS</tt></td>    <td width=20><td></td>/Users/$UserName/Library/Application Support/Eagle/settings/X.Y.Z/eaglerc</tr>
<tr><td><tt>Linux</tt></td>    <td width=20><td></td>/home/$UserName/.local/share/Eagle/settings/X.Y.Z/eaglerc</tr>
</table>
Where:
<li>$UserName - user name</li>
<li>X.Y.Z - EAGLE version. For example: 9.1.0.</li>
<br>
Instead of eaglerc file at default location user can specify a custom version of eaglerc to be used by passing fully qualified file name using <tt>-U</tt> command line option.<br>
Example:
<center><tt>C:/EAGLE-9.1.0/eagle.exe -UC:/Settings/eaglerc5.usr</tt></center>
<p>
If a <tt>'-'</tt> sign is given as the file name, as in <tt>-U-</tt>, no <tt>eaglerc</tt>
file will be read or written.
<h2>Defining Tolerance Values</h2>
Without <tt>'+'</tt> or <tt>'-'</tt> sign, a tolerance value applies to both directions:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>-D0.10</tt></td>         <td width=20><td>adjusts the draw tolerance to &plusmn;10%</td></tr>
<tr><td><tt>-D+0.1 -D-0.05</tt></td> <td width=20><td>adjusts the draw toleranceto +10% and -5%</td></tr>
</table>
<h2>Executing commands</h2>
If a command is given with the <tt>'-C'</tt> option, as in
<pre>
eagle -C "window (1 1) (2 2);" myboard.brd
</pre>
EAGLE will load the given file and execute the command as if it had been
typed into the editor window's command line.
<p>
The following conditions apply for the <tt>'-C'</tt> option:
<ul>
<li>A file name (board, schematic or library) must be given, so that an editor
    window will be opened in which the command can be executed. That file doesn't
    necessarily need to exist.
    The command is executed after loading and confirming of related messages.
<li>The <tt>eagle.scr</tt> file will not be executed automatically.
<li>The option <tt>'-s'</tt> will be ignored.
<li>The user settings will not be written back to the <tt>eaglerc</tt> file.
<li>Any project that has been open when EAGLE was left the last time will not be opened.
<li>The command can be a single command, or a sequence of commands delimited by
    semicolons.
</ul>
To run EAGLE without automatically executing the <tt>eagle.scr</tt> file or loading
a project, the command string can be empty, as in
<pre>
eagle -C ""
</pre>
Note that in this special case there must be a blank between the option character
and the quotes, so that the program will see the explicitly empty string. There
also doesn't have to be a file name here, because no command will actually be
executed.
<h2>Filename</h2>
If the given filename is <tt>eagle.epf</tt> (optionally preceded by a directory name),
EAGLE will load that Project File. Otherwise, if no file extension is given,
it defaults to <tt>.brd</tt>, to load a board file.
<h2>Console application (eaglecon.exe)</h2>
In order to run EAGLE from a console under Windows (e.g. in order to create a batch job
for CAM processing), you can use 'eaglecon.exe'.
eaglecon.exe is also located in the 'bin' folder, is identical with eagle.exe, but
keeps a connection to a console.
<p>
<b>Important note on closing:</b><br>
Please always close first EAGLE before closing the console!
Closing the console first leads to an uncontrolled shutdown of EAGLE with loss of unsaved
changes etc. The same problem occurs if you close the EAGLE windows as a group or explicitely
the console window via the taskbar.


<a name=4>
<h1>Quick Introduction</h1>
For a quick start you should know more about the following topics:
<ul>
<li><a href=#5>Control Panel and Editor Windows</a>
<li><a href=#30>Using Editor Commands</a>
<li><a href=#6>Entering Parameters and Values</a>
<li><a href=#7>Drawing a Schematic</a>
<li><a href=#8>Creating a Hierarchical Schematic</a>
<li><a href=#9>Checking the Schematic</a>
<li><a href=#10>Generating a Board from a Schematic</a>
<li><a href=#11>Checking the Layout</a>
<li><a href=#12>Creating a Library Device</a>
<li><a href=#166>Using the Autorouter</a>
<li><a href=#143>Using the System Printer</a>
<li><a href=#147>Using the CAM Processor</a>
</ul>


<a name=5>
<h1>Control Panel and Editor Windows</h1>
From the <a href=#13>Control Panel</a> you can open schematic,
board, or library editor windows by using the File menu or double clicking
an icon.


<a name=6>
<h1>Entering Parameters and Values</h1>
Parameters and values can be entered in the EAGLE command line
or, more conveniently, in the Parameter Toolbars which appear when a
command is activated. As this is quite self-explanatory, the help text
does not explicitly mention this option at other locations.
<p>
Wherever coordinates or sizes (like width, diameter etc.) can be entered, they may
be given with units, as in 50mil or 0.8mm. If no unit is given, the current grid unit is used.


<a name=7>
<h1>Drawing a Schematic</h1>
<h2>Create a Schematic File</h2>
Use File/New and Save as to create a schematic with a name of your
choice.
<h2>Load a Drawing Frame</h2>
Load library FRAMES with <a href=#135>USE</a> and place a frame of your choice with <a href=#31>ADD</a>.
<h2>Place Symbols</h2>
Load appropriate libraries with <a href=#135>USE</a> and place symbols (see <a href=#31>ADD</a>, <a href=#83>MOVE</a>,
<a href=#49>DELETE</a>, <a href=#112>ROTATE</a>, <a href=#84>NAME</a>, <a href=#136>VALUE</a>). Where a particular component is not
available, define a new one with the library editor.
<h2>Draw Bus Connections</h2>
Using the <a href=#39>BUS</a> command, draw bus connections. You can <a href=#84>NAME</a> a bus in
such a way that you can drag nets out of the bus which are named
accordingly.
<h2>Draw Net Connections</h2>
Using the <a href=#85>NET</a> command, connect up the pins of the various elements on
the drawing. Intersecting nets may be made into connections with the
<a href=#67>JUNCTION</a> command.
<h2>Create a Hierarchical Schematic</h2>
<a href=#8>Creating a Hierarchical Schematic</a>


<a name=8>
<h1>Creating a Hierarchical Schematic</h1>
<h2>Create a Hierarchical Schematic</h2>
A hierarchical schematic is created using a number of modules.
A module is created with the <a href=#82>MODULE</a> command
and contains a number of usual sheets.
<h2>Use a Module</h2>
In the schematic a module is referenced by a module instance.
There can be multiple module instances of the same module.
<h2>Connect a Module Instance</h2>
Connection points of module instances are defined by <a href=#100>PORT</a>s.


<a name=9>
<h1>Checking the Schematic</h1>
Carry out an electrical rule check (<a href=#55>ERC</a>) to look for open pins, etc.,
and use the messages generated to correct any errors. Use the <a href=#117>SHOW</a>
command to follow complete nets across the screen. Use the <a href=#57>EXPORT</a> command
to generate a netlist, pinlist, or partlist if necessary.


<a name=10>
<h1>Generating a Board from a Schematic</h1>
By using the <a href=#38>BOARD</a> command or clicking the Switch-to-Board icon you
can generate a board from the loaded schematic (if there is no board
with the same name yet).
<p>
All the components, together with their connections drawn as airwires,
appear beside a blank board ready for placing. Power pins are
automatically connected to the appropriate supply (if not connected by
a net on the schematic).
<p>
The board is linked to the schematic via <a href=#406>Forward&amp;Back Annotation</a>.
This mechanism makes sure that schematic and board are consistent.
When editing a drawing, board and schematic must be loaded to keep
Forward&amp;Back Annotation active.
<h2>Set Board Outlines and Place Components</h2>
The board outlines can be adjusted with the <a href=#83>MOVE</a> and <a href=#127>SPLIT</a>
commands as appropriate before moving each package on the board. Once
all packages have been placed, the <a href=#104>RATSNEST</a> command is used to
optimize airwires.
<h2>Define Restricted Areas</h2>
If required, restricted areas for the Autorouter can be defined as
<a href=#105>RECT</a>angles, <a href=#98>POLYGON</a>s, or <a href=#43>CIRCLE</a>s on the tRestrict, bRestrict, or
vRestrict layers. Note: areas enclosed by wires drawn on the Dimension
layer are borders for the Autorouter, too.
<h2>Routing</h2>
Airwires are now converted into tracks with the aid of the <a href=#113>ROUTE</a>
command. This function can also be performed automatically by the
<a href=#37>Autorouter</a>, when available.


<a name=11>
<h1>Checking the Layout</h1>
Check the layout (<a href=#53>DRC</a>) and correct the errors (<a href=#56>ERRORS</a>). Generate
net, part, or pin list if necessary(<a href=#57>EXPORT</a>).


<a name=12>
<h1>Creating a Library Device</h1>
Creating a new component part in a library has three steps. You must
follow these steps as they build upon each other.
<p>
To start, open a library. Use the File menu Open or New command (not
the USE command).
<h2>Create a Footprint</h2>
Footprints are the part of the device that are added to a board. (Prior to EAGLE 9.1, they were referred to as packages.)
<p>
Click the Edit Footprint icon and edit a new footprint by typing its
name in the New field of the dialog box.
<p>
Set the proper distance <a href=#61>GRID</a>.
<p>
<a href=#84>NAME</a> and place <a href=#89>PAD</a>s properly.
<p>
Add texts &gt;NAME and &gt;VALUE with the <a href=#131>TEXT</a> command (show actual name and
value in the board) and draw footprint outlines (<a href=#73>LINE</a> command) in the
proper layers.
<h2>Create a Symbol</h2>
Symbols are the part of the device that are added to a schematic.
<p>
Click the Edit Symbol icon and edit a new symbol by typing its
name in the New field of the dialog box.
<p>
Place and name pins with the commands <a href=#93>PIN</a> and <a href=#84>NAME</a> and provide pin
parameters (<a href=#41>CHANGE</a>).
<p>
Add texts &gt;NAME and &gt;VALUE with the <a href=#131>TEXT</a> command (show actual name and
value in the schematic) and draw symbol outlines (<a href=#73>LINE</a> command) in the
proper layers.
<h2>Create the Device</h2>
Devices are the "master" part of a component and use both a footprint (possibly with a 3D package)
and one or more symbols.
<p>
Click the Edit Device icon and edit a new device by typing its
name in the New field of the dialog box.
<p>
Assign the footprint (and optional 3D package) with the <a href=#88>PACKAGE</a> command.
<p>
Add the gate(s) with <a href=#31>ADD</a>, you can have as many gates as needed.
<p>
Use <a href=#46>CONNECT</a> to specify which of the packages pads are
connected to the pins of each gate.
<p>
Save the library and you can <a href=#135>USE</a> it from the schematic or board
editor.


<a name=13>
<h1>Control Panel</h1>
The Control Panel is the top level window of EAGLE.
It contains a tree view on the left side, and an information window on the right side.
<h2>Directories</h2>
The top level items of the tree view represent the various types of EAGLE files.
Each of these can point to one or more directories that contain files of that type.
The location of these directories can be defined with the <a href=#15>directories dialog</a>.
If a top level item points to a single directory, the contents of that directory will
appear if the item is opened (either by clicking on the little symbol to the left, or by
double clicking the item). If such an item points to more directories, all of these
directories will be listed when the item is opened.
<h2>Context menu</h2>
The <a href=#14>context menu</a> of the tree items can be accessed by clicking on them with the right
mouse button. It contains options specific to the selected item.
<h2>Descriptions</h2>
The <i>Description</i> column of the tree view contains a short description of the
item (if available). These descriptions are derived from the first non-blank line
of the text from the following sources:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Directories</td>            <td width=20><td>a file named DESCRIPTION in that directory</td></tr>
<tr><td>Libraries</td>              <td width=20><td>the description of the library</td></tr>
<tr><td>Devices</td>                <td width=20><td>the description of the device</td></tr>
<tr><td>3D Packages</td>            <td width=20><td>the description of the 3D package</td></tr>
<tr><td>Footprints</td>             <td width=20><td>the description of the footprint</td></tr>
<tr><td>Symbols</td>                <td width=20><td>the description of the symbol</td></tr>
<tr><td>Design Rules</td>           <td width=20><td>the description of the design rules file</td></tr>
<tr><td>User Language Programs</td> <td width=20><td>the text defined with the <tt>#usage</tt> directive</td></tr>
<tr><td>Scripts</td>                <td width=20><td>the comment at the beginning of the script file</td></tr>
<tr><td>CAM Jobs</td>               <td width=20><td>the description of the CAM job</td></tr>
</table>
<h2>Drag&amp;drop</h2>
You can use <i>Drag&amp;Drop</i> to copy or move files and directories within the
tree view. It is also possible to drag a device or footprint to a schematic, board or library
window, respectively, and drop it there to add it to the drawing. User Language Programs
and Scripts will be executed if dropped onto an editor window, and Design Rules will be
applied to a board if dropped onto a board editor window. If a board, schematic or
library file is dropped onto its respective editor window, it will be loaded into the
editor.
All of these functions can also be accessed through the <i>context menu</i>
of the particular tree item.
<h2>Information window</h2>
The right hand side of the Control Panel displays information about the current item
in the tree view. That information is derived from the places listed above under
<i>Descriptions</i>. Devices, 3D packages, footprints, and symbols also show a preview of
their contents.
<h2>Pulldown menu</h2>
The Control panel's <i>pulldown menu</i> contains the following options:
<h2>File</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>New   </td><td width=20><td>create a new file</td></tr>
<tr><td>Open            </td><td width=20><td>open an existing file</td></tr>
<tr><td>Open recent projects</td><td width=20><td>open a recently used project</td></tr>
<tr><td>Save all        </td><td width=20><td>save all modified editor files</td></tr>
<tr><td>Close project   </td><td width=20><td>close the current project</td></tr>
<tr><td>Exit            </td><td width=20><td>exit from the program</td></tr>
</table>
<h2>View</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Refresh</td><td width=20><td>refresh the contents of the tree view</td></tr>
<tr><td>Search in tree</td><td width=20><td>search in the contents of the tree view (see below)</td></tr>
<tr><td>Sort            </td><td width=20><td>change the sorting of the tree view</td></tr>
</table>
<h2>Options</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Directories...    </td><td width=20><td>opens the <a href=#15>directories dialog</a></td></tr>
<tr><td>Backup...         </td><td width=20><td>opens the <a href=#16>backup dialog</a></td></tr>
<tr><td>User interface... </td><td width=20><td>opens the <a href=#17>user interface dialog</a></td></tr>
<tr><td>Data collection and use... </td><td width=20><td>opens the <a href=#18>data collection and use dialog</a></td></tr>
<tr><td>Proxy settings... </td><td width=20><td>opens the <a href=#19>proxy settings dialog</a></td></tr>
</table>
<h2>Window</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Control Panel         </td><td width=20><td>switch to the Control Panel</td></tr>
<tr><td>1 Schematic - ...     </td><td width=20><td>switch to window number 1</td></tr>
<tr><td>2 Board - ...         </td><td width=20><td>switch to window number 2</td></tr>
</table>
<h2>Help</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>General </td><td width=20><td>opens a general help page</td></tr>
<tr><td>Context           </td><td width=20><td>opens the help page for the current context</td></tr>
<tr><td>Control Panel     </td><td width=20><td>opens the help page you are currently looking at</td></tr>
<tr><td>Check for Update  </td><td width=20><td><a href=#20>checks</a> if a new version of EAGLE is available</td></tr>
<tr><td>About EAGLE       </td><td width=20><td>displays details on your EAGLE version and <a href=#409>license</a></td></tr>
</table>
<h2>Search Bar</h2>
The <i>Search</i> pattern can be one or more words, separated by blanks.
These words are searched case insensitively in the tree names and descriptions
and must <u>all</u> match. The wildcard character '*' matches any number
of non-whitespace characters, while '?' matches exactly <u>one</u> of these characters.
To search for a wildcard character itself it has to be escaped like '\*'.
To restrict the search to a branch of the tree, the search can be started in its
context menu. To find a NAND device from the 74xx series, e.g. enter: <tt>74* nand</tt>
<h2>Status line</h2>
The status line at the bottom of the Control Panel contains
the full name of the currently selected item.


<a name=14>
<h1>Context Menus</h1>
Clicking on an item in the <a href=#13>Control Panel</a>
with the right mouse button opens a context menu which allows
the following actions (not all of them may be present on a particular item):
<h2>New Folder</h2>
Creates a new folder below the selected folder and puts the newly created tree
item into <i>Rename</i> mode.
<h2>Edit Description</h2>
Loads the DESCRIPTION file of a directory into the HTML editor.
<h2>Rename</h2>
Puts the tree item's text into edit mode, so that it can be renamed.
<h2>Copy</h2>
Opens a file dialog in which you can enter a name to which to copy this file or directory.
You can also use <i>Drag&amp;Drop</i> to do this.
<h2>Delete</h2>
Deletes the file or directory (you will be prompted to confirm that you really want this to happen).
<h2>Use</h2>
Marks this library to be <i>used</i> when searching for devices or footprints.
You can also click on the icon in the second column of the tree view to toggle this flag.
<h2>Use all</h2>
Marks all libraries in the Libraries path to be <i>used</i> when searching for devices or footprints.
<h2>Use none</h2>
Removes the <i>use</i> marks from all libraries (including such libraries that are not
in the Libraries path).
<h2>Update</h2>
Updates all parts used from this library in the loaded board and schematic.
<h2>Update in Library</h2>
Updates all footprints used from this library in the loaded library.
<h2>Add to Schematic</h2>
Starts the <a href=#31>ADD</a> command in the schematic window with this device.
You can also use <i>Drag&amp;Drop</i> to do this.
<h2>Add to Board</h2>
Starts the <a href=#31>ADD</a> command in the board window with this footprint.
You can also use <i>Drag&amp;Drop</i> to do this.
<h2>Copy to Library</h2>
Copies the selected device set, 3D package, footprint, or symbol into the loaded library.
You can also use <i>Drag&amp;Drop</i> to do this.
<h2>New package variant in Library</h2>
Creates a new package variant with the selected footprint in the current
device set of the loaded library.
You can also use <i>Drag&amp;Drop</i> to do this.
<h2>Open/Close Project</h2>
Opens or closes this project.
You can also click on the icon in the second column of the tree view to do this.
<h2>New</h2>
Opens a window with a new file of the given type.
<h2>Open</h2>
Opens this file in the propper window.
You can also use <i>Drag&amp;Drop</i> to do this.
<h2>Print...</h2>
Prints the file to the system printer. See the chapter on
<a href=#143>printing to the system printer</a> for more
information on how to use the print dialogs.
<p>
Printing a file through this context menu option will always print the file
as it is on disk, even if you have an open editor window in which you have
modified the file! Use the <a href=#102>PRINT</a> command to
print the drawing from an open editor window.<br>
<b>Please note that polygons in boards will not be automatically calculated
when printing via the context menu! Only the outlines will be drawn.
To print polygons in their calculated shape you have to load the drawing
into an editor window, enter <a href=#104>RATSNEST</a>
and then <a href=#102>PRINT</a></b>.
<h2>Run in ...</h2>
Runs this User Language Program in the current schematic, board or library.
You can also use <i>Drag&amp;Drop</i> to do this.
<h2>Execute in ...</h2>
Executes this script file in the current schematic, board or library.
You can also use <i>Drag&amp;Drop</i> to do this.
<h2>Load into Board</h2>
Loads this set of Design Rules into the current board.
You can also use <i>Drag&amp;Drop</i> to do this.


<a name=15>
<h1>Directories</h1>
The <i>Directories</i> dialog is used to define the directory paths
in which to search for files.
<p>
All entries may contain one or more directories, separated by a colon (<b><tt>':'</tt></b>),
in which to look for the various types of files.
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
On <b>Windows</b> the individual directory names are separated by a semicolon (<b><tt>';'</tt></b>).
</td></tr></table>
When entering an <a href=#86>OPEN</a>,
<a href=#135>USE</a>, <a href=#115>SCRIPT</a> or
<a href=#114>RUN</a> command, these paths will be searched
left-to-right to locate the file.
If the file dialog is used to access a file of one of these types, the directory into
which the user has navigated through the file dialog will be implicitly added to the
end of the respective search path.
<p>
The Example directories contain assets that can be used for reference. The toggle option "Include EAGLE examples" controls their visibility. All installed resources and examples are opened in read-only mode.
<p>
The special variables <tt>$HOME</tt> and <tt>$EAGLEDIR</tt> can be used to reference
the user's home directory and the EAGLE program directory, respectively.
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
On <b>Windows</b> the value of <tt>$HOME</tt> is either defined by the environment variable EAGLE_HOME (if set), or by the value of the registry key "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell&nbsp;Folders\Personal", which contains the actual name of the "My Documents" directory.
<br>All saved files are stored in $HOME\EAGLE folder.
</td></tr></table>
<br>
<table><tr><td valign="top"><img src="platforms-mac.png"><br><img src="platforms-lin.png"></td><td valign="middle">
On <b>MacOS</b> and <b>Linux</b> the value of <tt>$HOME</tt> is either defined by the environment variable EAGLE_HOME (if set), or the environment variable HOME.
If none of the environment variables is set, then $HOME is set to $EAGLEDIR.
<br>All saved files are stored in the folder $HOME\Documents\EAGLE.
</td></tr></table>


<a name=16>
<h1>Backup</h1>
The <i>Backup</i> dialog allows you to customize the
<a href=#404>automatic backup</a> function.
<h2>Maximum backup level</h2>
Defines how many backup copies of your EAGLE data files shall be kept
when regularly saving a file to disk with the WRITE command
(default is 9).
<h2>Auto backup interval (minutes)</h2>
Defines the maximum time after which EAGLE automatically creates a safety backup
copy of any modified drawing (default is 5).
<h2>Automatically save project file</h2>
If this option is checked, your project settings will be automatically saved when
you exit from the program.
Note that if you uncheck this option while you have a project open, this
project will not be saved when you close it, and thus this setting will not
be stored in the project's eagle.epf file. This means that the next time you
open the project, this option will be checked again. If you want this option
to remain unchecked for the current project, you need to manually select
"File/Save all" from the pulldown menu after unchecking this option.


<a name=17>
<h1>User Interface</h1>
The <i>User interface</i> dialog allows you to customize the
appearance of the layout, schematic and library
<a href=#23>editor windows</a>.
<h2>Controls</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Pulldown menu        </td><td width=20><td>activates the pulldown menu at the top of the editor window</td></tr>
<tr><td>Action toolbar       </td><td width=20><td>activates the action toolbar containing buttons for "File", "Print" etc.</td></tr>
<tr><td>Parameter toolbar    </td><td width=20><td>activates the dynamic parameter toolbar, which contains all the parameters that are available for the currently active command</td></tr>
<tr><td>Command buttons      </td><td width=20><td>activates the command buttons</td></tr>
<tr><td>Command texts        </td><td width=20><td>activates the textual command menu</td></tr>
<tr><td>Sheet thumbnails     </td><td width=20><td>aktivates the sheet thumbnail preview</td></tr>
</table>
<h2>Display</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Enable High DPI Scaling  </td><td width=20><td>sets the Qt::AA_EnableHighDpiScaling application attribute to true</td></tr>
<tr><td>Enable Auto Screen Scale Factor </td><td width=20><td>sets the Qt environment variable QT_AUTO_SCREEN_SCALE_FACTOR to 1</td></tr>
</table>
<h2>Layout</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Background     </td><td width=20><td>selects a black, white or colored background for the layout mode</td></tr>
<tr><td>Cursor               </td><td width=20><td>selects a small or large cursor for the layout mode</td></tr>
</table>
<h2>Schematic</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Background     </td><td width=20><td>selects a black, white or colored background for the schematic mode</td></tr>
<tr><td>Cursor               </td><td width=20><td>selects a small or large cursor for the schematic mode</td></tr>
</table>
<h2>Vertical text</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>New drawings         </td><td width=20><td>selects the reading direction of vertical texts in newly created drawings</td></tr>
<tr><td>This drawing         </td><td width=20><td>selects the reading direction of vertical texts in the currently loaded drawing</td></tr>
</table>
<h2>Help</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Bubble help          </td><td width=20><td>activates the "Bubble Help" function, which pops up a short hint about the meaning of several buttons when moving the cursor over them</td></tr>
<tr><td>User guidance        </td><td width=20><td>activates the "User Guidance" function, which displays a helping text telling the user what would be the next meaningful action when a command is active</td></tr>
</table>
<h2>Misc</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Always vector font   </td><td width=20><td>always displays texts in drawings with the builtin vector font, regardless of which font is actually set for a particular text</td></tr>
<tr><td>Mouse wheel zoom     </td><td width=20><td>defines the zoom factor that will be used to zoom in and out of an editor window when the mouse wheel is turned ('0' disables this feature, the sign of this value defines the direction of the zoom operation)</td></tr>
</table>


<a name=18>
<h1>Data collection and use</h1>
The <i>Data collection and use</i> dialog allows you to control privacy settings.
<h2>Available settings:</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Anonymous Analytics  </td><td width=20><td>allows anonymous data reports</td></tr>
<tr><td>Communication        </td><td width=20><td>allows email communication with the user</td></tr>
</table>


<a name=19>
<h1>Proxy settings</h1>
The <i>Proxy settings</i> dialog allows you to set proxy server.
By default Eagle uses system proxy settings.
<h2>Available proxy types:</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Use system settings  </td><td width=20><td>lets Eagle use system proxy settings</td></tr>
<tr><td>No proxy             </td><td width=20><td>uses direct connections</td></tr>
<tr><td>HTTP                 </td><td width=20><td>HTTP transparent proxying is used</td></tr>
<tr><td>SOCKS5               </td><td width=20><td>Socks5 proxying is used</td></tr>
</table>
<h2>Options:</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Server               </td><td width=20><td>the host name of the proxy host</td></tr>
<tr><td>Port                 </td><td width=20><td>the port of the proxy host</td></tr>
<tr><td>Proxy server requires password</td><td width=20><td>enables proxy authentication</td></tr>
<tr><td>Username             </td><td width=20><td>the username for proxy authentication</td></tr>
<tr><td>Password             </td><td width=20><td>the password for proxy authentication</td></tr>
</table>
<h2>Test settings</h2>
Tests connection to the server with set proxy settings and 30 seconds timeout.
Countdown and result is shown next to the button.


<a name=20>
<h1>Check for Update</h1>
The option "Help/Check for Update" in the Control Panel's pulldown menu opens
a dialog that displays whether there is a new version of EAGLE available on
the CadSoft server.
<p>
The <b>Configure</b> button opens a dialog in which you can specify if and
how often a check for new versions should be done automatically upon program
start (by default it checks once per day). If you need to use a proxy to access
the Internet, this can also be specified in the configuration dialog. In the "Host"
field enter the full name of the proxy host, without any
<tt>http://</tt> prefix, and enter an optional port number in the "Port" field.
<p>
If you would like to be informed about beta versions of EAGLE, you can check
the "Also check for beta versions" box.


<a name=21>
<h1>Keyboard and Mouse</h1>
The <i>modifier keys</i> (<tt>Alt</tt>, <tt>Ctrl</tt> and <tt>Shift</tt>) are used
to modify the behavior of certain mouse actions.
Note that depending on which operating system or window manager you use, some of these
keys (in combination with mouse events) may not be delivered to applications, which means
that some of the functions described here may not be available.
<h2>Alt</h2>
Pressing the <tt>Alt</tt> key switches to an alternate <a href=#61>GRID</a>.
This can typically be a finer grid than the normal one, which allows you to quickly
do some fine positioning in a dense area, for instance, where the normal grid might
be too coarse.
The alternate grid remains active as long as the <tt>Alt</tt> key is held pressed down.
<h2>Ctrl</h2>
Pressing the <tt>Ctrl</tt> key while clicking on the right mouse button toggles
between corresponding wire bend styles (only applies to commands that support wire
bend styles, like, for instance, <a href=#73>LINE</a>).
<p>
The <tt>Ctrl</tt> key together with the left mouse button controls special functionality
of individual commands, like, for instance, selecting an object at its origin with the
<a href=#83>MOVE</a> command.
<p>
If a command can select a group, the <tt>Ctrl</tt> key must be pressed together with
the right mouse button when selecting the group (otherwise a context menu for the
selected object would be opened).
<p>
<table><tr><td valign="top"><img src="platforms-mac.png"></td><td valign="middle">
On <b>Mac OS X</b> the <tt>Cmd</tt> key has to be used instead of the <tt>Ctrl</tt> key.
</td></tr></table>
<h2>Shift</h2>
Pressing the <tt>Shift</tt> key while clicking on the right mouse button reverses
the direction in which the wire bend styles are switched through (only applies to
commands that support wire bend styles, like, for instance, <a href=#73>LINE</a>).
<p>
The <tt>Shift</tt> key together with the left mouse button controls special functionality
of individual commands, like, for instance, deleting a higher level object with the
<a href=#49>DELETE</a> command.
<h2>Esc</h2>
Pressing the <tt>Esc</tt> key when a command is active will cancel the current
activity of that command without canceling the entire command (if there is text
in the command line, that text will be deleted first, and the next press of the
<tt>Esc</tt> key will act on the command).
For the <a href=#83>MOVE</a> command, for example, this means
that an object that is currently attached to the cursor
will be dropped and an other object can be selected.
<h2>Crsr-Up/Down</h2>
The keys <tt>Crsr-Up</tt> (cursor up) and <tt>Crsr-Down</tt> (cursor down) can be used in the
command line of an editor window to scroll through the command history.
<h2>Function Keys</h2>
Function keys can be assigned any commands by using the <a href=#35>ASSIGN</a> command.
<h2>Left Mouse Button</h2>
The left mouse button is generally used to select, draw or place objects.
<h2>Center Mouse Button</h2>
The center mouse button changes the current layer or mirrors the object currently
attached to the mouse cursor.
<p>
The following commands support the center mouse button:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#31>ADD</a>  </td><td width=20><td>mirror part</td></tr>
<tr><td><a href=#34>ARC</a>            </td><td width=20><td>change active layer</td></tr>
<tr><td><a href=#43>CIRCLE</a>      </td><td width=20><td>change active layer</td></tr>
<tr><td><a href=#47>COPY</a>          </td><td width=20><td>mirror object</td></tr>
<tr><td><a href=#66>INVOKE</a>      </td><td width=20><td>mirror gate</td></tr>
<tr><td><a href=#68>LABEL</a>        </td><td width=20><td>change active layer</td></tr>
<tr><td><a href=#73>LINE</a>          </td><td width=20><td>change active layer</td></tr>
<tr><td><a href=#83>MOVE</a>          </td><td width=20><td>mirror object or group</td></tr>
<tr><td><a href=#91>PASTE</a>        </td><td width=20><td>mirror group</td></tr>
<tr><td><a href=#98>POLYGON</a>    </td><td width=20><td>change active layer</td></tr>
<tr><td><a href=#105>RECT</a>          </td><td width=20><td>change active layer</td></tr>
<tr><td><a href=#113>ROUTE</a>        </td><td width=20><td>change active layer</td></tr>
<tr><td><a href=#123>SMD</a>            </td><td width=20><td>change active layer</td></tr>
<tr><td><a href=#131>TEXT</a>          </td><td width=20><td>change active layer</td></tr>
</table>
<p>
Click&amp;Drag with the center mouse button will pan the drawing within the editor
window.
<h2>Right Mouse Button</h2>
The right mouse button is mostly used to select a group, rotate objects attached to
the mouse cursor, change wire bend styles and several other command specific functions.
<p>
When selecting an object with the right mouse button, a context specific popup menu is
displayed from which commands that apply to this object can be selected.
If there is currently a command active that can be applied to a group, the popup menu
will contain an entry for this.
<p>
The following commands support the right mouse button:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#31>ADD</a>  </td><td width=20><td>rotate part</td></tr>
<tr><td><a href=#34>ARC</a>            </td><td width=20><td>change direction of arc</td></tr>
<tr><td><a href=#39>BUS</a>            </td><td width=20><td>change wire bend</td></tr>
<tr><td><a href=#41>CHANGE</a>      </td><td width=20><td>apply change to group</td></tr>
<tr><td><a href=#49>DELETE</a>      </td><td width=20><td>delete group</td></tr>
<tr><td><a href=#62>GROUP</a>        </td><td width=20><td>close polygon</td></tr>
<tr><td><a href=#66>INVOKE</a>      </td><td width=20><td>rotate gate</td></tr>
<tr><td><a href=#68>LABEL</a>        </td><td width=20><td>rotate label</td></tr>
<tr><td><a href=#73>LINE</a>          </td><td width=20><td>change wire bend</td></tr>
<tr><td><a href=#80>MIRROR</a>      </td><td width=20><td>mirror group</td></tr>
<tr><td><a href=#83>MOVE</a>          </td><td width=20><td>rotate object, select group</td></tr>
<tr><td><a href=#85>NET</a>            </td><td width=20><td>change wire bend</td></tr>
<tr><td><a href=#89>PAD</a>            </td><td width=20><td>rotate pad</td></tr>
<tr><td><a href=#91>PASTE</a>        </td><td width=20><td>rotate group</td></tr>
<tr><td><a href=#93>PIN</a>            </td><td width=20><td>rotate pin</td></tr>
<tr><td><a href=#98>POLYGON</a>    </td><td width=20><td>change wire bend</td></tr>
<tr><td><a href=#111>RIPUP</a>        </td><td width=20><td>cycle on ripup parameters options, ripup group</td></tr>
<tr><td><a href=#112>ROTATE</a>      </td><td width=20><td>rotate group</td></tr>
<tr><td><a href=#113>ROUTE</a>        </td><td width=20><td>change wire bend</td></tr>
<tr><td><a href=#123>SMD</a>            </td><td width=20><td>rotate smd</td></tr>
<tr><td><a href=#127>SPLIT</a>        </td><td width=20><td>change wire bend</td></tr>
<tr><td><a href=#131>TEXT</a>          </td><td width=20><td>rotate text</td></tr>
</table>
<h2>Mouse Wheel</h2>
Inside an editor window the mouse wheel can be used to zoom in and out.


<a name=22>
<h1>Selecting objects in dense areas</h1>
When you try to select an object at a position where several objects
are placed close together, a four way arrow and the question
<p>
<i>Select highlighted object? (left=yes, right=next, ESC=cancel)</i>
<p>
indicates that you can now choose one of these objects.
<p>
Press the right mouse button to switch to the next object.
<p>
Press the left mouse button to select the highlighted object.
<p>
Press Esc to cancel the selection procedure.
<p>
The command
<pre>
<a href=#116>SET</a> Select_Factor select_radius;
</pre>
defines the selection radius.
<p>
If the original selection was done with the right mouse button, a context specific
popup menu will be displayed which applies to the first selected object, and which
contains "Next" as the first entry. Clicking on this entry will cyclically switch
through the objects within the selection radius.


<a name=23>
<h1>Editor Windows</h1>
EAGLE knows different types of data files, each of which has its own
type of editor window. By double clicking on one of the items in the
<a href=#13>Control Panel</a> or by selecting a file from the
<b>File/Open</b> menu, an editor
window suitable for that file will be opened.
<ul>
<li><a href=#24>Library Editor</a>
<li><a href=#27>Schematic Editor</a>
<li><a href=#26>Board Editor</a>
<li><a href=#28>Text Editor</a>
</ul>


<a name=24>
<h1>Library Editor</h1>
The <i>Library Editor</i> is used to edit a part library (<tt>*.lbr</tt>).
<p>
After opening a new library editor window, the edit area will display the library's
table-of-contents, i.e. a list of the devices, footprints, 3D packages, and symbols in the library.
(Note that prior to EAGLE 9.1, footprints were referred to as packages.)
From this view, you can manage the devices, footprints, and symbols: open them for
editing, rename them, delete them, duplicate them, etc. Click the <b>Add</b> buttons
at the bottom of each list to create new devices, footprints, and symbols or to import
them from another library. Click the <b>Import 3D Package</b> button to import a 3D
package from another library, add one from the web, or create one using the package
generator.


<a name=25>
<h1>Edit Library Object</h1>
In library edit mode you can edit footprints, symbols, and devices.
<p>
<b>Footprint:</b> the footprint definition.
<p>
<b>Symbol:</b> the symbol as it appears in the circuit diagram.
<p>
<b>Device:</b> definition of the whole component. Contains one or more
package variants and one or several symbols (e.g. gates).
The symbols can be different from each other.
<p>
Click on the <b>Devices</b>, <b>Footprints</b> or
<b>Symbols</b> tabs to view the respective items.
<p>
If you want to create a new object, write the name of the new object into
the <b>New</b> field. You can also edit an existing object
by typing its name into this field.
<p>
To import an existing device, footprint, or symbol from another library, select
the corresponding tab in the dialog, then click the <b>Import...</b> button
at the bottom of the dialog. A dialog will open that shows the devices, footprints,
or symbols available from the currently in-use libraries. Select the item you
wish to import and click <b>OK</b>. The item will be copied to the open library
and opened for editing. Note that importing a device will also import all of
3D packages, footprints and symbols it references.


<a name=26>
<h1>Board Editor</h1>
The <i>Board Editor</i> is used to edit a board (<tt>*.brd</tt>).
<p>
When there is a schematic file (<tt>*.sch</tt>) with the same name as the
board file (in the same directory), opening a board editor window will
automatically open a <a href=#27>Schematic Editor</a>
window containing that file and will put it on the desktop
as an icon. This is necessary to have the schematic file loaded when editing
the board causes modifications that have to be
<a href=#406>back-annotated</a>
to the schematic.
<h2>Board Shape</h2>
When a single closed non-self-intersecting shape is being drawn on the dimension layer,
it will be detected as the board shape. Inner closed shapes are treated as cutouts,
as are closed shapes drawn on the milling layer. The board shape is displayed in
another color aiding the user in creating correct geometries for manufacturing.


<a name=27>
<h1>Schematic Editor</h1>
The <i>Schematic Editor</i> is used to edit a schematic (<tt>*.sch</tt>).
<p>
When there is a board file (<tt>*.brd</tt>) with the same name as the
schematic file (in the same directory), opening a schematic editor window will
automatically open a <a href=#26>Board Editor</a>
window containing that file and will put it on the desktop
as an icon. This is necessary to have the board file loaded when editing
the schematic causes modifications that have to be
<a href=#406>forward-annotated</a>
to the board.
<p>
The combo box in the action toolbar of the schematic editor window allows
you to switch between the various sheets of the schematic, or to add new
sheets to the schematic (this can also be done using the
<a href=#54>EDIT</a> command).


<a name=28>
<h1>Text Editor</h1>
The <i>Text Editor</i> is used to edit any kind of text.
<p>
The text must be a pure ASCII file and must not contain any control codes.
The main area of use for the text editor is writing
<a href=#173>User Language Programs</a> and
<a href=#115>Script files</a>.
<h2>Using an external text editor</h2>
If you prefer to use an external text editor instead of EAGLE's builtin text
editor, you can specify the command necessary to start that editor in the
"Options/User interface" dialog.
<p>
Within that command the following placeholders will be replaced with
actual values:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%C</tt></td><td width=20><td>the column in which to place the cursor (currently always <tt>1</tt>)</td></tr>
<tr><td><tt>%F</tt></td><td width=20><td>the name of the file to load</td></tr>
<tr><td><tt>%L</tt></td><td width=20><td>the line in which to place the cursor</td></tr>
</table>
<p>
If the command consists only of a hyphen (<tt>'-'</tt>), EAGLE will never open
a text editor window. This may be useful for people who always start their text
editor by themselves.
<p>
The following restrictions apply when using an external text editor:
<ul>
<li>The external text editor runs as a separate process, and EAGLE has no way of
    knowing whether the loaded file has been modified or not. It is up to you to
    save the file after you have made modifications.
<li>If the same file is loaded into the text editor several times, it depends on
    the configuration of the text editor in use whether it opens a new window each
    time, or whether it loads the file into the same window.
<li>The external text editor windows do not show up in EAGLE's window list, and
    are therefore not stored in the project file, and are not reopened when the project
    is opened again later.
<li>When leaving EAGLE, the external text editor processes will be terminated.
    It depends on the operating system and the particular text editor whether or
    not you are queried if a file has been modified and should be saved.
<li>The "File/Save all" function will not save files edited with an external text editor.
<li>The update report that may be given when loading a file from an older version
    of EAGLE is always displayed with the internal text editor.
</ul>


<a name=29>
<h1>Editor Commands</h1>
<h2>Change Mode/File Commands</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#45>CLOSE</a>     </td><td width=20><td>Close drawing after editing</td></tr>
<tr><td><a href=#54>EDIT</a>      </td><td width=20><td>Load/create a drawing</td></tr>
<tr><td><a href=#57>EXPORT</a>    </td><td width=20><td>Generate ASCII list (e.g. netlist)</td></tr>
<tr><td><a href=#132>EXPORTSTEP</a>    </td><td width=20><td>Exports the board into a STEP file.</td></tr>
<tr><td><a href=#86>OPEN</a>      </td><td width=20><td>Open library for editing</td></tr>
<tr><td><a href=#103>QUIT</a>      </td><td width=20><td>Quit EAGLE</td></tr>
<tr><td><a href=#107>REMOVE</a>    </td><td width=20><td>Delete files/library elements</td></tr>
<tr><td><a href=#115>SCRIPT</a>    </td><td width=20><td>Execute command file</td></tr>
<tr><td><a href=#135>USE</a>       </td><td width=20><td>Load library for placing elements</td></tr>
<tr><td><a href=#141>WRITE</a>     </td><td width=20><td>Save drawing/library</td></tr>
</table>
<h2>Edit Drawings or Libraries</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#31>ADD</a>       </td><td width=20><td>Add element to drawing/symbol to device</td></tr>
<tr><td><a href=#33>ALIGN</a>       </td><td width=20><td>Aligns selected objects in the Layout editor</td></tr>
<tr><td><a href=#34>ARC</a>       </td><td width=20><td>Draw arc</td></tr>
<tr><td><a href=#36>ATTRIBUTE</a>  </td><td width=20><td>Define attributes</td></tr>
<tr><td><a href=#43>CIRCLE</a>    </td><td width=20><td>Draw circle</td></tr>
<tr><td><a href=#44>CLASS</a>    </td><td width=20><td>Define net classes</td></tr>
<tr><td><a href=#47>COPY</a>      </td><td width=20><td>Copy objects/elements</td></tr>
<tr><td><a href=#48>CUT</a>       </td><td width=20><td>Cut previously defined group</td></tr>
<tr><td><a href=#49>DELETE</a>    </td><td width=20><td>Delete objects</td></tr>
<tr><td><a href=#50>DESCRIPTION</a> </td><td width=20><td>Change an object's description</td></tr>
<tr><td><a href=#62>GROUP</a>     </td><td width=20><td>Define group for upcoming operation</td></tr>
<tr><td><a href=#64>HOLE</a>      </td><td width=20><td>Define non-conducting hole</td></tr>
<tr><td><a href=#71>LAUNCH</a>     </td><td width=20><td>Launch web-based 3d package generator and search</td></tr>
<tr><td><a href=#72>LAYER</a>     </td><td width=20><td>Create/change layer</td></tr>
<tr><td><a href=#73>LINE</a>      </td><td width=20><td>Draw line or routed track</td></tr>
<tr><td><a href=#80>MIRROR</a>    </td><td width=20><td>Mirror objects</td></tr>
<tr><td><a href=#81>MITER</a>    </td><td width=20><td>Miter wire/line joints</td></tr>
<tr><td><a href=#82>MODULE</a>      </td><td width=20><td>Create module and add module instances</td></tr>
<tr><td><a href=#83>MOVE</a>      </td><td width=20><td>Move or rotate objects</td></tr>
<tr><td><a href=#84>NAME</a>      </td><td width=20><td>Name object</td></tr>
<tr><td><a href=#91>PASTE</a>     </td><td width=20><td>Paste previously cut group to a drawing</td></tr>
<tr><td><a href=#92>PATTERN</a>      </td><td width=20><td>Copies the selected element in the layout to a given number of elements and arranges them in a linear or circular pattern with given offsets.</td></tr>
<tr><td><a href=#100>PORT</a>   </td><td width=20><td>Add port to module</td></tr>
<tr><td><a href=#98>POLYGON</a>   </td><td width=20><td>Draw polygon</td></tr>
<tr><td><a href=#99>POLYGONIZE</a>   </td><td width=20><td>Convert closed set of wires into a polygon or vice versa</td></tr>
<tr><td><a href=#105>RECT</a>      </td><td width=20><td>Draw rectangle</td></tr>
<tr><td><a href=#112>ROTATE</a>    </td><td width=20><td>Rotate objects</td></tr>
<tr><td><a href=#119>SLICE</a>     </td><td width=20><td>Split lines</td></tr>
<tr><td><a href=#122>REPOSITION</a> </td><td width=20><td>Prepare NAME/VALUE texts for moving</td></tr>
<tr><td><a href=#127>SPLIT</a>     </td><td width=20><td>Bend wires/lines (tracks, nets, etc.)</td></tr>
<tr><td><a href=#131>TEXT</a>      </td><td width=20><td>Add text to a drawing</td></tr>
<tr><td><a href=#136>VALUE</a>     </td><td width=20><td>Enter/change value for component</td></tr>
</table>
<h2>Special Commands for Boards</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#53>DRC</a>       </td><td width=20><td>Perform design rule check</td></tr>
<tr><td><a href=#56>ERRORS</a>    </td><td width=20><td>Show DRC errors</td></tr>
<tr><td><a href=#58>FANOUT</a>     </td><td width=20><td>Fanout a device or signal</td></tr>
<tr><td><a href=#74>LOCK</a>    </td><td width=20><td>Lock component's position</td></tr>
<tr><td><a href=#76>MANUFACTURING</a>    </td><td width=20><td>Toggle manufacturing flyout</td></tr>
<tr><td><a href=#104>RATSNEST</a>  </td><td width=20><td>Show shortest air lines</td></tr>
<tr><td><a href=#110>REPLACE</a>   </td><td width=20><td>Replace component</td></tr>
<tr><td><a href=#111>RIPUP</a>     </td><td width=20><td>Ripup routed track</td></tr>
<tr><td><a href=#113>ROUTE</a>     </td><td width=20><td>Route signal</td></tr>
<tr><td><a href=#118>SIGNAL</a>    </td><td width=20><td>Define signal (air line)</td></tr>
<tr><td><a href=#138>VIA</a>       </td><td width=20><td>Place via-hole</td></tr>
</table>
<h2>Special Commands for Schematics</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#38>BOARD</a>      </td><td width=20><td>Create a board from a schematic</td></tr>
<tr><td><a href=#39>BUS</a>       </td><td width=20><td>Draw bus line</td></tr>
<tr><td><a href=#55>ERC</a>       </td><td width=20><td>Perform electrical rule check</td></tr>
<tr><td><a href=#60>GATESWAP</a>  </td><td width=20><td>Swap equivalent 'gates'</td></tr>
<tr><td><a href=#66>INVOKE</a>    </td><td width=20><td>Add certain 'gate' from a placed device</td></tr>
<tr><td><a href=#67>JUNCTION</a>  </td><td width=20><td>Place connection point</td></tr>
<tr><td><a href=#68>LABEL</a>     </td><td width=20><td>Provide label to bus or net</td></tr>
<tr><td><a href=#85>NET</a>       </td><td width=20><td>Define net</td></tr>
<tr><td><a href=#97>PINSWAP</a>   </td><td width=20><td>Swap equivalent pins</td></tr>
</table>
<h2>Special Commands for Libraries</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#46>CONNECT</a>   </td><td width=20><td>Define pin/pad assignment</td></tr>
<tr><td><a href=#88>PACKAGE</a>   </td><td width=20><td>Define package for device</td></tr>
<tr><td><a href=#89>PAD</a>       </td><td width=20><td>Add pad to a package</td></tr>
<tr><td><a href=#93>PIN</a>       </td><td width=20><td>Add pin to a symbol</td></tr>
<tr><td><a href=#101>PREFIX</a>    </td><td width=20><td>Define default prefix for device</td></tr>
<tr><td><a href=#107>REMOVE</a>    </td><td width=20><td>Delete library elements</td></tr>
<tr><td><a href=#109>RENAME</a>    </td><td width=20><td>Rename symbol/package/device</td></tr>
<tr><td><a href=#123>SMD</a>       </td><td width=20><td>Add smd pad to a package</td></tr>
<tr><td><a href=#130>TECHNOLOGY</a> </td><td width=20><td>Define technologies for a device</td></tr>
<tr><td><a href=#136>VALUE</a>     </td><td width=20><td>Define if value text can be changed</td></tr>
</table>
<h2>Change Screen Display and User Interface</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#35>ASSIGN</a>    </td><td width=20><td>Assign keys</td></tr>
<tr><td><a href=#41>CHANGE</a>    </td><td width=20><td>Change parameters</td></tr>
<tr><td><a href=#52>DISPLAY</a>   </td><td width=20><td>Display/hide layers</td></tr>
<tr><td><a href=#61>GRID</a>      </td><td width=20><td>Define grid/unit</td></tr>
<tr><td><a href=#79>MENU</a>      </td><td width=20><td>Configure command menu</td></tr>
<tr><td><a href=#116>SET</a>       </td><td width=20><td>Set program parameters</td></tr>
<tr><td><a href=#139>WINDOW</a>    </td><td width=20><td>Choose screen window</td></tr>
</table>
<h2>Miscellaneous Commands</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#37>AUTO</a>      </td><td width=20><td>Start Autorouter</td></tr>
<tr><td><a href=#63>HELP</a>      </td><td width=20><td>Show help page</td></tr>
<tr><td><a href=#65>INFO</a>      </td><td width=20><td>Show information about object</td></tr>
<tr><td><a href=#77>MARK</a>      </td><td width=20><td>Set/remove mark (for measuring)</td></tr>
<tr><td><a href=#87>OPTIMIZE</a>  </td><td width=20><td>Optimize (join) wire segments</td></tr>
<tr><td><a href=#42>PAINTROLLER</a>  </td><td width=20><td>Transfers selected properties of a selected object to other objects of the same type.</td></tr>
<tr><td><a href=#102>PRINT</a>    </td><td width=20><td>Print to the system printer</td></tr>
<tr><td><a href=#106>REDO</a>      </td><td width=20><td>Redo commands</td></tr>
<tr><td><a href=#114>RUN</a>        </td><td width=20><td>Run User Language Program</td></tr>
<tr><td><a href=#117>SHOW</a>      </td><td width=20><td>Highlight object</td></tr>
<tr><td><a href=#133>UNDO</a>      </td><td width=20><td>Undo commands</td></tr>
<tr><td><a href=#134>UPDATE</a>  </td><td width=20><td>Update library objects</td></tr>
<tr><td><a href=#128>FUSIONSYNC</a>  </td><td width=20><td>Synchronise a board with a Fusion PCB</td></tr>
<tr><td><a href=#129>FUSIONTEAM</a>  </td><td width=20><td>Publish design files (board and schematic) and/or manufacturing files to Fusion Team.</td></tr>
</table>


<a name=30>
<h1>Command Syntax</h1>
EAGLE commands can be entered in different ways:
<ul>
<li>with the keyboard as text
<li>with the mouse by selecting menu items or clicking on icons
<li>with assigned keys (see <a href=#35>ASSIGN</a> command)
<li>with command files (see <a href=#115>SCRIPT</a> command)
</ul>
All these methods can be mixed.
<p>
Commands and parameters in <tt>CAPITAL LETTERS</tt> are entered directly (or
selected in the command menu with the mouse). For the input there is
no difference between small and capital letters.
<p>
Parameters in <tt>lowercase letters</tt> are replaced by names, number values or
key words. Example:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Syntax:   </td><td width=20><td><tt>GRID grid_size grid_multiple;</tt></td></tr>
<tr><td>Input:    </td><td width=20><td><tt>GRID 1 10;</tt></td></tr>
</table>
<h2>Shorten key words</h2>
For command names and other key words, only so many characters must be
entered that they clearly differ from other key words.
<h2>Alternative Parameters</h2>
The sign | means that alternative parameters can be indicated. Example:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Syntax:   </td><td width=20><td><tt>SET BEEP OFF | ON;</tt></td></tr>
<tr><td>Input:    </td><td width=20><td><tt>SET BEEP OFF;</tt></td></tr>
<tr><td>          </td><td width=20><td>or</td></tr>
<tr><td>          </td><td width=20><td><tt>SET BEEP ON;</tt></td></tr>
</table>
<h2>Repetition Points</h2>
The signs .. mean that the function can be executed several times
or that several parameters of the same type are allowed. Example:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Syntax:   </td><td width=20><td><tt>DISPLAY option layer_name..</tt></td></tr>
<tr><td>Input:    </td><td width=20><td><tt>DISPLAY TOP PINS VIAS</tt></td></tr>
</table>
<h2>Coordinates</h2>
The sign &#149; normally means that an object has to be selected with the
left mouse button at this point in the command. Example:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Syntax:   </td><td width=20><td><tt>MOVE &#149; &#149;..</tt></td></tr>
<tr><td>Input:    </td><td width=20><td><tt>MOVE</tt></td></tr>
<tr><td>          </td><td width=20><td><tt>Mouse click on the first element to be moved</tt></td></tr>
<tr><td>          </td><td width=20><td><tt>Mouse click on the target position</tt></td></tr>
<tr><td>          </td><td width=20><td><tt>Mouse click on the second element to be moved</tt></td></tr>
<tr><td>          </td><td width=20><td><tt>etc.</tt></td></tr>
</table>
<p>
This example also explains the meaning of the repetition points for
commands with mouse clicks.
<p>
For the program each mouse click is the input of a coordinate. If
coordinates are to be entered as text, the input via the keyboard
must be as follows:
<pre>
(x y)
</pre>
x and y are numbers in the unit which has been selected with the GRID
command. The input as text is mainly required for script files.<br>
If a unit other than the one selected with the GRID command shall be used,
it can be appended to the given coordinates, as in
<pre>
(100mil 200mil)
</pre>
Allowed units are <tt>mm</tt>, <tt>mic</tt>, <tt>mil</tt> and <tt>in</tt>.
It is possible to use different units for x and y.<br>
The special coordinate
<pre>
(@)
</pre>
can be used to reference the current position of the mouse cursor within
the draw window. For example, the input
<pre>
MOVE R1 (@)
</pre>
would move the part named R1 to the place currently pointed to with the mouse.
<p>
Any combination of the following modifiers may follow the opening brace
in order to simulate a particular key that is held pressed with the
"mouse click" or to change the type of coordinates:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>&gt;</tt></td><td width=20><td>right mouse button click</td></tr>
<tr><td><tt>A   </tt></td><td width=20><td>Alt key</td></tr>
<tr><td><tt>C   </tt></td><td width=20><td>Ctrl key</td></tr>
<tr><td><tt>P   </tt></td><td width=20><td>Polar coordinates (relative to the <a href=#77>mark</a>, x = radius, y = angle in degrees, counterclockwise)</td></tr>
<tr><td><tt>R   </tt></td><td width=20><td>Relative coordinates (relative to the <a href=#77>mark</a>)</td></tr>
<tr><td><tt>S   </tt></td><td width=20><td>Shift key</td></tr>
</table>
For example, the input
<pre>
(CR&gt; 1 2)
</pre>
would result in a "right button mouse click" at (1&nbsp;2) relative to the <a href=#77>mark</a>,
with the Ctrl key held down (of course what happens with this kind of input
will depend on the actual command). Note that if there is currently no mark
defined, coordinates with <tt>R</tt> or <tt>P</tt> will be relative to the
drawing's origin. Also, the modifier characters are not case sensitive, their
sequence doesn't matter and there doesn't have to be a blank between them and
the first coordinate digit. So the above example could also be written as
<tt>(r&gt;c1&nbsp;2)</tt>.
Values entered as "polar coordinates" will be stored internally as the corresponding
pair of (x&nbsp;y) coordinates.
<p>
As an example for entering coordinates as text let's assume you wish to enter the exact
dimensions for board outlines:
<pre>
GRID 1 MM;
CHANGE LAYER DIMENSION;
LINE 0 (0 0) (160 0) (160 100) (0 100) (0 0);
GRID LAST;
</pre>
<h2>Decimal numbers</h2>
When entering decimal numbers in the command line of the editor window or in
dialog input fields, you can use the comma as the decimal delimiter (as in <tt>12,34</tt>),
if your locale settings allow this. However, when writing a script or a ULP that
returns EAGLE commands through the <tt>exit()</tt> function, you should always
use the 'dot' as the decimal delimiter (as in <tt>12.34</tt>), because otherwise
your script or ULP might not work on other systems. In general, it is recommended
to always use the 'dot' as the decimal delimiter.
<h2>Semicolon</h2>
The semicolon (';') terminates commands. A command needs to be terminated
with a semicolon if there fewer than the maximum possible number of options.
For example the command
<pre>
WINDOW;
</pre>
redraws the drawing window, whereas
<pre>
WINDOW FIT
</pre>
scales the drawing to fit entirely into the drawing window. There is no semicolon necessary here because it is already clear that the command is complete.


<a name=31>
<h1>ADD</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Add elements into a drawing.<br>
Add symbols into a device.
<dt>
<b>Syntax</b>
<dd>
<tt>ADD footprint_name[@library_name] [name] [orientation] &#149;..</tt><br>
<tt>ADD device_name[@library_name]  [P3D=3d_package] [name [gate]] [orientation] &#149;..</tt><br>
<tt>ADD symbol_name                 [name] [options] &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> mirrors the part.<br>
<mb>Right</mb> rotates the part.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#134>UPDATE</a>,
<a href=#135>USE</a>,
<a href=#66>INVOKE</a>
<p>
The ADD command fetches a circuit symbol (gate) or a footprint from the active library and places it into the drawing.
<p>
During device definition the ADD command fetches a symbol into the device.
<p>
Usually you click the ADD command and select the footprint or symbol from the menu which opens. If necessary, parameters can now be entered via the keyboard.
<p>
If <tt>device_name</tt> contains wildcard characters (<tt>'*'</tt> or <tt>'?'</tt>) and more
than one device matches the pattern, the ADD dialog will be opened and the specific device
can be selected from the list.
Note that the <i>Description</i> checkbox in the ADD dialog will be unchecked after
any ADD command with a <tt>device_name</tt> has been given in the command line, no matter
if it contains wildcards or not. This is because a <tt>device_name</tt> entered in the
command line is only searched for in the device names, not in the descriptions.
<p>
The footprint or symbol is placed with the left button and rotated with the right button. After it has been placed another copy is immediately hanging from the cursor.
<p>
If there is already a device or footprint with the same name (from the same library) in the drawing,
and the library has been modified after the original object was added, an automatic
<a href=#134>library update</a> will be started and you will be asked whether
objects in the drawing shall be replaced with their new versions.
<b>Note: You should always run a <a href=#53>Design Rule Check</a> (DRC) and an
<a href=#55>Electrical Rule Check</a> (ERC) after a library update has been performed!</b>
<h2>Fetching a Footprint or Symbol into a Drawing</h2>
<h3>Wildcards</h3>
The ADD command can be used with wildcards (<tt>'*'</tt> or <tt>'?'</tt>) to find
a specific device. The ADD dialog offers a tree view of the matching
devices, as well as a preview of the device and package variant.
<p>
To add directly from a specific library, the command syntax
<pre>
ADD devicename@libraryname
</pre>
can be used. <tt>devicename</tt> may contain wildcards and <tt>libraryname</tt> can
be either a plain library name (like "ttl" or "ttl.lbr"), a full
file name (like "/home/mydir/myproject/ttl.lbr" or "../lbr/ttl"), or the URN of a downloaded managed library (like "urn:adsk.eagle:library:462"). In case of blanks in the file name
the whole expression has to be enclosed by apostrophs (like ADD 'DEV1A@/home/my dir/ttl.lbr').
<h3>3D Packages</h3>
When adding a device to a drawing, the device's 3D package can be specified using the syntax:
<pre>
ADD devicename[@libraryname] P3D=3d_package
</pre>
where <tt>3d_package</tt> is the name or URN of a 3D package. This will filter the list of devices matched by <tt>devicename</tt> (and <tt>libraryname</tt>, if specified) to those containing the specified 3D package. If no 3D package is specified, all 3D packages associated with the matched devices will be shown in the ADD dialog. (If there's a single matching device and that device has zero or one 3D packages, that device &ndash; and 3D package, if it exists &ndash; will be selected and the ADD dialog will not be shown.) The <tt>3d_package</tt> term is not case-sensitive and does not support wildcards. Example:
<pre>
ADD PINHD-1x4 P3D=PINHD-1x4-5.84MM
</pre>
add the PINHD-1x4 device to the schematic (and board) and assigns it the 3D package PINHD-1x4-5.84MM.
<h3>Names</h3>
The footprint_name, device_name or symbol_name parameter is the name under which the footprint, device or symbol is stored in the library.
It is usually selected from a menu. The name parameter is the name which the element is to receive in the drawing.
If the name could be interpreted as an orientation or option, it must be enclosed in single quotes.
If a name is not explicitly given it will receive an automatically generated name.
<p>
Example:
<pre>
ADD DIL14 IC1 &#149;
</pre>
fetches the DIL14 footprint to the board and gives it the name IC1.
<p>
If no name is given in the schematic, the gate will receive the prefix that was specified in the device definition with <a href=#101>PREFIX</a>, expanded with a sequential number (e.g. IC1).
<p>
Example:
<pre>
ADD 7400 &#149; &#149; &#149; &#149; &#149;
</pre>
This will place a sequence of five gates from 7400 type components. Assuming that the prefix is defined as "IC" and that the individual gates within a 7400 have the names A..D, the gates in the schematic will be named IC1A, IC1B, IC1C, IC1D, IC2A. (If elements with the same prefix have already been placed the counting will proceed from the next sequential number.) See also <a href=#66>INVOKE</a>.
<p>
While an object is attached to the cursor, you can change the name under which
it will be added to the drawing. This allows you to add several parts of the same
type, but with different, explicitly defined names:
<p>
Example:
<pre>
ADD CAP C1 &#149; C5 &#149; C7 &#149;
</pre>
<h3>Particular Gates</h3>
To fetch a particular gate of a newly added device the name of that gate can be given following the part name:
<p>
Example:
<pre>
ADD 7400 IC1 A &#149;
</pre>
This is mainly useful if a schematic is to be generated through a script. Note that if a particular
gate is added, no other gates with add level MUST or ALWAYS will be fetched automatically, and you will have to
use the <a href=#66>INVOKE</a> command to invoke at least the MUST gates (otherwise
the <a href=#55>Electrical Rule Check</a> will report them as missing).
<h3>Orientation</h3>
This parameter defines the orientation of the object in the drawing.
Objects are normally rotated using the right mouse button.
In <a href=#115>Script</a> files textual descriptions of this parameter are used:
<p>
<b><tt>[S][M]Rnnn</tt></b>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b><tt>S</tt></b>   </td><td width=20><td>sets the <b>S</b>pin flag, which disable keeping texts readable from the bottom or right side of the drawing (only available in a board context)</td></tr>
<tr><td><b><tt>M</tt></b>   </td><td width=20><td>sets the <b>M</b>irror flag, which mirrors the object about the y-axis</td></tr>
<tr><td><b><tt>Rnnn</tt></b></td><td width=20><td>sets the <b>R</b>otation to the given value, which may be in the range <tt>0.0</tt>...<tt>359.9</tt> (at a resolution of 0.1 degrees) in a board context, or one of <tt>0</tt>, <tt>90</tt>, <tt>180</tt> or <tt>270</tt> in a schematic context (angles may be given as negative values, which will be converted to the corresponding positive value)</td></tr>
</table>
<p>
The key letters <b><tt>S</tt></b>, <b><tt>M</tt></b> and <b><tt>R</tt></b> may be given
in upper- or lowercase, and there must be at least <b><tt>R</tt></b> followed by a number.
<p>
If the <b>M</b>irror flag is set in an element as well as in a text within the
element's footprint, they cancel each other out.
The same applies to the <b>S</b>pin flag.
<p>
Examples:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>R0 </td><td width=20><td>no rotation</td></tr>
<tr><td>R90    </td><td width=20><td>rotated 90&deg; counterclockwise</td></tr>
<tr><td>R-90   </td><td width=20><td>rotated 90&deg; clockwise (will be converted to 270&deg;)</td></tr>
<tr><td>MR0    </td><td width=20><td>mirrored about the y-axis</td></tr>
<tr><td>SR0    </td><td width=20><td>spin texts</td></tr>
<tr><td>SMR33.3</td><td width=20><td>rotated 33.3&deg; counterclockwise, mirrored and spin texts</td></tr>
</table>
<p>
Default: R0
<p>
<pre>
ADD DIL16 R90 (0 0);
</pre>
places a 16-pin DIL footprint, rotated 90 degrees counterclockwise, at coordinates (0 0).
<h3>Error messages</h3>
An error message appears if a gate is to be fetched from a device which is not fully defined (see <a href=#38>BOARD</a> command). This can be prevented with the "<a href=#116>SET</a> CHECK_CONNECTS OFF;" command. Take care: The BOARD command will perform this check in any case. Switching it off is only sensible if no pcb is to be made.
<h2>Fetch Symbol into Device</h2>
During device definition the ADD command fetches a previously defined symbol into the device. Two parameters (swaplevel and addlevel) are possible, and these can be entered in any sequence. Both can be preset and changed with the <a href=#41>CHANGE</a> command. The value entered with the ADD command is also retained as a default value.
<h3>Swaplevel</h3>
The swaplevel is an integer number, to which the following rules apply:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>0:  </td><td width=20><td>The symbol (gate) can not be swapped with any other in the schematic.</td></tr>
<tr><td>&gt;0 </td><td width=20><td>The symbol (gate) can be swapped with any other symbol of the same type in the schematic that has the same swaplevel (including swapping between different devices).</td></tr>
</table>
<p>
Default: 0
<h3>Addlevel</h3>
The following possibilities are available for this parameter:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>Next</tt>   </td><td width=20><td>If a device has more than one gate, the symbols are fetched into the schematic with Addlevel Next.</td></tr>
<tr><td><tt>Must</tt>   </td><td width=20><td>If any symbol from a device is fetched into the schematic, then a symbol defined with Addlevel Must must also appear. This happens automatically. It cannot be deleted until all the other symbols in the device have been deleted. If the only symbols remaining from a device are Must-symbols, the DELETE command will delete the entire device.</td></tr>
<tr><td><tt>Always</tt> </td><td width=20><td>Like Must, although a symbol with Addlevel Always can be deleted and brought back into the schematic with <a href=#66>INVOKE</a>.</td></tr>
<tr><td><tt>Can</tt>    </td><td width=20><td>If a device contains Next-gates, then Can-gates are only fetched if explicitly called with INVOKE. A symbol with Addlevel Can is only then fetched into the schematic with ADD if the device only contains Can-gates and Request-gates.</td></tr>
<tr><td><tt>Request</tt></td><td width=20><td>This property is usefully applied to devices' power-symbols. Request-gates can only be explicitly fetched into the schematic (INVOKE) and are not internally counted. The effect of this is that in devices with only one gate and one voltage supply symbol, the gate name is not added to the component name. In the case of a 7400 with four gates (plus power supply) the individual gates in the schematic are called, for example, IC1A, IC1B, IC1C and IC1D. A 68000 with only one <i>Gate</i>, the processor symbol, might on the other hand be called IC1, since its separate voltage supply symbol is not counted as a gate.  </td></tr>
</table>
<p>
Example:
<pre>
ADD PWR 0 REQUEST &#149;
</pre>
fetches the PWR symbol (e.g. a power pin symbol), and defines a Swaplevel of 0 (not swappable) and the Addlevel <i>Request</i> for it.


<a name=32>
<h1>ADDMODEL</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Used to convert a single part, or an entire schematic to a spice-compatible schematic.
<dt>
<b>Syntax</b>
<dd>
<tt>ADDMODEL name ..</tt>
</dl>
<b>See also</b> <a href=#120>SIM</a>
<p>
    This command converts a single part, or the entire current schematic (Select all before starting command) to a spice
    simulation-capable schematic by modifying parts so they include the neccessary attributes and mappings.  Where possible,
    assumptions are made as to what type of device each part represents.  This is done by using the first letter of the
    part reference and assumming it equals the proper spice equivalent.  For example, resistors are assummed to
    have a prefix R, capacitors C, inductors L, and subcircuits X.  Users can choose the right device type in the
    interface provided.  See the
    <a href=#120>SIM</a> command for more information on simulation, and see the Berkeley spice page
    on devices <a href="https://bwrcs.eecs.berkeley.edu/Classes/IcBook/SPICE/UserGuide/elements_fr.html">here</a>
    for a detailed list of spice devices and their syntax. The list of valid spice prefixes are below.
    <pre>R L C K X S W V I G E F H B T O U D Q J M Z</pre>


<a name=33>
<h1>ALIGN</h1>
<p>
<dt>
<b>Function</b>
<dd>
Aligns selected objects in the Layout editor.
<dt>
<b>Syntax</b>
<dd>
<tt>ALIGN &#149; ..</tt><br>
<p>
At the moment the ALIGN command does not support command line parameters.
<dt>
<h2>Operation</h2>
The ALIGN command can be used to align selected objects in relation to each other
or to move their origin location to the nearest grid point. You can use the commnd
toolbar, the command line or the <b>Edit</b> menu to start the ALIGN command.
The following modes are supported:
<ul>
<li>Align Edges Top | Bottom | Left | Right
<li>Align centers Vertical | Horizontal,
<li>Distribute Vertically | Horizontally
<li>Align Origin to Grid
</ul>
<p>
The ALIGN command uses axis aligned bounding boxes of objects to be
aligned for all modes except for Align Origin to Grid mode (which as the name
implies uses the origin of the object to be aligned).
<p>
In <b>Distribute Vertically | Horizontally</b> modes at least three selected objects
are required - these modes will provide equal spacing between the selected objects.
<p>
<h2>Applicability</h2>
The ALIGN command can be applied to following object types:
<ul>
<li>Element
<li>Text
<li>Pad
<li>Via
<li>Hole
</ul>
<p>
The ALIGN command will ignore other object types even if they were selected
prior to starting the command. The ALIGN command is not applicable
if there are no selected applicable objects in the editor.


<a name=34>
<h1>ARC</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Draw an arc of variable diameter, width, and length.
<dt>
<b>Syntax</b>
<dd>
<tt>ARC ['signal_name'] [CW | CCW] [ROUND | FLAT] [width] &#149; &#149; &#149;</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.<br>
<mb>Right</mb> changes the orientation.
</dl>
<b>See also</b> <a href=#41>CHANGE</a>,
<a href=#73>LINE</a>,
<a href=#43>CIRCLE</a>
<p>
The ARC command, followed by three mouse clicks on a drawing, draws
an arc of defined width. The first point defines a point on a circle,
the second its diameter. Entering the second coordinate reduces the
circle to a semi-circle, while the right button alters the direction
from first to second point. Entry of a third coordinate truncates
the semi-circle to an arc extending to a point defined by the intersection
of the circumference and a line between the third point and the arc
center.
<p>
The parameters CW and CCW enable you to define the direction of the
arc (clockwise or counterclockwise). ROUND and FLAT define whether the arc
endings are round or flat, respectively.
<h2>Signal name</h2>
The <tt>signal_name</tt> parameter is intended mainly to be used in
script files that read in generated data. If a <tt>signal_name</tt>
is given, the arc will be added to that signal and no
automatic checks will be performed.<br>
<b>This feature should be used with great care because it could result
in short circuits if an arc is placed in a way that it would connect
different signals. Please run a
<a href=#53>Design Rule Check</a> after using the ARC command
with the <tt>signal_name</tt> parameter!</b>
<h2>Line Width</h2>
The parameter "width" defines the thickness of the drawn line.
It can be changed or predefined with the command:
<pre>
CHANGE WIDTH width;
</pre>
The adjusted width is identical to the line width for wires.
<p>
Arcs with angles of 0 or 360 degrees or a radius of 0 are
not accepted.
<p>
Example for text input:
<pre>
GRID inch 1;
ARC CW (0 1) (0 -1) (1 0);
</pre>
generates a 90-degree arc with the center at the origin.


<a name=35>
<h1>ASSIGN</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Modify key assignments.
<dt>
<b>Syntax</b>
<dd>
<tt>ASSIGN</tt><br>
<tt>ASSIGN function_key command..;</tt><br>
<tt>ASSIGN function_key;</tt>
<p>
<tt>function_key = modifier+key</tt><br>
<tt>modifier     = </tt>any combination of <tt>S</tt> (Shift), <tt>C</tt> (Control), <tt>A</tt> (Alt) and <tt>M</tt> (Cmd, Mac OS X only)<br>
<tt>key          = F1..F12, A-Z, 0-9, BS</tt> (Backspace)
</dl>
<b>See also</b> <a href=#115>SCRIPT</a>,
<a href=#21>Keyboard and Mouse</a>
<p>
The ASSIGN command can be used to define the meaning of the function keys
<tt>F1</tt> thru <tt>F12</tt>, the letter keys <tt>A</tt> thru <tt>Z</tt>,
the (upper) digit keys <tt>0</tt> thru <tt>9</tt> and the <tt>backspace</tt>
key (each also in combination with modifier keys).
<p>
The ASSIGN command without parameters displays the present key
assignments in a dialog, which also allows you to modify these settings.
<p>
Keys can be assigned a single command or multiple commands. The command
sequence to be assigned should be enclosed in apostrophes.
<p>
If <tt>key</tt> is one of <tt>A-Z</tt> or <tt>0-9</tt>,
the <tt>modifier</tt> must contain at least <tt>A</tt>, <tt>C</tt> or <tt>M</tt>.
<table><tr><td valign="top"><img src="platforms-mac.png"></td><td valign="middle">
The <b><tt>M</tt></b> modifier is only available on <b>Mac OS X</b>.
</td></tr></table>
<p>
Please note that any special operating system function assigned to a function
key will be overwritten by the ASSIGN command.
Depending on the operating system, ASSIGN may not be able to overwrite
certain function keys (like e.g. Shift+F10 on Windows).<br>
If you assign to a letter key together with the modifier <tt>A</tt>,
(e.g. <tt>A+F</tt>), a corresponding hotkey from the pulldown menu is
no longer available.
<p>
To remove an assignment from a key you can enter <tt>ASSIGN</tt>
with only the function_key code, but no command.
<h2>Examples</h2>
<pre>
ASSIGN F7 'change layer top; route';
ASS A+F7 'cha lay to; rou';
ASSIGN C+F10 menu add mov rou ''';''' edit;
ASSIGN CA+R 'route';
</pre>
The first two examples have the same effect, since EAGLE allows abbreviations
not only with commands but also with parameters (as long as they are
unmistakable).
<p>
Please note that here, for instance, the change layer top command
is terminated by a semicolon, but not the route command. The
reason is that in the first case the command already contains all
the necessary parameters, while in the second case coordinates still
have to be added (usually with the mouse). Therefore the ROUTE command
must not be deactivated by a semicolon.
<h2>Define Command Menu</h2>
If you want to assign the MENU command to a key, the separator
character in the MENU command (semicolon) has to be enclosed in three
pairs of apostrophes (see the third example). This semicolon will
show up in the new menu.
<h2>Presetting of key assignments</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>F1     HELP</tt> </td><td width=20><td>Help function</td></tr>
<tr><td><tt>Alt+F2 WINDOW FIT</tt>     </td><td width=20><td>The whole drawing is displayed</td></tr>
<tr><td><tt>F2     WINDOW;</tt>        </td><td width=20><td>Screen redraw</td></tr>
<tr><td><tt>F3     WINDOW 2</tt>       </td><td width=20><td>Zoom in by a factor of 2</td></tr>
<tr><td><tt>F4     WINDOW 0.5</tt>     </td><td width=20><td>Zoom out by a factor of 2</td></tr>
<tr><td><tt>F5     WINDOW (@);</tt>    </td><td width=20><td>Cursor pos. is new center</td></tr>
<tr><td><tt>F6     GRID;</tt>          </td><td width=20><td>Grid on/off</td></tr>
</table>
<p>
Further, many useful key assignments are contained in the initialisation script default-assign.scr
and can be adjusted to your individual needs.


<a name=36>
<h1>ATTRIBUTE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Definition of attributes for parts.
<dt>
<b>Syntax</b>
<dd>
<tt>ATTRIBUTE name [ 'value' ] [ options ]</tt><br>
<tt>ATTRIBUTE part_name attribute_name</tt><br>
<tt>ATTRIBUTE part_name attribute_name 'attribute_value' [ [ orientation ] &#149; ]</tt><br>
<tt>ATTRIBUTE part_name attribute_name DELETE</tt><br>
<tt>ATTRIBUTE element_name attribute_name</tt><br>
<tt>ATTRIBUTE element_name attribute_name 'attribute_value' [ [ orientation ] &#149; ]</tt><br>
<tt>ATTRIBUTE element_name attribute_name DELETE</tt><br>
<tt>ATTRIBUTE * [ name [ 'value' ] ]</tt><br>
<tt>ATTRIBUTE * name DELETE</tt><br>
<tt>ATTRIBUTE &#149;..</tt>
</dl>
<b>See also</b> <a href=#130>TECHNOLOGY</a>,
<a href=#84>NAME</a>,
<a href=#136>VALUE</a>,
<a href=#122>REPOSITION</a>,
<a href=#131>TEXT</a>
<p>
See the description of <tt>orientation</tt> at <a href=#31>ADD</a>.
<p>
An <i>attribute</i> is an arbitrary combination of a <i>name</i> and a <i>value</i>,
that can be used to specify any kind of information for a given part.
<p>
Attributes can be defined in the library (for individual devices), in the schematic
(for an actual part) or in the board (for an actual element). Attributes defined
on the device level will be used for every part of that device type in the schematic.
In a schematic, additional attributes can be defined for each part, and existing
attributes from the devices can be overwritten with new values (if the attributes
have been defined as <i>variable</i>). An element in the board has all the attributes
of its corresponding part, and can have further attributes of its own.
<h2>Attributes in the Library</h2>
In a library the ATTRIBUTE command can be used to define the attributes of a given
technology variant, using the syntax
<pre>
ATTRIBUTE name [ 'value' ] [ options ]
</pre>
The <tt>name</tt> may consist of any letters, digits, '_', '#' and '-' and may have
any length; the first character must not be '-', though. Names are treated
case insensitive, so PartNo is the same as PARTNO. The <tt>value</tt> may
contain any characters and must be enclosed in single quotes.
<p>
The valid <tt>options</tt> are:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>delete</tt>  </td><td width=20><td>Delete the attribute with the given name from all technology variants (in this case there must be no 'value').</td></tr>
<tr><td><tt>variable</tt></td><td width=20><td>Mark this attribute as <i>variable</i>, so that it can be overwritten in the schematic (this is the default).</td></tr>
<tr><td><tt>constant</tt></td><td width=20><td>Attributes marked as <i>constant</i> cannot be overwritten in the schematic (unless the user insists).</td></tr>
</table>
Options may be abbreviated and are case insensitive.
<p>
An already existing attribute can be switched between <i>variable</i> and
<i>constant</i> without the need to repeat its value, as in
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ATTRIBUTE ABC '123'</tt>   </td><td width=20><td>(variable by default)</td></tr>
<tr><td><tt>ATTRIBUTE ABC constant</tt></td><td width=20><td>(ABC retains its value '123')</td></tr>
</table>
If the value of an attribute is changed, its <i>constant/variable</i> setting
remains unchanged (unless explicitly given).
If an attribute is defined as constant, a library UPDATE will reset its value.
<h2>Attributes in the Schematic</h2>
In a schematic, the ATTRIBUTE command can be used to assign attributes to
a part, in which case the value of such an attribute overwrites the value
of the attribute with the same name in the library (if the device has such
an attribute and allows overwriting). A part may also be given attributes
that are not defined in the library at all.
<p>
Selecting the ATTRIBUTE command and clicking on a part shows a dialog in which all
attributes of that part are listed and can be edited.
<p>
For a fully textual definition of a new attribute the following syntax can be used:
<pre>
ATTRIBUTE part_name attribute_name 'attribute_value' orientation &#149;
</pre>
<p>
For already existing attributes it's only possible to change the value;
the following syntax has to be used:
<pre>
ATTRIBUTE part_name attribute_name 'attribute_value';
</pre>
Note that in case of a multi-gate part, actually one of the gates (i.e.
"instances") is selected. When selecting it via a mouse click it is already
clear which gate is meant, while when selecting it via part_name, the full
name consisting of the part and gate name should be given.
While a specific part can only have one attribute with a given name, the
attribute can be attached to any or all of its gates.
If only the part name is given, the first visible gate will be implicitly
selected.
<p>
If no coordinates are given (and the command is terminated with a <tt>';'</tt>),
the behavior depends on whether the given attribute already exists for that
part (either in the device or in the schematic). If the attribute already exists,
only its value will be changed. If it doesn't exist yet, a new attribute with
the given name and value will be placed at the origin of the selected gate of the part.
<p>
To delete an attribute from a part, the command
<pre>
ATTRIBUTE part_name attribute_name DELETE
</pre>
can be used.
<p>
When defining attributes via the command line or a script, use the
<a href=#41>CHANGE</a> DISPLAY command to define which parts of the
attribute (name, value, both or none of these) shall be visible.
<h2>Attributes in the Board</h2>
In a board, attributes can be assigned to elements with the ATTRIBUTE
command, much the same as in schematics. By default elements have all the
attributes that are defined for their part in the schematic (and their
device in the library). Attributes with the same name for a given
element/part pair will always have the same value (through <a href=#406>Forward&amp;Back Annotation</a>).
Elements can have additional attributes that are not present in the
schematic or library.
<p>
If in a board the graphical representation of an attribute of an
element is deleted and the attribute is defined solely in the board
or there is no consistent schematic, the attribute is deleted too.
In any other case the attribute is not deleted, but its display mode
is changed to OFF (not visible).
<h2>Global attributes</h2>
Global attributes can be defined in boards and schematics by using <tt>'*'</tt> as
the part name (which implies that this attribute applies to <i>all</i> parts).
Alternatively global attributes can be defined through the menu option
"Edit/Global attributes...". The global attributes of board and schematic
are handled separately and are not connected via <a href=#406>Forward&amp;Back-Annotation</a>.
<p>
Such an attribute could for instance be the author of a drawing, and can be used
in the title block of a drawing's frame. It will be shown on every schematic sheet
that has a drawing frame that contains a <a href=#131>text variable</a>
with the same name.
<h2>The attribute <tt>VALUE</tt> and other special attributes</h2>
Names of <a href=#131>text variables</a> like <tt>NAME</tt> or <tt>GATE</tt>
can not be used as attribute names. The only exception is the attribute <b><tt>VALUE</tt></b>,
which can be used for assigning a value to each device in a library.
If such a device is added to schematic, this value is used as part value regardless if
the device set has 'Value On' or 'Value Off'.
The attribute <tt>VALUE</tt> is then no longer available in schematic or board to avoid confusion.
Changing the part value can be done in the usual way with the
<a href=#136>VALUE</a> command.
The attribute <tt>VALUE</tt> is also processed in library update, CHANGE PACKAGE/TECHNOLOGY
and REPLACE. The part value is replaced by the newer or different value of this attribute
if necessary.
<p>
The attribute name <b>_EXTERNAL_</b> is reserved for marking of external devices
(see <a href=#88>PACKAGE</a>).
<h2>Selecting the layer</h2>
Unlike other commands (like LINE, for instance), the ATTRIBUTE command keeps track
of its last used layer by itself. This has the advantage of making sure that
attributes are always drawn into the right layer, no matter what layers other
commands draw into. The downside of this is that the usual way of setting the layer
in a script, as in
<pre>
LAYER <i>layer</i>;
LINE (1 2) (3 4);
</pre>
doesn't work here. The layer needs to be selected while the ATTRIBUTE command is
already active, which can be done like this
<pre>
ATTRIBUTE <i>parameters</i>
LAYER <i>layer</i>
<i>more parameters</i>;
</pre>
Note that the ATTRIBUTE line is <b>not</b> terminated with a <tt>';'</tt>, and
that the LAYER command starts on a new line.<br>
The commands
<pre>
ATTRIBUTE
LAYER <i>layer</i>;
</pre>
set the layer to use with subsequent ATTRIBUTE commands.
<h2>Examples</h2>
First the package and technology has to be selected (in case there is more
than one) and then attributes for that technology can be defined:
<pre>
PACKAGE N;
TECHNOLOGY LS;
ATTRIBUTE PartNo '12345-ABC';
ATTRIBUTE Temp '100K' constant;
ATTRIBUTE Remark 'mount manually';
</pre>


<a name=37>
<h1>AUTO</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Starts the Autorouter
<dt>
<b>Syntax</b>
<dd>
<tt>AUTO;</tt><br>
<tt>AUTO signal_name..;</tt><br>
<tt>AUTO ! signal_name..;</tt><br>
<tt>AUTO &#149;..;</tt><br>
<tt>AUTO FOLLOWME</tt><br>
<tt>AUTO BGA</tt><br>
<tt>AUTO LOAD|SAVE filename;</tt>
</dl>
<b>See also</b> <a href=#118>SIGNAL</a>,
<a href=#113>ROUTE</a>,
<a href=#58>FANOUT</a>,
<a href=#73>LINE</a>,
<a href=#104>RATSNEST</a>,
<a href=#116>SET</a>
<p>
The AUTO command activates the integrated
<a href=#166>Autorouter</a>. If signal names
are specified or signals are selected with the mouse, only these signals
are routed. Without parameters the command will try to route all signals.
If a "!" character is specified all signals are routed except the
signals following the "!" character. The "!" character must be the
first parameter and must show up only once.
<p>
The <tt>LOAD</tt> and <tt>SAVE</tt> options can be used to load the Autorouter parameters
from or save them to the given file. If <i>filename</i> doesn't have the extension
<tt>".ctl"</tt> it will be appended automatically.
<p>
Without any parameters (or if no terminating <tt>';'</tt> is given), the AUTO command
opens a dialog in which the parameters that control the routing algorithm can
be configured. The special option <tt>FOLLOWME</tt> opens this dialog in a mode
where only the parameters controlling the <a href=#113>Follow-me router</a>
can be modified.
<h2>Example</h2>
<pre>
AUTO ! GND VCC;
</pre>
In every case the semicolon is necessary as a terminator. A menu for
adjusting the Autorouter control parameters opens if you select AUTO
from the command menu or type in AUTO from the keyboard (followed
by Return key).
<h2>Wildcards</h2>
If a <tt>signal_name</tt> parameter is given, the characters <tt>'*'</tt>, <tt>'?'</tt>
and <tt>'[]'</tt> are <i>wildcards</i> and have the following meaning:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>*</tt>    </td><td width=20><td>matches any number of any characters</td></tr>
<tr><td><tt>?</tt>    </td><td width=20><td>matches exactly one character</td></tr>
<tr><td><tt>[...]</tt></td><td width=20><td>matches any of the characters between the brackets</td></tr>
</table>
<p>
If any of these characters shall be matched exactly as such, it has to be enclosed
in brackets. For example, <tt>abc[*]ghi</tt> would match <tt>abc*ghi</tt> and not
<tt>abcdefghi</tt>.
<p>
A range of characters can be given as <tt>[a-z]</tt>, which results in any character
in the range <tt>'a'</tt>...<tt>'z'</tt>.
<h2>Polygons</h2>
When the Autorouter is started all <a href=#98>Polygons</a> are
calculated.
<h2>Protocol File</h2>
A protocol file (name.pro) is generated automatically.
<h2>Board Size</h2>
The Autorouter puts a rectangle around all objects in the board
and takes the size of this rectangle as the routing area. Wires
in the Dimension layer are border lines for the
Autorouter. This means you can delimit the route area with closed
lines drawn into this layer with the LINE command.
<p>
In practice you draw the board outlines into the Dimension layer with
the LINE command and place the components within this area.
<h2>Signals</h2>
Signals defined with EAGLE's SIGNAL command, polygons, and wires drawn
onto the Top, Bottom, and ROUTE2...15 layers are recognized by the
Autorouter.
<h2>Restricted Areas</h2>
Objects in the layers tRestrict, bRestrict,
and vRestrict are treated as restricted areas for the Top and Bottom
side and for vias respectively.
<p>
If you want the Autorouter not to use a layer, select "N/A" in the
preferred direction field.
<h2>Canceling</h2>
If you cancel the Autorouter by clicking on the STOP button, any airwires
that have not yet been routed, are not automatically recalculated.
Use the <a href=#104>RATSNEST</a> command to do this.
<h2>BGA</h2>
The BGA router is a special kind of autorouter which was designed to route BGAs
with a minimal number of layers, and satisfy other specific requirements
in BGA routing. The BGA router is useful if you have a limited number of
layers or you want to minimize the number of layers in your board.
BGA routing might take quite a long time and might consume a big amount of
memory depending on the BGA.
<h3>Parameters</h3>
BGA router has several input parameters. These parameters should be assigned to
each BGA as a value of the attribute with a name "BGA".
Please assign the "BGA" attribute only to BGA elements because the behavior of the
BGA router is not defined for elements which are not BGA.
Assigning an attribute to an element with name "BGA" and empty value means that
this element will be routed by the BGA router using all signals which are connected
to SMDs, and using all available layers, and placing micro vias, if microvias are
available in the board's technology.
If only a subset of signals connected to a BGA element should be routed, the
following value has to be assigned to the value of "BGA" attribute:
<pre>
(NETS "list of signal names")
</pre>
for example:
<pre>
(NETS LPC_A1 PWR D0)
</pre>
It is possible to skip some signals of this BGA. In this case you have to preceed
the keyword NETS with a <tt>-</tt> sign:
<pre>
(-NETS "list of signal names")
</pre>
for example:
<pre>
(-NETS LPC_A1 PWR D0)
</pre>
In this case all but LPC_A1 PWR D0 signals will be routed.<br>
It is also possible to control signals on each layer. To do this the following
description should be added to the attribute value:
<pre>
(LAYERS (LAYER_NUMBER1 "list1 of signal names") (LAYER_NUMBER2 "list2 of signal names") ...)
</pre>
In this case e.g. only signals from list1 are allowed to use the layer with number LAYER_NUMBER1.
For example:
<pre>
(LAYERS (2 GND) (3 3V3 2V5 1V2))
</pre>
The parameters above mean that only signal GND can use layer 2. In layer 3 only
wires that belong to the signals 3V3, 2V5 or 1V2 could be created.
An empty list like (2) means that in layer 2 no signals can be routed.
By setting an empty list for some layers it is possible to switch off routing for these layers.<br>
It is also possible to exclude some signals from a list.
To do this the layer number has to be preceeded by a minus <tt>-</tt> sign:
<pre>
(LAYERS (2 GND) (-3 3V3 2V5 1V2))
</pre>
Layer 2 can be used only for signal GND, layer 3 can be used for all signals
except 3V3 2V5 1V2.
The BGA router can use microvias, if they are defined in the board's layer setup.
Microvias will be placed on SMDs. It is possible to switch off the usage of microvias
by setting the following parameter:
<pre>
(MICROVIAS OFF)
</pre>
<h3>GUI</h3>
It is possible to setup all parameters by editing the value of the "BGA" attribute,
but it's easier to do this in a dialog. By issuing the 'AUTO BGA" command a pop-up
dialog with two lists appears. The list on the left shows elements which
might be a BGA. The list on the right contains BGAs you would like to set and save
the routing parameters and finally have them routed.
You can modify the content of these lists by moving elements from here to there.
The list on the right with elements supposed to be routed might have a marker in orange
or in green.
The green marker indicates that the settings for this element will be saved and
it will be routed. Orange indicates that the settings only will be saved.
Double-click onto the element to change the marker.
The "Edit" button allows you to set parameters for the selected element of the "BGA" list
in a new dialog. In this dialog a list of signals connected to SMDs of this BGA is shown.
Here you can define list of layers for each signal. Select one or more signals and
click the "Edit" button. In the followig dialog choose the layers that are allowed to be used
for the BGA routing.<br>
In the signals dialog you will find an option to switch on/off the usage of micro vias.
Just keep in mind: This GUI workflow creates an attribute named "BGA" for each BGA component
with appropriate attribute values that are used to instruct the BGA router.


<a name=38>
<h1>BOARD</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Converts a schematic into a board.
<dt>
<b>Syntax</b>
<dd>
<tt>BOARD [ grid ]</tt>
</dl>
<b>See also</b> <a href=#54>EDIT</a>
<p>
The command BOARD is used to convert a schematic drawing into a board.
<p>
If the board already exists, it will be loaded into a board window.
<p>
If the board does not exist, you will be asked whether to create that new
board.
If a <tt>grid</tt> is given, the parts on the board will be placed in
the given raster, as in
<pre>
BOARD 5mm
</pre>
which would place the parts in a 5 millimeter raster (default is 50mil).
The number must be given with a unit, and the maximum allowed value
is 10mm.
<p>
The BOARD command will never overwrite an existing board file. To create
a new board file if there is already a file with that name, you have to
<a href=#107>remove</a> that file first.
<h2>Creating a board from a schematic</h2>
The first time you edit a board the program checks if there is a
schematic with the same name in the same directory and gives you the
choice to create the board from that schematic.<br>
If you have opened a schematic window and want to create a board, just
type
<pre>
edit .brd
</pre>
in the editor window's command line.
<p>
All relevant data from the schematic file (name.sch) will be converted to a
board file (name.brd). The new board is loaded automatically as an empty
card with a size of 160x100mm
(<a href=#409>Light edition</a>: 100x80mm).
All packages and connections are shown on the left side
of the board. Supply pins are already connected
(see <a href=#93>PIN</a> command).
<p>
If you need board outlines different to the ones that are generated
by default, simply delete the respective lines and use the
<a href=#73>LINE</a> command to draw your own outlines into
the <i>Dimension</i> layer. The recommended width for these lines is 0.
<p>
A board file cannot be generated:
<ul>
<li>if there are gates in the schematic from a device
for which no package has been defined (error message: "device
name has no package). Exception: if there are only pins with
Direction "Sup" (supply symbols)
<li>if there are gates in the schematic from a device
for which not all pins have been assigned to related pads of a footprint
(error message: "device name has unconnected pins"). Exception:
device without pins (e.g. frames)
</ul>


<a name=39>
<h1>BUS</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Draws buses in a schematic.
<dt>
<b>Syntax</b>
<dd>
<tt>BUS [? | {PREDEFINED_BUS_NAME} | bus_spec] &#149; [curve | @radius] &#149;..</tt><br>
<tt>BUS {PREDEFINED_BUS_NAME=bus_spec}</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Right</mb> changes the wire bend style (see <a href=#116>SET Wire_Bend</a>).<br>
<mb>Shift+Right</mb> reverses the direction of switching bend styles.<br>
<mb>Ctrl+Right</mb> toggles between corresponding bend styles.
</dl>
<b>See also</b> <a href=#65>INFO</a>,
<a href=#40>BREAKOUTBUS</a>,
<a href=#85>NET</a>,
<a href=#84>NAME</a>,
<a href=#116>SET</a>
<p>
A BUS is a collection of nets. A BUS has a specification and is drawn as one or more bus line segments.
The bus specification may include a (strictly unique) alias, which is a short name used to identify the bus. The BUS
command is used to draw buses onto the Bus layer of a schematic diagram.
<p>
EAGLE has the ability to save reusable bus specifications as "Predefined Busses" (PDBs).
The PDBs are saved in the eaglerc file and can be used across projects, even shared with others
(example: SPI:MISO,MOSI,CLK,CS). By including the PDB in braces after the BUS command, the bus will adopt
this specification when drawn. The PDB name must be valid and exist in the eaglerc file to use in this way.
<pre>
BUS {PREDEFINED_BUS_NAME}
</pre>
<p>The BUS toolbar command button supports a right-click menu, with quick access to existing PDBs.
Choosing one from this menu is equivalent to using the command format above.
<p>
New PDBs can be also created from the command line using the format below. Note that the PDB name must be unique, and
the bus_spec must be a valid bus specification as described in this section. PDBs are saved to eaglerc and
are available immiediately for use.
<pre>
BUS {PREDEFINED_BUS_NAME=bus_spec}
</pre>
<p>If you type BUS ? in the command line (or choose "New" from the right-click menu on the BUS button in the
command toolbar), the Predefined Bus dialog will open, where you can create and manage PDBs.
<pre>
BUS ?
</pre>
<p>Bus_spec has the following form:
<pre>
ALIAS:partbus,partbus,..
</pre>
where ALIAS can be any name.
Partbus is either a simple net name or a name range of the following form:
<pre>
NetName[LowestIndex..HighestIndex]
</pre>
where the following condition must be met:
<p>
0 &lt;= LowestIndex &lt;= HighestIndex &lt;= 511
<p>
If a name is used with a range, that NetName must not end with digits, because
it would become unclear which digits belong to the Name and which belong to
the range.
<p>
If a bus wire is placed at a point where there is already another bus
wire, the current bus wire will be ended at that point.
This function can be disabled with "<tt>SET AUTO_END_NET OFF;</tt>",
or by unchecking "Options/Set/Misc/Auto end net and bus".
<p>
If the <i>curve</i> or <i>@radius</i> parameter is given, an arc can be drawn as part of the bus
(see the detailed description in the <a href=#73>LINE</a> command).
<h2>Bus Specification Examples</h2>
<pre>
A[0..15]
RESET
DB[0..7],A[3..4]
ATBUS:A[0..31],B[0..31],RESET,CLOCK,IOSEL[0..1]
</pre>
If no bus specification is given, a specification of the form B$1 is automatically
allocated. This can be changed with the NAME or INFO command at any time.
<p>
The line width used by the bus can be defined for example with
<pre>
SET Bus_Wire_Width 40;
</pre>
to be 40 mil. (Default: 30 mil).
<h2>Inverted signals</h2>
The name of an inverted signal ("active low") can be displayed overlined if it
is preceded with an exclamation mark (<tt>'!'</tt>), as in
<pre>
  ATBUS:A[0..31],B[0..31],!RESET,CLOCK,IOSEL[0..1]
</pre>
which would result in
<pre>
                          _____
  ATBUS:A[0..31],B[0..31],RESET,CLOCK,IOSEL[0..1]
</pre>
You can find further details about this in the description of the <a href=#131>TEXT</a> command.
<h2>Bus Breakouts</h2>
Buses can be broken out automatically with new labeled nets using the <a href=#40>BREAKOUTBUS</a>
command, available from the command-line and by the bus object right-click context menu.


<a name=40>
<h1>BREAKOUTBUS</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Breakout member nets from a bus as new nets with labels.
<dt>
<b>Syntax</b>
<dd>
<tt>BREAKOUTBUS &#149; &#149;..</tt>
</dl>
<p>The BREAKOUTBUS command is accessed from the context menu after right-clicking on a bus. The breakout types are
    given as choices in the menu: "All Nets", "Selected Nets", and "Single Net". The "Selected Nets" option will bring up a
    dialog where the user can choose which nets to breakout. "Single Net" is a submenu where all members of the bus are
    shown and a single net can be chosen. "All Nets" breaks out all members of the bus.
<p>Once a breakout choice is made new nets with labels are created, spaced 1 grid apart, along the bus, and the user then clicks
    to finalize the placement of the new nets.
<p>Holding down SHIFT while placing the nets will freeze the shape of the new nets, and allow movement only along the bus.


<a name=41>
<h1>CHANGE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Changes parameters.
<dt>
<b>Syntax</b>
<dd>
<tt>CHANGE option &#149; &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Right</mb> changes parameter of the group.
</dl>
The CHANGE command is used to change or preset properties of objects.
The objects are clicked on with the mouse after the desired parameters
have been selected from the CHANGE command menu or have been typed
in from the keyboard.
<p>
Parameters adjusted with the CHANGE command remain as preset
properties for objects added later.
<p>
All values in the CHANGE command are used according to the actual grid
unit.
<h2>Change Groups</h2>
When using the CHANGE command with a group, the group is first identified
with the <a href=#62>GROUP</a> command before
entering the CHANGE command with appropriate parameters. The right
button of the mouse is then used to execute the changes.
<h2>What can be changed?</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Layer                </td><td width=20><td><tt>CHANGE LAYER name | number</tt></td></tr>
<tr><td>Text                 </td><td width=20><td><tt>CHANGE TEXT [ text ]</tt></td></tr>
<tr><td>Text height          </td><td width=20><td><tt>CHANGE SIZE value</tt></td></tr>
<tr><td>Text thickness       </td><td width=20><td><tt>CHANGE RATIO ratio</tt></td></tr>
<tr><td>Text line distance   </td><td width=20><td><tt>CHANGE LINEDISTANCE value</tt></td></tr>
<tr><td>Text font            </td><td width=20><td><tt>CHANGE FONT VECTOR | PROPORTIONAL | FIXED</tt></td></tr>
<tr><td>Text alignment       </td><td width=20><td><tt>CHANGE ALIGN BOTTOM | LEFT | CENTER | TOP | RIGHT</tt></td></tr>
<tr><td>Wire width           </td><td width=20><td><tt>CHANGE WIDTH value</tt></td></tr>
<tr><td>Wire style           </td><td width=20><td><tt>CHANGE STYLE value</tt></td></tr>
<tr><td>Arc cap              </td><td width=20><td><tt>CHANGE CAP ROUND | FLAT</tt></td></tr>
<tr><td>Pad shape            </td><td width=20><td><tt>CHANGE SHAPE SQUARE | ROUND | OCTAGON | LONG | OFFSET</tt></td></tr>
<tr><td>Pad/via/smd flags    </td><td width=20><td><tt>CHANGE STOP | CREAM | THERMALS | FIRST  OFF | ON</tt></td></tr>
<tr><td>Pad/via diameter     </td><td width=20><td><tt>CHANGE DIAMETER diameter</tt></td></tr>
<tr><td>Pad/via/hole drill   </td><td width=20><td><tt>CHANGE DRILL value</tt></td></tr>
<tr><td>Via layers           </td><td width=20><td><tt>CHANGE VIA from-to</tt></td></tr>
<tr><td>Smd dimensions       </td><td width=20><td><tt>CHANGE SMD width height</tt></td></tr>
<tr><td>Smd roundness        </td><td width=20><td><tt>CHANGE ROUNDNESS value</tt></td></tr>
<tr><td>Pin parameters       </td><td width=20><td><tt>CHANGE DIRECTION NC | IN | OUT | IO | OC | HIZ | SUP | PAS | PWR</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE FUNCTION NONE | DOT | CLK | DOTCLK</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE LENGTH POINT | SHORT | MIDDLE | LONG</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE VISIBLE BOTH | PAD | PIN | OFF</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE SWAPLEVEL number</tt></td></tr>
<tr><td>Polygon parameters   </td><td width=20><td><tt>CHANGE THERMALS OFF | ON</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE ORPHANS OFF | ON</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE ISOLATE distance</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE POUR SOLID | HATCH | CUTOUT</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE RANK value</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE SPACING distance</tt></td></tr>
<tr><td>Gate parameters      </td><td width=20><td><tt>CHANGE SWAPLEVEL number</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE ADDLEVEL NEXT | MUST | ALWAYS | CAN | REQUEST</tt></td></tr>
<tr><td>Net class            </td><td width=20><td><tt>CHANGE CLASS number | name</tt></td></tr>
<tr><td>Package              </td><td width=20><td><tt>CHANGE PACKAGE part_name [device_name] | 'device_name' [part_name]</tt></td></tr>
<tr><td>3D Package           </td><td width=20><td><tt>CHANGE PACKAGE3D part_name [3d_package] | '3d_package' [part_name]</tt></td></tr>
<tr><td>Technology           </td><td width=20><td><tt>CHANGE TECHNOLOGY part_name [device_name] | 'device_name' [part_name]</tt></td></tr>
<tr><td>Attribute display    </td><td width=20><td><tt>CHANGE DISPLAY OFF | VALUE | NAME | BOTH</tt></td></tr>
<tr><td>Frame parameters     </td><td width=20><td><tt>CHANGE COLUMS value</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE ROWS value</tt></td></tr>
<tr><td>                     </td><td width=20><td><tt>CHANGE BORDER NONE | BOTTOM | RIGHT | TOP | LEFT | ALL</tt></td></tr>
<tr><td>Label                </td><td width=20><td><tt>CHANGE XREF OFF | ON</tt></td></tr>
<tr><td>Dimension type       </td><td width=20><td><tt>CHANGE DTYPE PARALLEL | HORIZONTAL | VERTICAL | RADIUS | DIAMETER | ANGLE | LEADER</tt></td></tr>
<tr><td>Dimension unit       </td><td width=20><td><tt>CHANGE DUNIT [MIC | MM | MIL | INCH] [OFF | ON] [precision]</tt></td></tr>
<tr><td>Dimension line       </td><td width=20><td><tt>CHANGE DLINE width [ extension_width [ extension_length [ extension_offset ]]]
(extension values can be set to AUTO; unchanged preceding values can be skipped with '-'; see examples)</tt></td></tr>
<tr><td>Populate             </td><td width=20><td><tt>CHANGE POPULATE OFF | ON (only available in a board context without active f/b annotation)</tt></td></tr>
</table>
<h2>Examples</h2>
<pre>
<tt>CHANGE DLINE 0.1mm;</tt>
</pre>
changes dimension line width to 0.1mm. Extension parameters are left unchanged.
<pre>
<tt>CHANGE DLINE 0.2mm - 0.5mm AUTO;</tt>
</pre>
changes dimension line width to 0.2mm, extension line length to 0.5mm and extension offset to AUTO. The extension line width is left unchanged.


<a name=42>
<h1>PAINTROLLER</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Transfers selected properties of an object to other objects of the same type.
<dt>
<b>Syntax</b>
<dd>
<tt>PAINTROLLER &#149; </tt><br>
<tt>PAINTROLLER &#149; &#149;</tt><br>
<tt>PAINTROLLER &#149; [propertyname] &#149;</tt><br>
</dl>
The PAINTROLLER command can be started in the command line or with the PAINTROLLER icon in the commands toolbar.
<p>
Select the properties you want to transfer to other objects of the same type in the Copy Properties dialog of the selected object, then close the dialog with OK, and click the target objects.


<a name=43>
<h1>CIRCLE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds circles to a drawing.
<dt>
<b>Syntax</b>
<dd>
<tt>CIRCLE &#149; &#149;..       [center, circumference]</tt><br>
<tt>CIRCLE width &#149; &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.
</dl>
<b>See also</b> <a href=#41>CHANGE</a>,
<a href=#73>LINE</a>
<p>
The CIRCLE command is used to create circles. Circles in the layers
tRestrict, bRestrict, and vRestrict define restricted
areas. They should be defined with a width of 0.
<p>
The width parameter defines the width of the circle's circumference
and is the same parameter as used in the LINE command. The width can
be changed with the command:
<pre>
CHANGE WIDTH width;
</pre>
where <i>width</i> is the desired value in the current unit.
<p>
A circle defined with a width of 0 will be filled.
<p>
The radius of the resulting circle is limited to 1000mm.
<h2>Example</h2>
<pre>
GRID inch 1;
CIRCLE (0 0) (1 0);
</pre>
generates a circle with a radius of 1 inch and the center at the origin.


<a name=44>
<h1>CLASS</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Define and use net classes.
<dt>
<b>Syntax</b>
<dd>
<tt>CLASS</tt><br>
<tt>CLASS number|name</tt><br>
<tt>CLASS number [ name [ width [ clearance [ drill ] ] ] ] [ number:clearance .. ]</tt>
</dl>
<b>See also</b> <a href=#168>Design Rules</a>,
<a href=#85>NET</a>,
<a href=#118>SIGNAL</a>,
<a href=#41>CHANGE</a>
<p>
The CLASS command is used to define or use net classes.
<p>
Without parameters, it offers a dialog in which the net classes can be defined.
<p>
If only a <tt>number</tt> or <tt>name</tt> is given, the net class with the given
number or name is selected and will be used for subsequent NET and SIGNAL commands.
<p>
If both a <tt>number</tt> and a <tt>name</tt> are given, the net class with the
given number will be assigned all the following values and will also be used for
subsequent NET and SIGNAL commands. If any of the parameters following <tt>name</tt>
are omitted, the net class will keep its respective value.
<p>
If <tt>number</tt> is negative, the net class with the absolute value of <tt>number</tt>
will be cleared. The default net class <tt>0</tt> can't be cleared.
<p>
Net class names are handled case insensitive, so SUPPLY would be the same as Supply
or SuPpLy.
<p>
Using several net classes in a drawing increases the time the
Autorouter needs to do its job. Therefore it makes sense to use only as few net
classes as necessary (only the number of net classes actually used by nets or
signals count here, not the number of defined net classes).
<p>
In order to avoid conflicts when CUT/PASTEing between drawings it makes sense
to define the same net classes under the same numbers in all drawings.
<p>
Modules are using the same set of net classes as the schematic itself.
<p>
If a net of a <a href=#82>MODULE</a> has an external connection
through a <a href=#100>PORT</a>, the net class of the net on this port
is overwriting the net class of the net in the module.
<p>
The Autorouter processes signals sorted by their total width requirements (Width
plus Clearance), starting with those that require the most space. The bus router
only routes signals with net class <tt>0</tt>.
<p>
The net class of an existing net/signal can be changed with the CHANGE command.
<h2>Width</h2>
The <i>width</i> parameter defines a minimum width that all objects in this
net class must have.
<h2>Clearance</h2>
The <i>clearance</i> parameter defines the minimum clearance between objects
of different signals in this net class and objects in other net classes.
<h2>Drill</h2>
The <i>drill</i> parameter defines a minimum drill size that all objects in this
net class must have (only applies to objects that actually have a drill parameter,
like pads and vias).
<h2>Clearance between net classes</h2>
If a clearance is given in the form <tt>number:clearance</tt>, it defines the
minimum clearance between signals in this net class and signals in the net class
with the given <tt>number</tt>. The command
<pre>
CLASS 3 1:0.6mm 2:0.8mm
</pre>
defines a minimum clearance of 0.6mm between signals in net classes 1 and 3,
and one of 0.8mm between signals in net classes 2 and 3. Note that the numbers in
<tt>number:clearance</tt> must be less than or equal to the number of the net class
itself (<tt>'3'</tt> in the above example), so
<pre>
CLASS 3 1:0.6mm 2:0.8mm 3:0.2mm
</pre>
would also be valid, whereas
<pre>
CLASS 3 1:0.6mm 2:0.8mm 3:0.2mm 4:0.5mm
</pre>
would not be allowed.
<p>
A clearance value of '0' between two net classes means, there is no specific
value. Then the higher value of the participating net classes will be used.


<a name=45>
<h1>CLOSE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Closes an editor window.
<dt>
<b>Syntax</b>
<dd>
<tt>CLOSE</tt>
</dl>
<b>See also</b> <a href=#86>OPEN</a>,
<a href=#54>EDIT</a>,
<a href=#141>WRITE</a>,
<a href=#115>SCRIPT</a>
<p>
The CLOSE command is used to close an editor window. If the drawing you
are editing has been modified you will be prompted whether you wish to
save it.
<p>
This command is mainly used in script files.


<a name=46>
<h1>CONNECT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Assigns pads to pins.
<dt>
<b>Syntax</b>
<dd>
<tt>CONNECT</tt><br>
<tt>CONNECT [ ALL | ANY ] gate_name.pin_name pad_name..</tt><br>
<tt>CONNECT [ ALL | ANY ] pin_name pad_name..</tt>
</dl>
<b>See also</b> <a href=#101>PREFIX</a>,
<a href=#86>OPEN</a>,
<a href=#45>CLOSE</a>,
<a href=#115>SCRIPT</a>
<p>
This command is used in the device editing mode in order to define
the relationship between the pins of a gate and the pads of the
corresponding footprint in the library. First of all, it is necessary
to define which package is to be used by means of the PACKAGE command.
<p>
If the CONNECT command is invoked without parameters, a dialog is
presented which allows you to interactively assign the connections.
<h2>Device with one Gate</h2>
If only one gate is included in a device, the parameter gate_name
can be dropped, e.g.:
<pre>
CONNECT gnd 1 rdy 2 phi1 3 !irq 4 nc1 5...
</pre>
(Note: "!" is used to indicate inverted data signals.)
<h2>Device with several Gates</h2>
If several gates are present in a device, parameters must be entered
with gate_name, pin_name and pad_name each time. For example:
<pre>
CONNECT A.I1     1  A.I2  2   A.O  3;
CONNECT B.I1     4  B.I2  5   B.O  6;
CONNECT C.I1    13  C.I2  12  C.O 11;
CONNECT D.I1    10  D.I2  9   D.O  8;
CONNECT PWR.gnd  7;
CONNECT PWR.VCC 14;
</pre>
In this case, the connections for four NAND gates of a good old 7400
are allocated. The device includes five gates - A, B, C, D,
and PWR. The gate inputs are named I1 and I2 while the output is named O.
<p>
The CONNECT command can be repeated as often as required. It may be
used with all pin/pad connections or with only certain pins. Each
new CONNECT command overwrites the previous conditions for the relevant
pins.
<p>
Note that if you have a large number of connections in a single device,
the CONNECT command works a lot faster if all connections are given in
one single call, like shown in the example below.
<h2>Several Pads connected to the same Pin</h2>
Some parts, like power amplifiers or BGA chips, may have several pads
that are connected internally. This may be done for better heat dissipation
or to allow for higher currents. The CONNECT command can handle these
cases by simply listing all related pad names, separated by blanks (and
therefore enclosed in single quotes), as in
<pre>
CONNECT ALL I1 '1 3 5';
CONNECT ANY O1 '2 4 6';
</pre>
In the first example the pin <tt>I1</tt> is connected to the three pads
<tt>1</tt>, <tt>3</tt> and <tt>5</tt>. If the pin <tt>I1</tt> is connected
to a net in the schematic, all three pads must be explicitly connected to
the corresponding signal in the board.<br>
In the second example, the keyword <tt>ANY</tt> indicates that any one
(or even all) of the pads <tt>2</tt>, <tt>4</tt> or <tt>6</tt> can be
connected to the signal. It is even allowed to use this internal connection as
a "bridge" by connecting one segment of the signal to, say, pad <tt>2</tt>, while
connecting the rest of the signal to pad <tt>6</tt>, without any explicit
external connection between these two pads. Of course, when designing a
library part and using <tt>ANY</tt> in a CONNECT command, you need to
be sure that the part will be able to handle cross currents running through
its pads. If in doubt, use <tt>ALL</tt> (which is the default and may be omitted).
<p>
If a pin name would collide with one of the keywords <tt>ALL</tt> or <tt>ANY</tt>,
the pin name needs to be enclosed with single quotes. As soon as one of these
keywords appears in a CONNECT command, it applies to all pin/pad connections that
follow it, until a different keyword is seen, as in
<pre>
CONNECT 'A' '1' 'B' '2' ANY 'C' '3 4 5 6' 'D' '7 8' ALL 'E' '9 10 11';
</pre>
<p>
The <a href=#104>RATSNEST</a> and <a href=#37>AUTO</a>
command will handle the <tt>ALL</tt> and <tt>ANY</tt> cases appropriately.
<p>
In the CONNECT dialog the "Connect" button creates a new connection between
the selected pin and the selected pads. There can be more than one pad selected,
in which case all of these pads will be connected to the selected pin. Use the
Ctrl and Shift keys in the usual way to mark more than one pad as selected.<br>
The "Append" button adds the selected pads to the current connection.<br>
The "Disconnect" button removes the selected connection and puts the pin and
pads back in their separate lists, keeping them selected so that it is easy to
make modifications. A Disconnect immediately followed by a Connect results in
the same configuration as before the Disconnect (and vice versa).<br>
If a connection contains more than one pad, an icon indicates whether any or
all of these pads need to be externally connected to a signal. Click on this
icon to toggle the mode. When such a connection item is expanded, all the pads
are listed separately, and clicking on Disconnect with one of the pads selected
will only disconnect that one pad.
<h2>Gate or Pin names that contain periods</h2>
If a gate or pin name contains a period, simply enter them without any special
consideration (no quoting or escape characters are necessary).
<h2>Example</h2>
<pre>
ed 6502.dev;
prefix 'IC';
package dil40;
connect gnd 1 rdy 2 phi1 3 !irq 4 nc1 5 !nmi 6 \
        sync 7 vcc 8  a0 9 a1 10 a2 11 a3 12 a4 \
        13 a5 14 a6 15 a7 16 a8 17 a9 18 a10 19 \
        a11 20 p$0 21 a12 22 a13 23 a14 24 a15 \
        25 d7 26 d6 27 d5 28 d4 29 d3 30 d2 31 \
        d1 32 d0 33 r/w 34 nc2 35 nc3 36 phi0 37 \
        so 38 phi2 39 !res 40;
</pre>
If a command is continued at the next line, it is advisable to
insert the character "\" at the end of the line to ensure
the following text cannot be confused with an EAGLE command.
<p>
Confusing parameters with commands can also be avoided
by enclosing the parameters in apostrophes.


<a name=47>
<h1>COPY</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Copy objects.
<dt>
<b>Syntax</b>
<dd>
<tt>COPY &#149; &#149;..</tt><br>
<tt>COPY deviceset@[library] [name]</tt><br>
<tt>COPY footprint@[library] [name]</tt><br>
<tt>COPY package3d@[library] [name]</tt><br>
<tt>COPY symbol@[library] [name]</tt><br>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+C</mb> copies currently selected objects. <br>
<mb>Ctrl+Left</mb> selects an object at its origin.<br>
<mb>Ctrl+Right</mb> selects the group.<br>
<mb>Center</mb> mirrors the selected object or the group.<br>
<mb>Right</mb> rotates the selected object or the group.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#62>GROUP</a>,
<a href=#48>CUT</a>,
<a href=#91>PASTE</a>,
<a href=#31>ADD</a>,
<a href=#66>INVOKE</a>,
<a href=#98>POLYGON</a>
<p>
The COPY command is used to copy objects
within the same drawing, or between libraries. EAGLE will generate a new name for the
copy but will retain the old value. When copying signals (wires),
buses, and nets the names are retained, but in all other cases a new
name is assigned.
<h2>Copy to the system's clipboard</h2>
The COPY command in EAGLE traditionally only copied objects by clicking
on them with the mouse and placing them within the same drawing.
It also copied library objects between libraries. However, before version 6
it did not copy the current group selection to the system's clipboard, like
other Windows programs do. In EAGLE, the <a href=#48>CUT</a> command
was used for this. Unfortunately, this has irritated Windows users time and again, so
beginning with version 6, the COPY command also copies the selected group
of objects to the system's clipboard, while still retaining the full
functionality of previous versions. If you don't like this, you can use the
<a href=#116>SET</a> command
<pre>
SET Cmd.Copy.ClassicEagleMode 1
</pre>
to get back the original behavior of the COPY command (as well as the <a href=#48>CUT</a>
command).
<h2>Copy Wires</h2>
If you copy wires or polygons, belonging to a signal, the
copy will belong to the same signal. Please note, for this reason,
if two wires overlap after the use of the COPY command, the DRC will
not register an error. <br>
If one of the endpoints of the copied wire lie on the source segment, the wire
is connected to this segment. If not, an extra segment is created for this wire
(see also 'Copy and connectivity').
<h2>Copy Parts</h2>
When copying a part in a schematic, there will always be a new instance
of the complete part added, even if only a single gate of a multi-gate
part is selected. In addition to the selected gate, any other gates of that
device which have Add-Level MUST or ALWAYS will automatically be invoked.
<p>
If you just want to use another gate of a multi-gate part, you should use
the <a href=#66>INVOKE</a> command instead.
<h2>Copy library objects</h2>
By writing <tt>COPY deviceset@[library]</tt>, <tt>COPY footprint@[library]</tt>,
<tt>COPY package3d@[library]</tt>, or <tt>COPY symbol@[library]</tt>
you can copy a device set, footprint, 3D package or symbol from a given library into the currently
loaded library. <tt> library</tt> can be either a plain library name, a file path
(see <a href=#31>ADD</a> command), the URN of a downloaded managed library,
or be omitted. If it's a library name,
it is searched for in the currently set library path(s) and among the downloaded managed
libraries. If it's a URN, it searched for among the downloaded managed libraries.
If <tt>library</tt> is omitted, the currently
loaded library is taken as source. In case of ambiguity you can add the
suffix <tt>.dev/.fpt/.p3d/.sym</tt> to the object name. (Note that the use of ".fpt"
to specify a footprint is new as of EAGLE 9.1. For compatibility with previous versions, ".pac" is also supported.)
If an additional <tt>name</tt> is given, the copied object will be given that name.
This can also be done through the library objects'
<a href=#14>context menu</a> or via <i>Drag&amp;Drop</i> from
the Control Panel's tree view.
<p>
<b>Note that any existing library objects (device sets, symbols, footprints, 3D packages)
used by the copied library object will be automatically updated.</b>
<h2>Copy a group</h2>
Copying a group by selecting it with the right mouse button is actually
done by doing an implicit <a href=#48>CUT</a> operation, immediately
followed by a <a href=#91>PASTE</a>.
<h2>Copy objects to an other sheet</h2>
To copy objects to an other sheet of the same schematic, you need to
<a href=#62>GROUP</a> the objects, do a <a href=#47>COPY</a>
(or <a href=#48>CUT</a>), switch to the target sheet and then do
<a href=#91>PASTE</a>.
<h2>Copy and connectivity</h2>
Copying of wires does not change their connectivity. For instance,
if you copy a net and position it at another net, it doesn't get connected to this net.
The same is for segments of the same net, busses etc. For connections
use <a href=#84>NAME</a> or <a href=#67>JUNCTION</a>.
<h2>Copy using Ctrl+C and free anchors</h2>
If objects are copied using Ctrl+C, it works differently for a single object
compared to more than one (a GROUP). If a single object is copied, the origin
is used as the reference point when pasting the object later. If you copy a
group of objects, it allows you to define an anchor, here called a "free anchor".<br>
This means EAGLE will remmeber this point within the selected group you used
for copying and will use that point for pasting. Typical example is large group
of objects, you want to place relative to a certain point within those objects
(as opposed to the default center position).<br>
In this case, you would use Ctrl+C after placing the mouse cursor at the
location of your choice, and this point will be used for pasting.
In other words, for groups of objects, Ctrl+C remembers where your cursor
was when you copied the objects, and uses it for pasting.


<a name=48>
<h1>CUT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Copies a group into the clipboard.
<dt>
<b>Syntax</b>
<dd>
<tt>CUT &#149;</tt><br>
<tt>CUT;</tt>
</dl>
<b>See also</b> <a href=#91>PASTE</a>,
<a href=#47>COPY</a>,
<a href=#62>GROUP</a>
<p>
Parts of a drawing (or even a whole board) can be copied onto other
drawings by means of the commands CUT and PASTE.
<p>
To do this you first define a group (GROUP command). Then use the
CUT command, followed by a reference point (mouse click or coordinates
(x y)) to put the selected objects into the buffer.
<tt>CUT;</tt> automatically puts the reference point at the center of
the selected objects (snapped to the grid).
Now you can change to an other drawing (EDIT) and
copy the contents of the buffer onto the new drawing by executing
the PASTE command.
<h2>Reference Point</h2>
If you click the mouse after selecting the CUT command, the position
of the mouse cursor defines a reference point for the group, i.e.
when using the PASTE command, the mouse cursor will be at the exact
position of the group.
<h2>Note</h2>
Unlike other (Windows-) programs EAGLE's CUT command does not physically
remove the marked group from the drawing; it only copies the group into
the clipboard.
Unfortunately, this has irritated Windows users time any again, so
beginning with version 6, the CUT command no longer appears in the
main pulldown menu and the command button toolbar (it is still available
from the command line and within scripts). Windows users will
simply use the <a href=#47>COPY</a> command to copy the selected
group of objects into the system's clipboard. This, however, will not
allow them to define an explicit reference point for the selected group.
It will always be selected at the center of the group's bounding rectangle.
Using a reference point is only possible with the CUT command.
If you don't like this, you can use the
<a href=#116>SET</a> command
<pre>
SET Cmd.Copy.ClassicEagleMode 1
</pre>
to get back the original behavior of the CUT command (as well as the <a href=#47>COPY</a>
command).


<a name=49>
<h1>DELETE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Deletes objects.
<dt>
<b>Syntax</b>
<dd>
<tt>DELETE &#149;..</tt><br>
<tt>DELETE name ..</tt><br>
<tt>DELETE SIGNALS</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Shift+Left</mb> deletes higher level object.<br>
<mb>Ctrl+Left</mb> deletes a wire joint or a port.<br>
<mb>Ctrl+Right</mb> deletes the group.
</dl>
<b>See also</b> <a href=#111>RIPUP</a>,
<a href=#53>DRC</a>,
<a href=#62>GROUP</a>
<p>
The DELETE command is used to delete the selected object.
<p>
Parts, pads, smds, pins and gates can also be selected by their name,
which is especially useful if the object is outside the currently shown
window area. Note that when selecting a multi-gate part in a schematic by name,
you will need to enter the full instance name, consisting of part
and gate name.
<p>
Attributes of parts can be selected by entering the concatenation of
part name and attribute name, as in <tt>R5&gt;VALUE</tt>.
<p>
Clicking the right mouse button deletes a previously defined
<a href=#62>GROUP</a>.
<p>
After deleting a group it is possible that airwires which have been newly
created due to the removal of a component may be "left over", because
they have not been part of the original group. In such a case you should
re-calculate the airwires with the <a href=#104>RATSNEST</a>
command.
<p>
With active <a href=#406>Forward&amp;Back Annotation</a>, no wires
or vias can be deleted from a signal that is connected to components in a board.
Also, no components can be deleted that have signals connected to them.
Modifications like these have to be done in the schematic. In this scenario,
the DELETE command will behave like the normal mode of the RIPUP command converting wires and vias back to airwires.
<p>
Use the <a href=#111>RIPUP</a> command to convert an already
routed connection back into an airwire.
<p>
The DELETE command has no effect on layers that are not visible (refer
to DISPLAY).
<p>
The DRC might generate error polygons which can only be deleted
with DRC CLEAR.
<h2>Deleting Wire Joints</h2>
If the DELETE command, with the <tt>Ctrl</tt> key pressed, is applied to the joining
point of two wires, these wires are combined to form one straight wire.
For this to work the two wires must be in the same layer and have the same width
and line style, and must both have round endings (in case of arcs).
<h2>Deleting Polygon Corners</h2>
The DELETE command deletes one corner at a time from a polygon. The
whole polygon is deleted if there are only three corners left.
<h2>Deleting Components</h2>
Components can be deleted only if the tOrigins layer (or bOrigins with
mirrored components) is visible and if (with active
<a href=#406>Forward&amp;Back Annotation</a>) no signals are
connected to
the component (see also <a href=#110>REPLACE</a>).
Please note that an element may appear to be not connected (no airwires
or wires leading to any of it's pads), while in fact it <b>is</b>
connected to a supply voltage through an implicit power pin. In such a case
you can only delete the corresponding part in the schematic.
<h2>Deleting Junctions, Nets, and Buses</h2>
The following rules apply:
<ul>
<li>If a bus is split into two parts, both keep the initial name.
<li>If a net is split into two parts, the larger one keeps the initial
name while the smaller one gets a new (generated) name.
<li>After the DELETE command, labels belong to the segment next to them.
<li>If a junction point is deleted, the net is separated at this location.
Please check the names of the segments with the SHOW command.
</ul>
<h2>Deleting Supply Symbols</h2>
If the last supply symbol of a given type is deleted from a net segment
that has the same name as the deleted supply pin, that segment is given
a newly generated name (if there are no other supply symbols still
attached to that segment) or the name of one of the remaining supply symbols.
<h2>Deleting Signals</h2>
If you select wires (tracks) or vias belonging to a signal with the DELETE
command three cases have to be considered:
<ul>
<li>The signal is split into two parts. EAGLE will generate a new name
for the smaller part of the signal and keep the previous name for
the larger one.
<li>The signal is deleted from one end. The remaining part of the signal
will keep the previous name.
<li>The signal had only one airwire. It will be deleted completely
and its name won't exist any longer.
</ul>
After wires or vias have been deleted from a signal which contains
polygons, all polygons belong to the signal keeping the original name
(usually the bigger part).
<h2>Deleting all Signals</h2>
<p>
DELETE SIGNALS can be used to delete all signals on a board. This
is useful if you want to read in a new or changed netlist (see EXPORT).
Only those signals are deleted which are connected to pads.
<p>
If you want to delete a part that has the name SIGNALS, you need to
write the name in single quotes.
<h2>Deleting higher level objects</h2>
If the <tt>Shift</tt> key is pressed when clicking on an object, the object
that is hierarchically above the selected one will be deleted. This applies
to the following objects:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>Gate</tt>    </td><td width=20><td>Deletes the entire part containing this gate (even if the gates are spread over several sheets). If f/b annotation is active, the wires connected to the element in the board will not be ripped up (as opposed to deleting a single gate), except for those cases where a pin of the deleted part is only connected directly to one single other pin and no net wire</td></tr>
<tr><td><tt>Polygon&nbsp;Wire</tt> </td><td width=20><td>Deletes the entire polygon</td></tr>
<tr><td><tt>Net/Bus&nbsp;Wire</tt> </td><td width=20><td>Deletes the entire net or bus segment</td></tr>
</table>
<p>
Don't forget: Deleting can be reversed by the
<a href=#133>UNDO</a> command!
<h2>Delete Key Operation with Group Default on</h2>
You can delete objects selected in the current group by pressing the delete key with the
<a href=#165>Group Default On</a> options enabled.


<a name=50>
<h1>DESCRIPTION</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines the description of a drawing or a library object.
<dt>
<b>Syntax</b>
<dd>
<tt>DESCRIPTION [ * ] [ description_string; ]</tt><br>
<tt>DESCRIPTION ** [ description_string; ]</tt>
</dl>
<b>See also</b> <a href=#46>CONNECT</a>,
<a href=#88>PACKAGE</a>,
<a href=#136>VALUE</a>
<p>
This command is used to define or edit the description of a drawing or a library object.
<p>
The <tt>description_string</tt> may contain <a href=#403>HTML</a> tags.
<p>
The first non-blank line of <tt>description_string</tt> will be used as a short
descriptive text (<i>headline</i>) in the Control Panel.
<p>
The DESCRIPTION command without a parameter opens a dialog in which the text can
be edited. The upper pane of this dialog shows the formatted text, in case it
contains <a href=#403>HTML</a> tags, while the lower pane is used
to edit the raw text. At the very top of the dialog the <i>headline</i> is displayed
as it would result from the first non-blank line of the description. The headline
is stripped of any HTML tags.
<p>
By default the DESCRIPTION command works on the description of the object that
is currently edited, like a device set, footprint, symbol, board or sheet.
If, in a library, there is no currently edited object (as can be the case after
it has been newly loaded) the description of the library will be changed.
<p>
To explicitly access the description of a library, even if a device, footprint or
symbol is already being edited, enter the asterisk character (<tt>'*'</tt>) as the
first parameter to the DESCRIPTION command. This is also the way to access the
description of a schematic, as opposed to the description of an individual sheet.
<p>
To access the description of the current <a href=#82>MODULE</a>,
enter a pair of asterisk characters (<tt>'**'</tt>) as the first parameter to
the DESCRIPTION command.
<h2>Example</h2>
<pre>
DESCRIPTION '&lt;b&gt;Quad NAND&lt;/b&gt;&lt;p&gt;\nFour NAND gates with 2 inputs each.';
</pre>
This would result in
<p>
<b>Quad NAND</b><p>
Four NAND gates with 2 inputs each.


<a name=51>
<h1>DIMENSION</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds dimensioning to a drawing.
<dt>
<b>Syntax</b>
<dd>
<tt>DIMENSION [dtype] &#149; &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.<br>
<mb>Right</mb> changes the dtype.<br>
<mb>Shift+Right</mb> reverses the direction of changing the dtype.<br>
<mb>Ctrl+Left</mb> when starting/ending a dimension does not select an object.<br>
</dl>
<b>See also</b> <a href=#73>LINE</a>,
<a href=#41>CHANGE</a>,
<a href=#43>CIRCLE</a>,
<a href=#64>HOLE</a>
<p>
The DIMENSION command adds dimensioning to a drawing.
It can either be applied to an object, or it can draw arbitrary
dimensions.
<p>
If the first point selects an object, a suitable dimension object is
generated as follows:
<p>
<table cellspacing=5>
<tr><td>straight wire</td><td width=20><td>linear dimension displaying the distance between the end points of the wire</td></tr>
<tr><td>curved wire</td>  <td width=20><td>radius dimension displaying the radius of the arc</td></tr>
<tr><td>circle</td>       <td width=20><td>diameter dimension displaying the diameter of the circle</td></tr>
<tr><td>hole</td>         <td width=20><td>diameter dimension displaying the diameter of the hole</td></tr>
</table>
<p>
If no object is selected, or a wire is selected at one of its end points,
a dimension object is generated according to the current dimension type.
If this dimension type is not the one that is needed, the right mouse
button can be clicked to loop through the various types.
<p>
To draw an arbitrary dimension even at close proximity to an object that would
trigger a specific kind of dimension, press the <tt>Ctrl</tt> key with the
first click. This may also be useful when using the DIMENSION command in a
script (by adding the 'C' modifier to the first coordinate), to make sure the
dimension appears exactly as intended.
<p>
The way in which a dimension object is drawn (line, unit, precision) can be configured
with "CHANGE DLINE/DUNIT" or with its properties dialog. Note that the "Unit" parameter
in this dialog refers to the unit in which the actual numbers of the dimension
object will be displayed.
<h2>Dimension Type</h2>
Every dimension object has three coordinates that define its reference
points and an alignment point. How these coordinates are actually
interpreted to display a dimension object depends on the dtype
property.
<p>
<b>Parallel</b>
<p>
A <i>parallel</i> dimension displays the distance between its first and
second reference point. The dimension line is parallel to the line going
through its reference points, and it runs through the given alignment
point. The actual position of the alignment point doesn't matter, only
its distance from the the line through its reference points is taken into
account.
When a parallel dimension object is newly created or modified, the alignment
point is normalized, so that it lies in the middle of the dimension line.
<p>
<b>Horizontal</b>
<p>
Same as <i>parallel</i>, but the dimension line extends only in X direction,
and it displays only the X distance between the reference points.
<p>
<b>Vertical</b>
<p>
Like <i>horizontal</i>, but for Y.
<p>
<b>Radius</b>
<p>
A <i>radius</i> dimension displays the distance between its first and
second reference point. The first reference point is at the center of the
arc this dimension is drawn for, while the second point is somewhere on
the arc itself.
If the alignment point is between the two reference
points, the dimension line is drawn between the reference points, which
is "inside" the arc. Otherwise the dimension
line is drawn "outside" of the arc. If the measurement text is too long
to fit on an inside radius dimension, the dimension line is drawn on the
outside.
A radius dimension automatically displays a cross at its
first reference point (which is the center of the arc).
When a radius dimension object is newly created or modified, the alignment
point is normalized, so that it lies in the middle of the dimension line
for an "inside" dimension, or just beyond the arrow for an "outside" dimension.
<p>
<b>Diameter</b>
<p>
A <i>diameter</i> dimension displays the distance between its first and
second reference point. The two reference points are on opposite sides of
the circle's circumference, so their distance measures the circle's diameter.
If the alignment point is between the two reference
points, the dimension line is drawn between the reference points, which
is "inside" the circle. Otherwise the dimension
line is drawn "outside" of the circle, much like a <i>parallel</i> dimension.
If the measurement text is too long to fit on an inside diameter dimension,
the dimension line is drawn on the outside.
A diameter dimension automatically displays a cross in the middle between its two
reference points (which is the center of the circle).
When a diameter dimension object is newly created or modified, the alignment
point is normalized, so that it lies at the same coordinates as its second
reference point for an "inside" dimension, or in the middle of the dimension
line for an "outside" dimension.
<p>
<b>Angle</b>
<p>
An <i>angle</i> dimension displays the angle between the second and third
reference point, measured counterclockwise around the first reference point
(which is the center of the arc).
When an angle dimension object is newly created or modified, the second reference
point is normalized, so that it has the same distance from the first point as the
third one does.
<p>
<b>Leader</b>
<p>
A <i>leader</i> dimension can be used to point at something in a drawing.
There is an arrow at the first point, and the second and third point define
a (bent) line. The leader doesn't display any measurement. You can use the
<a href=#131>TEXT</a> command to place any text you need.
<h2>Selection</h2>
A dimension object can be selected at any of its three points.


<a name=52>
<h1>DISPLAY</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Selects the visible layers.
<dt>
<b>Syntax</b>
<dd>
<tt>DISPLAY</tt><br>
<tt>DISPLAY [option] layer_number..</tt><br>
<tt>DISPLAY [option] layer_name..</tt>
</dl>
<b>See also</b> <a href=#72>LAYER</a>,
<a href=#102>PRINT</a>
<p>
Valid options are: ALL, NONE, LAST, ? and ??
<p>
The DISPLAY command is used to choose the visible layers. As parameters,
the layer number and the layer name are allowed (even mixed). If the
parameter ALL is chosen, all layers become visible. If the parameter
NONE is used, all layers are switched off. For example:
<pre>
DISPLAY NONE BOTTOM;
</pre>
Following this command only the Bottom layer is displayed.
<p>
If the parameter LAST is given, the previously visible layers will be displayed.
<p>
Please note that only those signal layers (1 through 16) are available
that have been entered into the layer setup in the <a href=#168>Design Rules</a>.
<p>
If the layer name or the layer number includes a negative sign, it
will be filtered out. For example:
<pre>
DISPLAY TOP -BOTTOM -3;
</pre>
In this case the Top layer is displayed while the Bottom layer and
the layer with the number 3 are not shown on the screen.
<p>
Avoid layer names ALL and NONE as well as names starting with a "-",
as well as the names of layer presets and aliases.
<p>
Some commands (PAD, SMD, SIGNAL, ROUTE) automatically activate certain
layers.
<p>
If the DISPLAY command is invoked without parameters, a dialog is
presented which allows you to adjust all layer settings.
<h2>Undefined Layers</h2>
The options '?' and '??' can be used to control what happens if an undefined
layer is given in a DISPLAY command. Any undefined layers following a '?' will
cause a warning and the user can either accept it or cancel the entire DISPLAY
command. Undefined layers following a '??' will be silently ignored.
This is most useful for writing script files that shall be able to handle any drawing,
even if a particular drawing doesn't contain some of the listed layers.
<pre>
DISPLAY TOP BOTTOM ? MYLAYER1 MYLAYER2 ?? OTHER WHATEVER
</pre>
In the above example the two layers TOP and BOTTOM are required and will cause
an error if either of them is missing. MYLAYER1 and MYLAYER2 will just be reported
if missing, allowing the user to cancel the operation, and OTHER and WHATEVER will
be displayed if they are there, otherwise they will be ignored.
<p>
The '?' and '??' options may appear any number of times and in any sequence.
<h2>Pads and Vias</h2>
If pads or vias have different shapes on different layers, the shapes of the currently
visible (activated with DISPLAY) signal layers are displayed on top of each other.
<p>
If the color selected for layer 17 (Pads) or 18 (Vias) is 0 (which represents
the current background color), the pads and vias are displayed
in the color and fill style of the respective signal layers. If no signal layer is
visible, pads and vias are not displayed.
<p>
If the color selected for layer 17 (Pads) or 18 (Vias) is not the background
color and no signal layers are visible, pads and vias are displayed in the
shape of the uppermost and undermost layer.
<p>
This also applies to printouts made with <a href=#102>PRINT</a>.
<h2>Selecting Objects</h2>
If you want to select certain objects or elements (e.g.
with MOVE or DELETE) the corresponding layer must be visible. Elements
can only be selected if the tOrigins (or bOrigins with mirrored elements)
layer is visible!
<h2>Parameter Aliases</h2>
Parameter aliases can be used to define certain parameter settings to the
DISPLAY command, which can later be referenced by a given name.
The aliases can also be accessed by clicking on the DISPLAY button
and holding the mouse button pressed until the list pops up.
A right click on the button also pops up the list.
<p>
The syntax to handle these aliases is:
<dl>
<dt>
<tt>DISPLAY = <i>name</i> <i>parameters</i></tt>
<dd>
Defines the alias with the given <i>name</i> to expand to the given
<i>parameters</i>. The <i>name</i> may consist of any number of letters,
digits and underlines, and is treated case insensitive. It must begin
with a letter or underline and may not be one of the option keywords.
<dt>
<tt>DISPLAY = <i>name</i> @</tt>
<dd>
Defines the alias with the given <i>name</i> to expand to the current
parameter settings of the command.
<dt>
<tt>DISPLAY = ?</tt>
<dd>
Asks the user to enter a name for defining an alias for the current
parameter settings of the command.
<dt>
<tt>DISPLAY = <i>name</i></tt>
<dd>
Opens the DISPLAY dialog and allows the user to select a set
of layers that will be defined as an alias under the given <i>name</i>.
<dt>
<tt>DISPLAY = <i>name</i>;</tt>
<dd>
Deletes the alias with the given <i>name</i>.
<dt>
<tt>DISPLAY <i>name</i></tt>
<dd>
Expands the alias with the given <i>name</i> and executes the DISPLAY command with
the resulting set of parameters. The <i>name</i> may be abbreviated and
there may be other parameters before and after the alias (even other
aliases). Note that in case <i>name</i> is an abbreviation, aliases have precedence
over other parameter names of the command.
</dl>
Example:
<p>
<tt>DISPLAY = MyLayers None Top Bottom Pads Vias Unrouted</tt>
<p>
Defines the alias "MyLayers" which, when used as in
<p>
<tt>DISPLAY myl</tt>
<p>
will display just the layers Top, Bottom, Pads, Vias and Unrouted
(without the "None" parameter the given layers would be displayed in
addition to the currently visible layers).
Note the abbreviated use of the alias and the case insensitivity.


<a name=53>
<h1>DRC</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Checks design rules.
<dt>
<b>Syntax</b>
<dd>
<tt>DRC</tt><br>
<tt>DRC &#149; &#149; ;</tt><br>
<tt>DRC LOAD|MERGE|SAVE filename;</tt><br>
<tt>DRC *</tt>
</dl>
<b>See also</b> <a href=#168>Design Rules</a>,
<a href=#44>CLASS</a>,
<a href=#116>SET</a>,
<a href=#55>ERC</a>,
<a href=#56>ERRORS</a>
<p>
The command DRC checks a board against the current set of <a href=#168>Design Rules</a>.
<p>
Please note that electrically irrelevant objects (wires in footprints, rectangles, circles
and texts) are not checked against each other for clearance errors.
<p>
The errors found are displayed as error polygons in the respective layers,
and can be browsed through with the <a href=#56>ERRORS</a> command.
<p>
Without parameters the DRC command opens a Design Rules dialog in which the board's
Design Rules can be defined, and from which the actual check can be started.
<p>
If two coordinates are given in the DRC command (or if the Select button is
clicked in the Design Rules dialog) all checks will be performed solely in the
defined rectangle. Only errors that occur (at least partly) in this area will be reported.
<p>
If you get DRC errors that don't go away, even if you modify the
<a href=#168>Design Rules</a>, make sure you check the
<a href=#44>Net class</a> of the reported object to see whether
the error is caused by a specific parameter of that class.
<p>
To delete all error polygons use the command
<pre>
ERRORS CLEAR
</pre>
<p>
The <tt>LOAD</tt> and <tt>SAVE</tt> options can be used to load the Design Rules
from or save them to the given file. If <i>filename</i> doesn't have the extension
<tt>".dru"</tt> it will be appended automatically. The <tt>MERGE</tt> option can
be used to merge some additional Design Rules parameters (the others remain
unchanged).
<p>
If the DRC command is given an asterisk character (<tt>'*'</tt>) as the
first parameter, the Design Rules dialog will be opened and allow editing the
Design Rules, without triggering an actual check when the dialog is confirmed.
<p>
With Live DRC enabled, the design rules are checked while editing.
<p>
<h2>Related SET commands</h2>
The SET command can be used to change the behavior of the DRC command:
<pre>
SET DRC_FILL  fill_name;
</pre>
Defines the fill style used for the DRC error polygons.
Default is LtSlash.
<pre>
SET LIVE_DRC  ON | OFF;
</pre>
Enables/Disables design rule checking of the design while editing.


<a name=54>
<h1>EDIT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Loads an existing drawing to be edited or creates a new drawing.
<dt>
<b>Syntax</b>
<dd>
<tt>EDIT name</tt><br>
<tt>EDIT name.ext</tt><br>
<tt>EDIT .ext</tt><br>
<tt>EDIT .sX [ .sY ]</tt><br>
<tt>EDIT name.mod</tt><br>
<tt>EDIT name.m2</tt><br>
<tt>EDIT .m3</tt><br>
<tt>EDIT modX.m3 modY.m1</tt><br>
<tt>EDIT;</tt>
</dl>
<b>See also</b> <a href=#86>OPEN</a>,
<a href=#45>CLOSE</a>,
<a href=#38>BOARD</a>,
<a href=#82>MODULE</a>
<p>
The EDIT command is used to load a drawing or if a library has been
opened with the OPEN command, to load a package, symbol, or device for
editing.
<p>
The EDIT command is also used to create or edit modules within a schematic.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>EDIT name.brd</tt>  </td><td width=20><td>loads a board</td></tr>
<tr><td><tt>EDIT name.sch</tt>  </td><td width=20><td>loads a schematic</td></tr>
<tr><td><tt>EDIT name.fpt</tt>  </td><td width=20><td>loads a footprint (new in EAGLE 9.1)</td></tr>
<tr><td><tt>EDIT name.pac</tt>  </td><td width=20><td>loads a footprint (alternative suffix for backwards compatibility with older EAGLE versions)</td></tr>
<tr><td><tt>EDIT name.sym</tt>  </td><td width=20><td>loads a symbol</td></tr>
<tr><td><tt>EDIT name.dev</tt>  </td><td width=20><td>loads a device</td></tr>
<tr><td><tt>EDIT name.dbl</tt>  </td><td width=20><td>loads a design block in preview dialog</td></tr>
<tr><td><tt>EDIT name.dbl;</tt> </td><td width=20><td>loads a new design block into the editor(s)</td></tr>
<tr><td><tt>EDIT urn</tt>       </td><td width=20><td>loads a footprint|symbol|device by urn</td></tr>
<tr><td><tt>EDIT .s3</tt>       </td><td width=20><td>loads sheet 3 of a schematic</td></tr>
<tr><td><tt>EDIT .s5 .s2 </tt>  </td><td width=20><td>moves sheet 5 before sheet 2 and loads it (if sheet 5 doesn't exist, a new sheet is inserted before sheet 2)</td></tr>
<tr><td><tt>EDIT .s2 .s5 </tt>  </td><td width=20><td>moves sheet 2 before sheet 5 and loads it (if sheet 5 doesn't exist, sheet 2 becomes the last sheet)</td></tr>
<tr><td><tt>EDIT name.mod</tt>  </td><td width=20><td>loads (or creates) a module within a schematic</td></tr>
<tr><td><tt>EDIT name.m2</tt>   </td><td width=20><td>loads (or creates) sheet 2 of module</td></tr>
<tr><td><tt>EDIT .m3</tt>       </td><td width=20><td>loads (or creates) sheet 3 of the current module</td></tr>
<tr><td><tt>EDIT .s2 modY.m1</tt>  </td><td width=20><td>moves sheet 2 before sheet 1 of module 'modY' and loads it</td></tr>
<tr><td><tt>EDIT modX.m3 modY.m1</tt>  </td><td width=20><td>moves sheet 3 of module 'modX' before sheet 1 of module 'modY' and loads it</td></tr>
<tr><td><tt>EDIT;</tt>          </td><td width=20><td>shows table of contents (in a library)</td></tr>
</table>
<p>
Wildcards in the name are allowed (e.g. *.brd).
<p>
The EDIT command without parameters will cause a
file dialog (in board or schematic mode) or a
<a href=#25>popup menu</a> (in library mode) to appear
from which you can select the file or object.
<p>
To change from schematic to a board with the same name the command
<pre>
EDIT .brd
</pre>
can be used. In the same way to change from board to schematic use
the command
<pre>
EDIT .sch
</pre>
It's also possible to change from the library editor to board or schematic.
<p>
To edit another sheet of a schematic the command
<pre>
EDIT .sX
</pre>
(X is the sheet number) or the combo box in the action toolbar of the
editor window can be used. If the given sheet number doesn't exist,
a new sheet is created.
<p>
You can also switch between sheets by clicking on an icon of the sheet
thumbnail preview. Drag&amp;drop in the thumbnail preview allows you to
reorder sheets.
<p>
Symbols, devices or footprints may only be edited if a library is first
opened with the OPEN command. To do this, it is possible to use the name or the urn of the component.
<h2>Which Directory?</h2>
EDIT loads files from the
<a href=#15>project directory</a>.


<a name=55>
<h1>ERC</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Electrical Rule Check.
<dt>
<b>Syntax</b>
<dd>
<tt>ERC</tt>
</dl>
<b>See also</b> <a href=#53>DRC</a>,
<a href=#56>ERRORS</a>,
<a href=#407>Consistency Check</a>
<p>
This command is used to test schematics for electrical errors. The
result of the check is presented in the <a href=#56>ERRORS</a>
dialog.
<h2>Consistency Check</h2>
The ERC command also performs a
<a href=#407>Consistency Check</a>
between a schematic and its corresponding board, provided the board file
has been loaded before starting the ERC.
As a result of this check the automatic
<a href=#406>Forward&amp;Back Annotation</a>
will be turned on or off, depending on whether the files have been found
to be consistent or not.
<p>
Please note that the ERC detects inconsistencies between the implicit power
and supply pins in the schematic and the actual signal connections in the board.
Such inconsistencies can occur if the supply pin configuration is modified
after the board has been created with the BOARD command. Since the power
pins are only connected "implicitly", these changes can't always be forward
annotated.<br>
If such errors are detected, <a href=#406>Forward&amp;Back Annotation</a>
will still be performed, but the supply pin configuration should be checked!


<a name=56>
<h1>ERRORS</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Shows the errors found by the ERC or DRC command.
<dt>
<b>Syntax</b>
<dd>
<tt>ERRORS</tt><br>
<tt>ERRORS CLEAR</tt>
</dl>
<b>See also</b> <a href=#55>ERC</a>,
<a href=#53>DRC</a>
<p>
The command ERRORS is used to show the errors found by the Electrical Rule Check (ERC)
or the Design Rule Check (DRC). If selected, a window is opened in which
all errors are listed. If no ERC or DRC has been run for the loaded drawing, yet,
the respective check will be started first.
<p>
The list view in the ERRORS dialog has up to four sections that contain
<i>Consistency errors</i>, <i>Errors</i>, <i>Warnings</i> and <i>Approved</i>
messages, respectively.
<p>
Selecting an entry with the mouse causes the error to be marked in the editor
window with a rectangle and a line from the upper left corner of the screen.
<p>
Double clicking an entry centers the drawing to the area where the error is located.
Checking the "Centered" checkbox causes this to happen automatically.
<h2>Marking a message as processed</h2>
The <i>Processed</i> button marks a message as processed. It is still contained
in the list, but there is no error indicator in the editor window any more (except
if the list entry is selected). This can be used to mark messages as "done" after
fixing the related problem, without having to run the check again. After the next
ERC/DRC the message will be either gone, or marked as unprocessed again if the
problem still persists.
<h2>Approving a message</h2>
If an error or warning can't be fixed, but apparently doesn't matter (which the
user has to decide), it can be moved to the <i>Approved</i> section by pressing
the <i>Approve</i> button. Messages in that section will not draw error indicators
in the editor window (except if the list entry is selected) and are implicitly
marked as "processed". If any of these messages no longer apply after the
next ERC/DRC, they will be deleted. All approved messages are stored in the drawing
file, so that it is documented which ones have been explicitly approved by the
user. Note that consistency errors can not be approved - they always have to
be fixed in order to activate <a href=#406>Forward&amp;Back Annotation</a>.
<h2>Clearing the list</h2>
The <i>Clear all</i> button deletes all entries form the list, except for the
approved messages. This can be used to get rid of the error indicators in
the editor window. The next ERC/DRC will regenerate the messages again, if
they still apply.
<p>
The list can also be cleared by entering the command
<pre>
ERRORS CLEAR
</pre>
 


<a name=57>
<h1>EXPORT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Generation of data files.
<dt>
<b>Syntax</b>
<dd>
<tt>EXPORT SCRIPT    filename;</tt><br>
<tt>EXPORT NETLIST   filename;</tt><br>
<tt>EXPORT SPICENETLIST   filename;</tt><br>
<tt>EXPORT NETSCRIPT filename;</tt><br>
<tt>EXPORT PARTLIST  filename;</tt><br>
<tt>EXPORT PINLIST   filename;</tt><br>
<tt>EXPORT DIRECTORY filename;</tt><br>
<tt>EXPORT IMAGE     filename|CLIPBOARD [MONOCHROME|WINDOW] resolution;</tt>
</dl>
<b>See also</b> <a href=#115>SCRIPT</a>,
<a href=#114>RUN</a>
<p>
The EXPORT command is used to provide you with ASCII text files which
can be used e.g. to transfer data from EAGLE to other programs, or to
generate an image file from the current drawing.
<p>
By default the output file is written into the <b>Project</b> directory.
<p>
The command generates the following output files:
<h2>SCRIPT</h2>
A library previously opened with the OPEN command will be output as
a script file. When a library has been exported and is to be imported
again with the SCRIPT command, a new library should be opened in order
to avoid duplication - e.g. the same symbol is defined more than
once. Reading script files can be accelerated if the command
<pre>
Set Undo_Log Off;
</pre>
is given before.
<h2>NETLIST</h2>
Generates a netlist for the loaded schematic or board. Only nets which
are connected to elements are listed.
<h2>SPICENETLIST</h2>
Generates a spice-formatted netlist for the loaded schematic. Only nets which
are connected to elements are listed.
<h2>NETSCRIPT</h2>
Generates a netlist for the loaded schematic in the form of a script
file. This file can be used to read a new or changed netlist into
a board where elements have already been placed or previously routed
tracks have been deleted with <tt>DELETE SIGNALS</tt>.
Note that while reading such a script into a board no schematic that
is consistent with this board may be loaded.
<h2>PARTLIST</h2>
Generates a component list for schematics or boards. Only elements
with pins/pads are included.
<h2>PINLIST</h2>
Generates a list with pads and pins, containing the pin directions and
the names of the nets connected to the pins.
<h2>DIRECTORY</h2>
Lists the directory of the currently opened library.
<h2>IMAGE</h2>
Exporting an <i>IMAGE</i> generates an image file with a format corresponding
to the given filename extension. The following image formats are available:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>.bmp</tt></td>   <td width=20><td>Windows Bitmap Files</td></tr>
<tr><td><tt>.png</tt></td>   <td width=20><td>Portable Network Graphics Files</td></tr>
<tr><td><tt>.pbm</tt></td>   <td width=20><td>Portable Bitmap Files</td></tr>
<tr><td><tt>.pgm</tt></td>   <td width=20><td>Portable Grayscale Bitmap Files</td></tr>
<tr><td><tt>.ppm</tt></td>   <td width=20><td>Portable Pixelmap Files</td></tr>
<tr><td><tt>.tif</tt></td>   <td width=20><td>TIFF Files</td></tr>
<tr><td><tt>.xbm</tt></td>   <td width=20><td>X Bitmap Files</td></tr>
<tr><td><tt>.xpm</tt></td>   <td width=20><td>X Pixmap Files</td></tr>
</table>
<p>
The <i>resolution</i> parameter defines the image resolution (in 'dpi').
<p>
If <i>filename</i> is the special name CLIPBOARD (upper or lowercase doesn't matter)
the image will be copied into the system's clipboard.
<p>
The optional keyword <i>MONOCHROME</i> creates a black&amp;white image.
<p>
The optional keyword <i>WINDOW</i> creates an image of the currently visible
area in the editor window. Without this keyword, the image will contain the
entire drawing.
<h2>Further formats</h2>
A lot of further formats like DXF or Hyperlynx can be exported by ULPs.
They can be started from command line using the <a href=#114>RUN</a> command.
Under 'File/Export' a number these format exports are also available.


<a name=58>
<h1>FANOUT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Creates fanouts from devices and signals.
<dt>
<b>Syntax</b>
<dd>
<tt>FANOUT DEVICE device-name [direction]</tt><br>
<tt>FANOUT SIGNAL signal-name [direction]</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Left</mb> selects the device or signal to fanout.
</dl>
<b>See also</b> <a href=#37>BGA</a>,
<a href=#113>ROUTE</a>,
<a href=#41>CHANGE</a>,
<a href=#168>DESIGN RULES</a>,
<p>
The FANOUT command creates a routed wire and attached via from pads of the selected device or signal.
Only surface mount devices (SMD) or ball-grid array (BGA) devices will be fanned out; devices with through-hole
pads will be ignored.
<p>
The WIDTH parameter defines the width of the routed wire for the fanout
and is the same parameter as used in the ROUTE command. The width can
be changed with the command:
<pre>
CHANGE WIDTH width;
</pre>
where <i>width</i> is the desired value in the current unit.
<p>
If the width is less than the Design Rules minimum width, then the minimum width will be used as to avoid a design rule violation.
<p>
The via used for the fanout is defined by both the Drill and Diameter parameter toolbar settings.    And like the width parameter,
if the Drill size is less than the Design Rules minimum Drill, then the minimum size will be used.   The Drill can be changed
with the command:
<pre>
CHANGE DRILL drill-size;
</pre>
<p>
The distance from the pad to where the via is placed can be controlled by the Design Rule clearance of same-signal Smd To Via.
See the <a href=#168>DESIGN RULES</a> command.
<p>
If the fanout wire and/or via would cause a design rule violation, then that specific fanout from a pad is not performed.
For these situations look at the Width and Drill size parameters and the Design Rule minimums (including Net Classes)
to see if any adjustments to the Width or Drill is needed.  If these values cannot be changed, then you may also
try using the fanout direction of fanout-alternate which helps for these cases.
<p>
The parameters toolbar button Allow Violations, when enabled, permits the FANOUT command to create via fanouts even when the via would cause
a design rule violation to a neighboring fanout.    This option can be used to help determine why certain vias are not being fanned out
by being able to see the violation a particular via would create.   The default for this option is off, do not allow violations.
<h2>Direction</h2>
The direction of the fanout relative to the device can be controlled with the fanout direction parameters in the toolbar, or the following optional
command line options :
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Out         </td><td width=20><td>Fanouts go out and away from the device center</td></tr>
<tr><td>In          </td><td width=20><td>Fanouts go inwards toward the device center</td></tr>
<tr><td>Alternate   </td><td width=20><td>Fanouts alternate between OUT and IN for adjacent pads</td></tr>
</table>
<h2>Example</h2>
<pre>
FANOUT DEVICE U3;
FANOUT DEVICE U4 OUT;
FANOUT SIGNAL GND ALTERNATE;
FANOUT SIGNAL +5;
</pre>


<a name=59>
<h1>FRAME</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds a frame to a drawing.
<dt>
<b>Syntax</b>
<dd>
<tt>FRAME [ columns [ rows ] ] [ borders ] &#149; &#149;</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.
</dl>
<b>See also</b> <a href=#68>LABEL</a>
<p>
The FRAME command draws a frame with numbered columns and rows.
The two points define two opposite corners of the frame. Pressing the center
mouse button changes the layer to which the frame is to be added.
<p>
The <tt>columns</tt> parameter defines the number of columns in the frame.
There can be up to 127 columns. By default the columns are numbered from
left to right. If the <tt>columns</tt> value is negative, they are numbered
from right to left.
<p>
The <tt>rows</tt> parameter defines the number of rows in the frame.
There can be up to 26 rows. Rows are marked from top to bottom with letters,
beginning with 'A'. If the <tt>rows</tt> value is negative, they are marked
from bottom to top. If <tt>rows</tt> is given, it must be preceeded by
<tt>columns</tt>.
<p>
The <tt>borders</tt> parameter, if given, defines which sides of the frame
will have a border with numbers or letters displayed. Valid options for this
parameter are <tt>Left</tt>, <tt>Top</tt>, <tt>Right</tt> and <tt>Bottom</tt>.
By default all four sides of the frame will have a border. If any of these
options is given, only the requested sides will have a border. The special
options <tt>None</tt> and <tt>All</tt> can be used to have no borders at all,
or all sides marked.
<p>
Even though you can draw several frames in the same drawing, only the first
one will be used for calculating the positions of parts and nets. These positions
can be used, for instance, in a <a href=#173>User Language</a> Program
to generate a list of parts with their locations in their respective frame.
They are also used internally to automatically generate cross references
for <a href=#68>labels</a>.
<p>
Due to the special nature of the frame object, it doesn't have a rotation of
its own, and it doesn't get rotated with the <a href=#112>ROTATE</a>
command.
<p>
A frame can be drawn directly into a board or schematic, but more typically you
will want to create a special symbol or footprint drawing that perhaps also
contains a title block, which you can then use in all your drawings.
The "frames" library that comes with EAGLE contains several drawing frames.
<h2>Example</h2>
<pre>
FRAME 10 5 TOP LEFT &#149; &#149;
</pre>
draws a frame with 10 columns (numbered from left to right) and 5 rows (marked
'A' to 'E' from top to bottom) that has the column and row indicators drawn only
at the top and left border.


<a name=60>
<h1>GATESWAP</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Swaps equivalent gates on a schematic.
<dt>
<b>Syntax</b>
<dd>
<tt>GATESWAP &#149; &#149;..;</tt><br>
<tt>GATESWAP gate_name gate_name..;</tt>
</dl>
<b>See also</b> <a href=#31>ADD</a>
<p>
Using this command two gates may be swapped within a schematic. Both
gates must be identical with the same number of pins and must be allocated
the same Swaplevel in the device definition. They do not, however,
need to be in the same device.
<p>
The name used in the GATESWAP command is the displayed name on the
schematic (e.g. U1A for gate A in device U1).
<p>
If a device is not used anymore after the GATESWAP command, it is
deleted automatically from the drawing.


<a name=61>
<h1>GRID</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines grid.
<dt>
<b>Syntax</b>
<dd>
<tt>GRID option..;</tt><br>
<tt>GRID;</tt>
<dt>
<b>Keyboard</b>
<dd>
<tt>F6: GRID;</tt>   turns the grid on or off.
</dl>
<b>See also</b> <a href=#115>SCRIPT</a>
<p>
The GRID command is used to specify the grid and the current unit.
Given without an option, this command switches between  GRID ON
and GRID OFF.
<p>
The following options exist:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>GRID ON;</tt>        </td><td width=20><td>Displays the grid on the screen</td></tr>
<tr><td><tt>GRID OFF;</tt>       </td><td width=20><td>Turns off displayed grid</td></tr>
<tr><td><tt>GRID DOTS;</tt>      </td><td width=20><td>Displays the grid as dots</td></tr>
<tr><td><tt>GRID LINES;</tt>     </td><td width=20><td>Displays the grid as solid lines</td></tr>
<tr><td><tt>GRID MIC;</tt>       </td><td width=20><td>Sets the grid units to micron</td></tr>
<tr><td><tt>GRID MM;</tt>        </td><td width=20><td>Sets the grid units to mm</td></tr>
<tr><td><tt>GRID MIL;</tt>       </td><td width=20><td>Sets the grid units to mil</td></tr>
<tr><td><tt>GRID INCH;</tt>      </td><td width=20><td>Sets the grid units to inch</td></tr>
<tr><td><tt>GRID FINEST;</tt>    </td><td width=20><td>Sets the grid to the finest possible value</td></tr>
<tr><td><tt>GRID grid_size;</tt> </td><td width=20><td>Defines the distance between</td></tr>
<tr><td>                     </td><td width=20><td>the grid points in the actual unit</td></tr>
<tr><td><tt>GRID LAST;</tt>      </td><td width=20><td>Sets grid to the most recently</td></tr>
<tr><td>                     </td><td width=20><td>used values</td></tr>
<tr><td><tt>GRID DEFAULT;</tt>   </td><td width=20><td>Sets grid to the standard values</td></tr>
<tr><td><tt>GRID grid_size grid_multiple;</tt> </td><td width=20><td></td></tr>
<tr><td>                     </td><td width=20><td>grid_size = grid distance</td></tr>
<tr><td>                     </td><td width=20><td>grid_multiple = grid factor</td></tr>
<tr><td><tt>GRID ALT ...;</tt>   </td><td width=20><td>Defines the alternate grid</td></tr>
</table>
<h2>Examples</h2>
<pre>
Grid mm;
Set Diameter_Menu 1.0 1.27 2.54 5.08;
Grid Last;
</pre>
In this case you can change back to the last grid definition
although you don't know what the definition looked like.
<pre>
GRID mm 1 10;
</pre>
for instance specifies that the distance between the grid points is
1 mm and that every 10th grid line will be displayed.
<p>
Note: The first number in the GRID command always represents the grid
distance, the second - if existing - represents the grid multiple.
<p>
The GRID command may contain multiple parameters:
<pre>
GRID inch 0.05 mm;
</pre>
In this case the grid distance is first defined as 0.05 inch. Then
the coordinates of the cursor are chosen to be displayed in mm.
<pre>
GRID DEFAULT;
</pre>
Sets grid to the standard value for the current drawing type.
<pre>
GRID mil 50 2 lines on alt mm 1 mil;
</pre>
Defines a 50 mil grid displayed as lines (with only every other line visible), and sets the alternate grid size to 1 mm,
but displays it in mil.
<p>
Pressing the <tt>Alt</tt> key switches to the alternate Grid.
This can typically be a finer grid than the normal one, which allows you to quickly
do some fine positioning in a dense area, for instance, where the normal grid might
be too coarse.
The alternate grid remains active as long as the <tt>Alt</tt> key is held pressed down.
<h2>Parameter Aliases</h2>
Parameter aliases can be used to define certain parameter settings to the
GRID command, which can later be referenced by a given name.
The aliases can also be accessed by clicking on the GRID button
and holding the mouse button pressed until the list pops up.
A right click on the button also pops up the list.
<p>
The syntax to handle these aliases is:
<dl>
<dt>
<tt>GRID = <i>name</i> <i>parameters</i></tt>
<dd>
Defines the alias with the given <i>name</i> to expand to the given
<i>parameters</i>. The <i>name</i> may consist of any number of letters,
digits and underlines, and is treated case insensitive. It must begin
with a letter or underline and may not be one of the option keywords.
<dt>
<tt>GRID = <i>name</i> @</tt>
<dd>
Defines the alias with the given <i>name</i> to expand to the current
parameter settings of the command.
<dt>
<tt>GRID = ?</tt>
<dd>
Asks the user to enter a name for defining an alias for the current
parameter settings of the command.
<dt>
<tt>GRID = <i>name</i></tt>
<dd>
Opens the GRID dialog and allows the user to adjust the grid
parameters and define an alias for them under the given <i>name</i>.
<dt>
<tt>GRID = <i>name</i>;</tt>
<dd>
Deletes the alias with the given <i>name</i>.
<dt>
<tt>GRID <i>name</i></tt>
<dd>
Expands the alias with the given <i>name</i> and executes the GRID command with
the resulting set of parameters. The <i>name</i> may be abbreviated and
there may be other parameters before and after the alias (even other
aliases). Note that in case <i>name</i> is an abbreviation, aliases have precedence
over other parameter names of the command.
</dl>
Example:
<p>
<tt>GRID = MyGrid inch 0.1 lines on</tt>
<p>
Defines the alias "MyGrid" which, when used as in
<p>
<tt>GRID myg</tt>
<p>
will change the current grid to the given settings.
Note the abbreviated use of the alias and the case insensitivity.


<a name=62>
<h1>GROUP</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a group.
<dt>
<b>Syntax</b>
<dd>
<tt>GROUP &#149;..</tt><br>
<tt>GROUP ALL</tt><br>
<tt>GROUP;</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Left&amp;Drag</mb> defines a rectangular group.<br>
<mb>Shift+Left</mb> adds the new group to an existing one.<br>
<mb>Ctrl+Left</mb> toggles the group membership of the selected object.<br>
<mb>Ctrl+Shift+Left</mb> toggles the group membership of the higher level object.<br>
<mb>Right</mb> closes the group polygon. <br>
<mb>Ctrl+A</mb> kicks off GROUP ALL to select all objects.
</dl>
<b>See also</b> <a href=#41>CHANGE</a>,
<a href=#48>CUT</a>,
<a href=#91>PASTE</a>,
<a href=#80>MIRROR</a>,
<a href=#49>DELETE</a>
<p>
The GROUP command is used to define a group of objects
for a successive command. Also a whole drawing or an element can be
defined as a group. Objects are selected - after activating the
GROUP command - by click&amp;dragging a rectangle or by drawing a polygon with the mouse. The easiest
way to close the polygon is to use the right mouse button. Only objects
from displayed layers can become part of the group.
<p>
The keyword <tt>ALL</tt> can be used to define a group that includes
the entire drawing area.
<p>
Selection of attributes can be disabled using the parameter toolbar button Enable Attribute Selection by unchecking the toggle button.
The default for this button is checked, to allow selection of device attributes.
<p>
The group includes:
<ul>
<li>all objects whose origin is inside the polygon
<li>all wires with at least one end point inside the polygon
<li>all circles whose center is inside the polygon
<li>all rectangles with any corner inside the polygon
</ul>
<h2>Move Group</h2>
In order to move a group it is necessary to select the MOVE command
with the right mouse button. When moving wires (tracks) with
the GROUP command that have only one end point in the polygon, this
point is moved while the other one remains at its previous position.
<p>
For instance: In order to change several pad shapes, select
CHANGE and SHAPE with the left mouse button and select the group with
the right mouse button.
<p>
The group definition remains until a new drawing is loaded
or the command
<pre>
GROUP;
</pre>
is executed.
<h2>Extending the group</h2>
If you press the <tt>Shift</tt> key together with any mouse click when
defining the group, the newly defined group will be added to the existing group (if
any).
<h2>Individual objects</h2>
You can toggle the group membership of an individual object by clicking on it
with the <tt>Ctrl</tt> key pressed. If you also press the <tt>Shift</tt> key
when doing so, the group membership of the next higher level object is toggled.
For instance, when clicking on a net wire in a schematic with the GROUP command
and <tt>Ctrl+Shift</tt> pressed, the group membership of the entire segment will
be toggled.
<h2>Group Default on</h2>
There is a new user option that makes GROUP the default operation. You can left-click and drag to move objects, and more ..
<p>
See the <a href=#165>Group Default On</a> option for more info.


<a name=63>
<h1>HELP</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Help for the current command.
<dt>
<b>Syntax</b>
<dd>
<tt>HELP</tt><br>
<tt>HELP command</tt>
<dt>
<b>Keyboard</b>
<dd>
<tt>F1: HELP</tt>   activates the context sensitive help.
</dl>
This command opens a context sensitive help window.
<p>
A <tt>command</tt> name within the HELP command shows the help page of that
command.
<h2>Example</h2>
<pre>
HELP GRID;
</pre>
displays the help page for the GRID command.


<a name=64>
<h1>HOLE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Add drill hole to a board or footprint.
<dt>
<b>Syntax</b>
<dd>
<tt>HOLE drill &#149;..</tt>
</dl>
<b>See also</b> <a href=#138>VIA</a>,
<a href=#89>PAD</a>,
<a href=#41>CHANGE</a>
<p>
This command is used to define e.g. mounting holes (has no electrical
connection between the different layers) in a board or in a footprint.
The parameter drill defines the diameter of the hole in the
actual unit. It may be up to 200 mm (7.7840 inch).
<h2>Example</h2>
<pre>
HOLE 0.20 &#149;
</pre>
If the actual unit is "inch", the hole will have a diameter
of 0.20 inch.
<p>
The entered value for the diameter (also used for via-holes and pads)
remains as a presetting for successive operations. It may be changed
with the command:
<pre>
CHANGE DRILL value &#149;
</pre>
A hole can only be selected if the Holes layer is displayed.
<p>
A hole generates a symbol in the Holes layer as well as a circle with
the diameter of the hole in the Dimension layer. The relation between
certain diameters and symbols is defined in the "Options/Set/Drill" dialog.
The circle in the Dimension layer is used by the Autorouter. As
it will keep a (user-defined) minimum distance between via-holes/wires
and dimension lines, it will automatically keep this distance to the
hole.
<p>
In the layers tStop and bStop, holes generate the solder
stop mask, whose diameter is determined by the <a href=#168>Design Rules</a>.


<a name=65>
<h1>INFO</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Display and modify object properties.
<dt>
<b>Syntax</b>
<dd>
<tt>INFO &#149;..</tt><br>
<tt>INFO name ..</tt>
</dl>
<b>See also</b> <a href=#41>CHANGE</a>,
<a href=#117>SHOW</a>
<p>
The INFO command displays further details about an object's properties
on screen, e.g. wire width, layer number, text size etc.
It is also possible to modify properties in this dialog.
<p>
Parts, pads, smds, pins and gates can also be selected by their name,
which is especially useful if the object is outside the currently shown
window area. Note that when selecting a multi-gate part in a schematic by name,
you will need to enter the full instance name, consisting of part
and gate name.
<p>
Selection of attributes can be disabled using the parameter toolbar button Enable Attribute Selection by unchecking the toggle button.
The default for this button is checked, to allow selection of device attributes.
<p>
Attributes of parts can be selected by entering the concatenation of
part name and attribute name, as in <tt>R5&gt;VALUE</tt>.
<p>
The coordinates of a rotated rect are not changeable.
<p>
In the design block editing mode the command <tt>INFO .dbl</tt> will show a dialog
that allows modifying description and attributes of the currently edited design block.


<a name=66>
<h1>INVOKE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Call a specific symbol from a device.
<dt>
<b>Syntax</b>
<dd>
<tt>INVOKE &#149; orientation &#149;</tt><br>
<tt>INVOKE part_name gate_name orientation &#149;</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> mirrors the gate.<br>
<mb>Right</mb> rotates the gate.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#47>COPY</a>,
<a href=#31>ADD</a>
<p>
See the ADD command for an explanation of Addlevel und Orientation.
<p>
The INVOKE command is used to select a particular gate from a device
which is already in use and place it in the schematic (e.g. a power
symbol with Addlevel = Request).
<p>
Gates are activated in the following way:
<ul>
<li>Enter the part name (e.g. IC5) and select the gate from the popup dialog that appears.
<li>Define device and gate name from the keyboard (e.g. INVOKE IC5 POWER).
<li>Select an existing gate from the device with the mouse and then select the desired gate from the popup menu which appears.
</ul>
The final mouse click positions the new gate.
<p>
If an already invoked gate is selected in the dialog, the default button changes
to "Show", and a click on it zooms the editor window in on the selected gate,
switching to a different sheet if necessary.
<h2>Gates on Different Sheets</h2>
If a gate from a device on a different sheet is to be added
to the current sheet, the name of the part has to be specified in
the INVOKE command. In this case the right column of the popup menu
shows the sheet numbers where the already used gates are placed.


<a name=67>
<h1>JUNCTION</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Places a dot at intersecting nets.
<dt>
<b>Syntax</b>
<dd>
<tt>JUNCTION &#149;..</tt>
</dl>
<b>See also</b> <a href=#85>NET</a>
<p>
This command is used to draw a connection dot at the intersection
of nets which are to be connected to each other. Junction points may
be placed only on a net. If placed on the intersection of different
nets, the user is given the option to connect the nets.
<p>
If a net wire is placed at a point where there are at least two other
net wires and/or pins, a junction will automatically be placed.
This function can be disabled with "<tt>SET AUTO_JUNCTION OFF;</tt>",
or by unchecking "Options/Set/Misc/Auto set junction".
<p>
On the screen junction points are displayed at least with a diameter
of five pixels.


<a name=68>
<h1>LABEL</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Attaches text labels to buses and nets.
<dt>
<b>Syntax</b>
<dd>
<tt>LABEL [XREF] [orientation] &#149; &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.<br>
<mb>Right</mb> rotates the label.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#84>NAME</a>,
<a href=#39>BUS</a>,
<a href=#59>FRAME</a>
<p>
Bus or net names may be placed on a schematic in any location by using
the label command. When the bus or net is clicked on with the mouse,
the relevant label attaches to the mouse cursor and may be rotated,
changed to another layer, or moved to a different location. The second
mouse click defines the location of the label.
<p>
The orientation of the label may be defined textually
using the usual definitions as listed in the <a href=#31>ADD</a> command (R0, R90
etc.).
<p>
Buses and nets may have any number of labels.
<p>
Labels cannot be changed with "CHANGE TEXT".
<p>
Labels are handled by the program as text, but their value corresponds
to the name of the appropriate bus or net. If a bus or net is renamed
with the NAME command, all associated labels are renamed automatically.
<p>
If a bus, net, or label is selected with the SHOW command, all connected
buses, nets and labels are highlighted.
<h2>Cross-reference labels</h2>
If the optional keyword <tt>XREF</tt> is given, the label will be a
"cross-reference" label. Cross-reference labels can be used in multi-sheet
schematics to indicate the next sheet a particular net appears on (note that
this only works for nets, not for busses!).
The <tt>XREF</tt> keyword is mainly for use in scripts. Normally the setting
is taken from what has previously been set with <a href=#41>CHANGE XREF</a>,
or by clicking on the Xref button in the parameter toolbar.
<p>
The format in which a cross-reference label is displayed can be controlled
through the "Xref label format" string, which is defined in the "Options/Set/Misc"
dialog, or with the <a href=#116>SET</a> command.
The following placeholders are defined, and can be used in any order:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%F</tt></td>  <td width=20><td>enables drawing a flag border around the label</td></tr>
<tr><td><tt>%N</tt></td>  <td width=20><td>the name of the net</td></tr>
<tr><td><tt>%S</tt></td>  <td width=20><td>the next sheet number</td></tr>
<tr><td><tt>%C</tt></td>  <td width=20><td>the column on the next sheet</td></tr>
<tr><td><tt>%R</tt></td>  <td width=20><td>the row on the next sheet</td></tr>
</table>
<p>
The default format string is <tt>"%F%N/%S.%C%R"</tt>. Apart from the defined
placeholders you can also use any other ASCII characters.
<p>
The column and row values only work if there is a <a href=#59>frame</a>
on the next sheet on which the net appears. If <tt>%C</tt> or <tt>%R</tt> is
used and there is no frame on that sheet, they will display a question mark (<tt>'?'</tt>).
<p>
When determining the column and row of a net on a sheet, first the column and then
the row within that column is taken into account. Here XREF labels take precedence
over normal labels, which again take precedence over net wires.
For a higher sheet number, the frame coordinates of the left- and topmost field
are taken, while for a lower sheet number those of the right- and bottommost field
are used.
<p>
The orientation of a cross-reference label defines whether it will point to
a "higher" or a "lower" sheet number. Labels with an orientation of R0 or R270 point
to the right or bottom border of the drawing, and will therefore refer to
a higher sheet number. Accordingly, labels with an orientation of R90 or R180 will
refer to a lower sheet number. If a label has an orientation of R0 or R270, but the
net it is attached to is not present on any higher sheet, a reference to the next
lower sheet is displayed instead (the same applies accordingly to R90 and R180).
If the net appears only on the current sheet, no cross-reference is shown at all,
and only the net name is displayed (surrounded by the flag border, if the format
string contains the <tt>%F</tt> placeholder).
<p>
A cross-reference label that is placed on the end of a net wire will connect to
the wire so that the wire is moved with the label, and vice versa.
<p>
The cross-reference label format string is stored within the schematic drawing file.
<p>
A cross-reference label can be changed to a normal label either through the
<a href=#41>CHANGE</a> command or the label's <i>Properties</i> dialog.
<h2>Selecting the layer</h2>
Unlike other commands (like LINE, for instance), the LABEL command keeps track
of its last used layer by itself. This has the advantage of making sure that
labels are always drawn into the right layer, no matter what layers other
commands draw into. The downside of this is that the usual way of setting the layer
in a script, as in
<pre>
LAYER <i>layer</i>;
LINE (1 2) (3 4);
</pre>
doesn't work here. The layer needs to be selected while the LABEL command is
already active, which can be done like this
<pre>
LABEL <i>parameters</i>
LAYER <i>layer</i>
<i>more parameters</i>;
</pre>
Note that the LABEL line is <b>not</b> terminated with a <tt>';'</tt>, and
that the LAYER command starts on a new line.<br>
The commands
<pre>
LABEL
LAYER <i>layer</i>;
</pre>
set the layer to use with subsequent LABEL commands.


<a name=69>
<h1>VPROBE</h1>
<dl>
    <dt>
        <b>Function</b>
    <dd>
        Attaches voltage probe to buses and nets.
    <dt>
        <b>Syntax</b>
    <dd>
        <tt>VPROBE ..</tt>
</dl>
<b>See also</b> <a href=#85>NET</a>,
<b>See also</b> <a href=#39>BUS</a>
<p>
    Voltage probes allow the user to view node voltages in simulation results.
    Command available as context-menu item on nets in schematic, as well as via command-line and via a toolbar command button.


<a name=70>
<h1>VPPROBE</h1>
<dl>
    <dt>
        <b>Function</b>
    <dd>
        Attaches voltage phase probe to buses and nets.
    <dt>
        <b>Syntax</b>
    <dd>
        <tt>VPPROBE</tt>
</dl>
<b>See also</b> <a href=#85>NET</a>,
<b>See also</b> <a href=#39>BUS</a>
<p>
    Voltage phase probes allow the user to view the phase of node voltages in AC simulation results.
    Command available as context-menu item on nets in schematic, as well as via command-line and via a toolbar command button.


<a name=71>
<h1>LAUNCH</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Launch web-based 3d package generator and search.
<dt>
<b>Syntax</b>
<dd>
<tt>LAUNCH PACKAGE3D-GENERATOR</tt><br>
<tt>LAUNCH PACKAGE3D-WEB-SEARCH</tt><br>
</dl>
<b>See also</b>
<a href=#88>PACKAGE</a>,
<a href=#47>COPY</a>
<p>
    This command is used to launch the web-based 3d package generator and search.
    It can be used in the device editor, to create a new device variant (the same as the <a href=#88>PACKAGE</a> command),
    as well in the library editor, to import a package to a library (the same as the <a href=#47>COPY</a> command).


<a name=72>
<h1>LAYER</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Changes and defines layers.
<dt>
<b>Syntax</b>
<dd>
<tt>LAYER layer_number</tt><br>
<tt>LAYER layer_name</tt><br>
<tt>LAYER layer_number layer_name</tt><br>
<tt>LAYER [??] -layer_number</tt>
</dl>
<b>See also</b> <a href=#52>DISPLAY</a>
<h2>Choose Drawing Layer</h2>
The LAYER command with one parameter is used to change the current
layer, i.e. the layer onto which wires, circles etc. will be drawn.
If LAYER is selected from the menu, a popup menu will appear in which
you may change to the desired layer. If entered from the command line,
'layer_number' may be the number of any valid layer, and 'layer_name'
may be the name of a layer as displayed in the popup menu.
<p>
Certain layers are not available in all modes.
<p>
Please note that only those signal layers (1 through 16) are available
that have been entered into the layer setup in the <a href=#168>Design Rules</a>.
<h2>Define Layers</h2>
The LAYER command with two parameters is used to define a new layer
or to rename an existing one.
If you type in at the command prompt e.g.
<pre>
LAYER 101 SAMPLE;
</pre>
you define a new layer with layer number 101 and layer name SAMPLE.
<p>
If a footprint contains layers not yet specified in the board, these
layers are added to the board as soon as you place the package into
the board (ADD or REPLACE).
<p>
The predefined layers have a special function.
You can change their names, but their functions (related with their
number) remain the same.
<p>
If you define your own layers, you should use only numbers
greater than 100. Numbers below may be assigned for special purposes
in later EAGLE versions.
<h3>Top/bottom Pairs</h3>
Top/bottom pairs of layers have the property of mirroring upon each other
using the MIRROR command (see "Predefined EAGLE Layers" below). Besides using the
predefined layers tTest/bTest for custom purpose it's also possible to define
a custom pair like
<pre>
LAYER 53 tSomething;
LAYER 54 bSomething;
</pre>
This is supported for the layer pairs 53/54, 55/56, 57/58 and 59/60.
It should be used with care regarding later EAGLE versions.
<h2>Delete Layers</h2>
The LAYER command with the minus sign and a layer_number deletes the
layer with the specified number, e.g.
<pre>
LAYER -103;
</pre>
deletes the layer number 103. Layers to be deleted must be empty.
If this is not the case, the program generates the error message
<p>
"layer is not empty: #"
<p>
where "#" represents the layer number.
If you want to avoid any error messages in a layer delete operation
you can use the '??' option. This may be
useful in scripts that try to delete certain layers, but don't consider
it an error if any of these layers is not empty or not present at all.
<h2>Predefined EAGLE Layers</h2>
<h3>Layout</h3>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>1   Top       </td><td width=20><td>Tracks, top side</td></tr>
<tr><td>2   Route2    </td><td width=20><td>Inner layer</td></tr>
<tr><td>3   Route3    </td><td width=20><td>Inner layer</td></tr>
<tr><td>4   Route4    </td><td width=20><td>Inner layer</td></tr>
<tr><td>5   Route5    </td><td width=20><td>Inner layer</td></tr>
<tr><td>6   Route6    </td><td width=20><td>Inner layer</td></tr>
<tr><td>7   Route7    </td><td width=20><td>Inner layer</td></tr>
<tr><td>8   Route8    </td><td width=20><td>Inner layer</td></tr>
<tr><td>9   Route9    </td><td width=20><td>Inner layer</td></tr>
<tr><td>10  Route10   </td><td width=20><td>Inner layer</td></tr>
<tr><td>11  Route11   </td><td width=20><td>Inner layer</td></tr>
<tr><td>12  Route12   </td><td width=20><td>Inner layer</td></tr>
<tr><td>13  Route13   </td><td width=20><td>Inner layer</td></tr>
<tr><td>14  Route14   </td><td width=20><td>Inner layer</td></tr>
<tr><td>15  Route15   </td><td width=20><td>Inner layer</td></tr>
<tr><td>16  Bottom    </td><td width=20><td>Tracks, bottom side</td></tr>
<tr><td>17  Pads      </td><td width=20><td>Pads (through-hole)</td></tr>
<tr><td>18  Vias      </td><td width=20><td>Vias (through-hole)</td></tr>
<tr><td>19  Unrouted  </td><td width=20><td>Airwires (rubberbands)</td></tr>
<tr><td>20  Dimension </td><td width=20><td>Board outlines (circles for holes)</td></tr>
<tr><td>21  tPlace    </td><td width=20><td>Silk screen, top side</td></tr>
<tr><td>22  bPlace    </td><td width=20><td>Silk screen, bottom side</td></tr>
<tr><td>23  tOrigins  </td><td width=20><td>Origins, top side</td></tr>
<tr><td>24  bOrigins  </td><td width=20><td>Origins, bottom side</td></tr>
<tr><td>25  tNames    </td><td width=20><td>Service print, top side</td></tr>
<tr><td>26  bNames    </td><td width=20><td>Service print, bottom side</td></tr>
<tr><td>27  tValues   </td><td width=20><td>Component VALUE, top side</td></tr>
<tr><td>28  bValues   </td><td width=20><td>Component VALUE, bottom side</td></tr>
<tr><td>29  tStop     </td><td width=20><td>Solder stop mask, top side</td></tr>
<tr><td>30  bStop     </td><td width=20><td>Solder stop mask, bottom side</td></tr>
<tr><td>31  tCream    </td><td width=20><td>Solder cream, top side</td></tr>
<tr><td>32  bCream    </td><td width=20><td>Solder cream, bottom side</td></tr>
<tr><td>33  tFinish   </td><td width=20><td>Finish, top side</td></tr>
<tr><td>34  bFinish   </td><td width=20><td>Finish, bottom side</td></tr>
<tr><td>35  tGlue     </td><td width=20><td>Glue mask, top side</td></tr>
<tr><td>36  bGlue     </td><td width=20><td>Glue mask, bottom side</td></tr>
<tr><td>37  tTest     </td><td width=20><td>Test and adjustment inf., top side</td></tr>
<tr><td>38  bTest     </td><td width=20><td>Test and adjustment inf. bottom side</td></tr>
<tr><td>39  tKeepout  </td><td width=20><td>Nogo areas for components, top side</td></tr>
<tr><td>40  bKeepout  </td><td width=20><td>Nogo areas for components, bottom side</td></tr>
<tr><td>41  tRestrict </td><td width=20><td>Nogo areas for tracks, top side</td></tr>
<tr><td>42  bRestrict </td><td width=20><td>Nogo areas for tracks, bottom side</td></tr>
<tr><td>43  vRestrict </td><td width=20><td>Nogo areas for via-holes</td></tr>
<tr><td>44  Drills    </td><td width=20><td>Conducting through-holes</td></tr>
<tr><td>45  Holes     </td><td width=20><td>Non-conducting holes</td></tr>
<tr><td>46  Milling   </td><td width=20><td>Milling</td></tr>
<tr><td>47  Measures  </td><td width=20><td>Measures</td></tr>
<tr><td>48  Document  </td><td width=20><td>General documentation</td></tr>
<tr><td>49  Reference </td><td width=20><td>Reference marks</td></tr>
<tr><td>51  tDocu     </td><td width=20><td>Part documentation, top side</td></tr>
<tr><td>52  bDocu     </td><td width=20><td>Part documentation, bottom side</td></tr>
</table>
<h3>Schematic</h3>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>91  Nets      </td><td width=20><td>Nets</td></tr>
<tr><td>92  Busses    </td><td width=20><td>Buses</td></tr>
<tr><td>93  Pins      </td><td width=20><td>Connection points for component symbols</td></tr>
<tr><td>              </td><td width=20><td>with additional information</td></tr>
<tr><td>94  Symbols   </td><td width=20><td>Shapes of component symbols</td></tr>
<tr><td>95  Names     </td><td width=20><td>Names of component symbols</td></tr>
<tr><td>96  Values    </td><td width=20><td>Values/component types</td></tr>
<tr><td>97  Info      </td><td width=20><td>General information</td></tr>
<tr><td>98  Guide     </td><td width=20><td>Guide lines</td></tr>
<tr><td>100 SimOp     </td><td width=20><td>Operating Point Sim Results </td></tr>
<tr><td>101 SimProbes </td><td width=20><td>Simulation Result Probes</td></tr>
</table>
<h2>Layer Groups</h2>
There are two types of layer groups in EAGLE: preset layer groups, and
user-defined layer groups. They are available for both schematic and board
editor modes, but will not overlap between the two.
<p>
Preset groups are predefined in eagle.scr, and can be edited, renamed, and
removed from that location only, not from within the EAGLE editor.
<p>
User-defined layer groups have already existed in EAGLE for some time
but we have added them to the layer display dialog popup menu.
<p>
To add a new layer set, first select the layer you want to include in the group,
then press the ADD NEW button. Enter the name of your layer set, press the OK
button, and you are done. You may have up to 9 presets for both the schematic
and board editors.
<p>
Be careful with naming your layer presets, they may interfere with your expected
behavior of the DISPLAY command. For example, if you name a layer preset 'top',
it will override the normal action of DISPLAY (which would be to show the top
layer only), and instead display the set of layers in your layer preset.
<p>
To remove a user-defined layer group, select the group you wish to delete
from the drop-down menu, then press the REMOVE button.


<a name=73>
<h1>LINE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds lines to a drawing.
<dt>
<b>Syntax</b>
<dd>
<tt>LINE ['signal_name'] [width] &#149; &#149;..</tt><br>
<tt>LINE ['signal_name'] [width] [ROUND | FLAT] &#149; [curve | @radius] &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.<br>
<mb>Right</mb> changes the bend style (see <a href=#116>SET Wire_Bend</a>).<br>
<mb>Shift+Right</mb> reverses the direction of switching bend styles.<br>
<mb>Ctrl+Left</mb> when starting a line snaps it to the next existing line end point.<br>
<mb>Ctrl+Right</mb> toggles between corresponding bend styles.<br>
<mb>Ctrl+Left</mb> when placing a line end point defines arc radius.
</dl>
<b>See also</b> <a href=#81>MITER</a>,
<a href=#118>SIGNAL</a>,
<a href=#113>ROUTE</a>,
<a href=#41>CHANGE</a>,
<a href=#85>NET</a>,
<a href=#39>BUS</a>,
<a href=#49>DELETE</a>,
<a href=#111>RIPUP</a>,
<a href=#34>ARC</a>
<p>
The LINE command is used to add lines (tracks) to a drawing. The line
begins at the first point specified and runs to the second. Additional
points draw additional line segments. Two mouse clicks at the same
position finish the line and a new one can be started at the position
of the next mouse click.
<p>
Depending on the currently active bend style, one or two line segments will
be drawn between every two points. The bend style defines the angle
between the segments and can be changed with the right mouse button (holding
the Shift key down while clicking the right mouse button reverses the direction
in which the bend styles are gone through, and the Ctrl key makes it toggle
between corresponding bend styles).
<p>
Pressing the center mouse button brings up a popup menu from which you
may select the layer into which the line will be drawn.
<p>
The special keywords <tt>ROUND</tt> and <tt>FLAT</tt>, as well as the <i>curve</i>
parameter, can be used to draw an arc (see below).
<p>
Starting a LINE with the Ctrl key pressed snaps the starting point
of the new line to the coordinates of the closest existing line. This
is especially useful if the existing line is off grid. It also adjusts
the current width, layer and style to those of the existing line.
If the current bend style is 7 ("Freehand"), the new line will form a
smooth continuation of the existing line.
<h2>Signal name</h2>
Although it's possible to create wires for nets, busses or signals with the LINE command
(depending on the current layer), it's not recommended to do so.
It's better to use <a href=#85>NET</a>,
<a href=#85>BUS</a> or <a href=#118>SIGNAL</a> instead.
<p>
The <tt>signal_name</tt> parameter is intended mainly to be used in
script files that read in generated data. If a <tt>signal_name</tt>
is given, all subsequent lines will be added as wires to that signal and no
automatic checks will be performed.<br>
<b>This feature should be used with great care because it could result
in short circuits, if a wire is placed in a way that it would connect
different signals. Please run a
<a href=#53>Design Rule Check</a> after using the LINE command
with the <tt>signal_name</tt> parameter for signals!</b>
<h2>Line versus Wire</h2>
Wires are distinguished from lines ("plain wires") because of their "electrical"
meaning as part of a signal, net or bus. For historical reasons, wire is widely
used for both in EAGLE help.
<h2>Line Width (wire width)</h2>
Entering a number after activating the LINE command changes the width
of the line (in the present unit) which can be up to 200 mm (7.8740 inch).
<p>
The line width can be changed with the command
<pre>
CHANGE WIDTH width &#149;
</pre>
at any time.
<h2>Line Style (wire style)</h2>
Lines can have one of the following <i>styles</i>:
<ul>
<li>Continuous
<li>LongDash
<li>ShortDash
<li>DashDot
</ul>
The line style can be changed with the <a href=#41>CHANGE</a> command.
<p>
Note that the DRC and Autorouter will always treat lines as "Continuous",
even if their style is different. Line styles are mainly for electrical
and mechanical drawings and should not be used on signal layers. It is
an explicit DRC error to use a non-continuous line as part of a signal
that is connected to any pad.
<h2>Signals in Top, Bottom, and Route Layers</h2>
Lines in the layers Top, Bottom, and ROUTE2...15
are treated as signals. If you draw a line in either of these layers
starting from an existing signal, then all of the segments of this line
belong to that signal (only if the center of the line is placed exactly onto
the center of the existing signal wire or pad). If you finish this drawing operation with a
line segment connected to a different signal, then EAGLE will ask
you if you want to connect the two signals.
<p>
Note that EAGLE treats each line segment as a single object
(e.g. when deleting a line).
<p>
When the LINE command is active the center mouse button
can be used to change the layer on which the line is drawn.
<h2>Drawing Arcs</h2>
Lines and arcs are basically the same objects, so you can draw an arc either by
using the <a href=#34>ARC</a> command, or by adding the necessary parameters
to the LINE command. To make a line an arc it needs either the <i>curve</i> parameter, which
defines the "curvature" of the arc, or the <i>@radius</i> parameter, which defines
the radius of the arc (note the <tt>'@'</tt>, which is necessary to be able to tell
apart <i>curve</i> and <i>radius</i>).
<p>
The valid range for <i>curve</i> is <tt>]-360</tt>..<tt>+360[</tt> (without the limits +-360),
and its value means what
part of a full circle the arc consists of. A value of <tt>90</tt>, for instance,
would result in a <tt>90&deg;</tt> arc, while <tt>180</tt> would give you a semicircle.
Full circles cannot be created this way (for this use the <a href=#43>CIRCLE</a> command).
Positive values for <i>curve</i> mean that the arc is drawn in a mathematically positive sense
(i.e. counterclockwise). If <i>curve</i> is <tt>0</tt>, the arc is straight
("no curvature"), which is actually a line. Note that in order to distinguish the
<i>curve</i> parameter from the <i>width</i> parameter, it always has to be given with
a sign (<tt>'+'</tt> or <tt>'-'</tt>), even if it is a positive value.<br>
<p>
As an example, the command
<pre>
LINE (0 0) +180 (0 10);
</pre>
would draw a semicircle from the point (0 0) to (0 10), in counterclockwise
direction.
<p>
If a <i>radius</i> is given, the arc will have that radius. Just like the <i>curve</i>
parameter, <i>radius</i> also must have a sign in order to determine the arcs
orientation.
For example, the command
<pre>
LINE (0 0) @+100 (0 200);
</pre>
would draw a semicircle from the point (0 0) to (0 200) (with a radius of 100),
in counterclockwise direction. Note that if the end point is more than twice the
radius away from the start point, a straight line will be drawn.
<p>
The arc radius can also be defined by placing the line end point with the <tt>Ctrl</tt>
key pressed (typically at the center of the circle on which the arc shall lie).
In that case the point is not taken as an actual end point, but is rather
used to set the radius of an arc. You can then move the cursor around and place an
arc with the given radius (the right mouse button together with <tt>Ctrl</tt> will
toggle the arc's orientation). If you move the cursor more than twice the radius
away from the start point, a straight line will be drawn.
<p>
In order to be able to draw any arc with the LINE command (which is especially important
for generated script files), the keywords <tt>ROUND</tt> and <tt>FLAT</tt> are also
allowed in the LINE command. Note, though, that these apply only to actual arcs
(straight lines always have round endings). By default, arcs created with the LINE
command have round endings.


<a name=74>
<h1>LOCK</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Locks the position and orientation of a part in the board.
<dt>
<b>Syntax</b>
<dd>
<tt>LOCK &#149;..</tt><br>
<tt>LOCK name ..</tt>
<tt>LOCK -</tt>
<tt>LOCK *;</tt>
<tt>LOCK -*;</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Right</mb> applies the command to the group.<br>
<mb>Shift+Left</mb> reverses the lock operation ("unlocks" the object).<br>
<mb>Ctrl+Shift+Right</mb> "unlocks" all objects in the group that have the lock property.
</dl>
<b>See also</b> <a href=#83>MIRROR</a>,
<a href=#83>MOVE</a>,
<a href=#112>ROTATE</a>
<a href=#122>REPOSITION</a>
<p>
The LOCK command can be applied to parts, wires, vias, polygons, and holes in a
board, and prevents them from being moved, rotated, or mirrored. This is useful
for things like connectors, which need to be mounted at a particular location and
must not be inadvertently moved.
<p>
The origin of a locked part is displayed as an 'x' to have a visual
indication that the part is locked. For locked wires and vias a padlock symbol
is shown on the object to show the locked state.
<p>
If a group is moved and it contains locked objects, these objects will not move
with the group.
<p>
Detached texts of a locked part can still be moved individually, but
they won't move with a group.
<p>
Parts can also be selected by their name,
which is especially useful if the object is outside the currently shown
window area.
<p>
A "locked" object can be "unlocked" by clicking on it with the
<tt>Shift</tt> key pressed while the LOCK command is active.
<p>


<a name=75>
<h1>MAPTOMODEL</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Map a device to its spice subcircuit model or spice model card.
<dt>
<b>Syntax</b>
<dd>
<tt>MAPTOMODEL name ..</tt>
<dt>
</dl>
<b>See also</b> <a href=#120>SIM</a>,
<a href=#57>EXPORT</a>,
<a href=#32>ADDMODEL</a>
<p>
    The MAPTOMODEL command opens a dialog where you can map a part to a specific spice subcircuit model, spice model card,
    or intrinsic spice model.  If the device is not already a spice-compatible device, then the
    <a href=#32>ADDMODEL</a> command is initiated in the
    background first.  MAPTOMODEL shows a dialog where the user can set the model to use, and
    also map the pins from the part to the model inputs.  Note that if a gate is selected, the spice model
    is attached and mapped considering all gates in the device set, and it applies to all gates.
    Command available as context-menu item on nets in schematic, as well as via command-line and via a toolbar command button.


<a name=76>
<h1>MANUFACTURING</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Toggles the manufacturing dialog.
<dt>
<b>Syntax</b>
<dd>
<tt>MANUFACTURING;</tt><br>
<tt>MANUFACTURING EXPORT;</tt><br>
<tt>MANUFACTURING CAM;</tt><br>
<dt>
</dl>
<p>
The MANUFACTURING command provides access to the manufacturing flyout and the CAM exporter.
MANUFACTURING (without parameters) toggles the manufacturing flyout window in the board editor.
The manufacturing flyout provides manufacturing information about the board such as
dimensions, drillmaps, additional views...
MANUFACTURING CAM opens the CAM dialog and MANUFACTURING EXPORT creates a ZIP archive
with Gerber and Excellon data based on the current design.
These commands are only available in the board editor.


<a name=77>
<h1>MARK</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a mark on the drawing area.
<dt>
<b>Syntax</b>
<dd>
<tt>MARK &#149;</tt><br>
<tt>MARK;</tt>
</dl>
<b>See also</b> <a href=#61>GRID</a>
<p>
The MARK command allows you to define a point
on the drawing area and display the coordinates of the mouse cursor relative
to that point at the upper left corner of the screen (with a leading
'R' character). This command is useful especially when board dimensions
or cutouts are to be defined. Entering MARK; turns the mark
on or off.
<p>
Please choose a grid fine enough before using the MARK command.


<a name=78>
<h1>MEANDER</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Balance lengths of differential pairs and increase the length of a signal segment.
<dt>
<b>Syntax</b>
<dd>
<tt>MEANDER [length] &#149; ..</tt><br>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Left</mb> measures the length of the selected signal segment.<br>
<mb>Ctrl+Shift+Left</mb> measures the maximum length of the selected signal segments.<br>
<mb>Right</mb> toggles between symmetrical and asymmetrical meanders.
</dl>
<b>See also</b> <a href=#113>ROUTE</a>
<p>
The MEANDER command can be used to balance the lengths of signals forming
a differential pair.
To do this, just click on a wire of a differential pair and move the mouse cursor
away from the selection point. If there is a difference in the length of the two
signals, and the current mouse position is far enough away from the selection point,
a "meander" shaped sequence of wires will be drawn that increases the
length of the shorter signal segment.
An indicator attached to the mouse cursor shows the target length (which is the
length of the longer signal segment), as well as the deviation (in percent) of the
two signals from the target length.
<p>
The meander starts at the first click point and extends to the second point the
mouse is moved to. The maximum (perpendicular) size of the meander is defined by
the distance of the mouse to the meandered wire.
<p>
If a single meander isn't enough to balance the lengths, you can add further
meanders at different locations.
<p>
At any time you can enter a value in the command line to set the target <tt>length</tt>.
This can be used for all signals, not just for differential pairs.
<p>
When meandering a differential pair with a given target length, the meander first
tries to balance the length of the two signal segments that form the differential
pair, and then increases the total length of both segments.
<p>
To reset the target length you can either restart the MEANDER command or enter a
value of <tt>0</tt> in the command line.
<h2>Measuring signal lengths</h2>
If you click on a signal wire with the <tt>Ctrl</tt> key pressed, the length of that
signal segment will be measured and displayed on the screen in a little indicator
near the mouse position. You can use this to measure the length of a given signal
segment and use that as the target length for meandering an other segment.
<p>
If you do the measuring with <tt>Ctrl+Shift</tt> pressed, the maximum length of this
or any previously selected segments will be taken. This can be used to easily determine
the maximum length of several bus signals and then meandering each of them to that length.
<h2>Symmetrical and asymmetrical meanders</h2>
By default a meander is generated symmetrical, which means it extends to both sides
along the selected wire. If this is not what you need (either because there is only
space on one side, or because the longer one of the wires of a differential pair shall
not be elongated) you can switch to asymmetric mode by clicking the right mouse button.
The actual mouse position will decide which side of the wire the meander extends to.
Move the mouse around to find the proper position.
<h2>Length tolerance</h2>
The value defined in the Design Rules under
"Misc/Max. length difference in differential pairs" is used to select the color
when displaying the length deviations while drawing a meander. If the percentage
is shown in green, the respective segment lies within the given tolerance. Otherwise
the percentage is displayed in red. The default for this parameter is 10mm.


<a name=79>
<h1>MENU</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Customizes the textual command menu.
<dt>
<b>Syntax</b>
<dd>
<tt>MENU option ..;</tt><br>
<tt>MENU;</tt>
</dl>
<b>See also</b> <a href=#35>ASSIGN</a>,
<a href=#115>SCRIPT</a>
<p>
The MENU command can be used to create a user specific command menu.
<p>
The complete syntax specification for the <tt>option</tt> parameters is
<pre>
option    := command | submenu | delimiter
command   := [ icon ] text1 [ ':' text2 ]
submenu   := [ icon ] text '{' option [ '|' option ] '}'
icon      := '[' filename ']'
delimiter := '---'
</pre>
A menu option can be a simple command, as in
<pre>
MENU Display Grid;
</pre>
which would set the menu to the commands <tt>Display</tt> and <tt>Grid</tt>.
<tt>Display</tt> and <tt>Grid</tt> are interpreted both as menu text and as commands.
<br>It can be an aliased command, as in
<pre>
MENU 'MyDisp : Display None Top Bottom Pads Vias;' 'MyGrid : Grid mil 100 lines on;';
</pre>
which would set the menu to show the command aliases <tt>MyDisp</tt> and <tt>MyGrid</tt>
and actually execute the command sequence behind the <tt>':'</tt> of each option (<tt>text2</tt>, see above) when the respective button is clicked.<br>
It can also be a submenu button as in
<pre>
MENU 'Grid { Fine : Grid inch 0.001; | Coarse : Grid inch 0.1; }';
</pre>
which would define a button labeled <tt>Grid</tt> that, when clicked opens a
submenu with the two options <tt>Fine</tt> and <tt>Coarse</tt>.<br>
Character <tt>'|'</tt> is only necessary as a separator in submenu entries
(<tt>submenu</tt>, see above).
<p>
The special option <tt>'---'</tt> can be used to insert a delimiter, which
may be useful for grouping buttons.
<p>
A command button can display an icon by preceding the button text with the
file name of an icon, enclosed in square brackets, as in
<pre>
MENU '[/path/to/myicon.png] Set a fine grid : Grid inch 0.001;';
</pre>
Here the button will display only the given icon, and "Set a fine grid" will
be used as a "tool tip" that gets displayed when the mouse cursor is moved
over the button. The filename needs not be enquoted additionally
(like for masking spaces).<br>
If an icon is used in a popup menu, like
<pre>
MENU 'Grid { [/path/to/myicon.png] Set a fine grid : Grid inch 0.001; }';
</pre>
then both the icon and the text will be displayed, as with any other popup menu.<br>
If the icon's file name doesn't include a directory path, it is searched for
in the current working directory and in the EAGLE 'bin' directory.
<p>
Note that any <i>option</i> that consists of more than a single word, or that
might be interpreted as a command, must be enclosed in single quotes.
If you want to use the MENU command in a script to define a complex menu,
and would like to spread the menu definitions over several lines to make
them more readable, you need to end the lines with a backslash character (<tt>'\'</tt>)
as in
<pre>
MENU 'Grid {\
             Fine : Grid inch 0.001; |\
             Coarse : Grid inch 0.1;\
           }';
</pre>
<h2>Examples</h2>
<pre>
MENU Move Delete Rotate Route ';' Edit;
</pre>
would create a command menu that contains the commands Move...Route,
the semicolon, and the Edit command.
<p>
The command
<pre>
MENU;
</pre>
switches back to the default menu.
Note that the ';' entry should always be added
to the menu. It is used to terminate many commands.
<p>
Complex example:
<p>
<pre>
MENU '[draw.png] Draw {\
                        Wire {\
                               Continous : CHANGE STYLE Continuous; LINE |\
                               DashDot :  CHANGE STYLE DashDot; LINE |\
                               Help : HELP LINE;\
                             }|\
                        Rectangle {\
                                    RECT |\
                                    Help : HELP RECT; \
                                  }\
                       }\
      [export.png] Export {\
                            Script : EXPORT SCRIPT |\
                            Image : EXPORT IMAGE\
                          }\
      MyScript : SCRIPT MyScript.scr;';
</pre>
This menu consists of the 3 entries Draw, Export and MyScript, whereat Draw and Export
have submenus and are supplied with icons. Draw consists of the submenus Wire and
Rectangle, whereat Wire consists of the entries Continous, DashDot and Help and Rectangle
consists of the entries RECT (text and command RECT) and Help. <br>
The submenu of Export has the entries Script and Image.


<a name=80>
<h1>MIRROR</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Mirrors objects and groups.
<dt>
<b>Syntax</b>
<dd>
<tt>MIRROR &#149;..</tt><br>
<tt>MIRROR name..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Right</mb> mirrors the group.
</dl>
<b>See also</b> <a href=#112>ROTATE</a>,
<a href=#74>LOCK</a>,
<a href=#131>TEXT</a>
<p>
Using the MIRROR command, objects may be mirrored about the y axis.
One application for this command is to mirror components to be placed
on the reverse side of the board.
<p>
Parts, pads, smds and pins can also be selected by their name,
which is especially useful if the object is outside the currently shown
window area.
<p>
Attributes of parts can be selected by entering the concatenation of
part name and attribute name, as in <tt>R5&gt;VALUE</tt>.
<p>
Components can be mirrored only if the appropriate tOrigins/bOrigins
layer is visible.
<p>
When footprints are selected for use with the MIRROR
command, connected wires on the outer layers are mirrored, too (beware of short
circuits!).
<p>
Note that any objects on inner layers (2...15) don't change their layer
when they are mirrored. The same applies to vias.
<p>
Parts cannot be mirrored if they are <a href=#74>locked</a>,
or if any of their connected pads would extend outside the allowed area
(in case you are using a <a href=#409>limited edition</a> of EAGLE).
<h2>Mirror a Group</h2>
In order to mirror a group of elements, the group is first defined
with the GROUP command and polygon in the usual manner. The MIRROR
command is then selected and the right mouse button is used to execute
the change. The group will be mirrored about the vertical axis through
the next grid point.
<p>
Wires, circles, pads and polygons may not be individually
mirrored unless included in a group.
<h2>Mirror Texts</h2>
Text on the solder side of a pc board (Bottom and bPlace layers) is
mirrored automatically so that it is readable when you look at the
solder side of the board.
<p>
Mirrored text in a schematic will be printed on the other side of its origin point,
but it will still remain normally readable.


<a name=81>
<h1>MITER</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Miters wire joints.
<dt>
<b>Syntax</b>
<dd>
<tt>MITER [radius] &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Left&amp;Drag</mb> dynamically modifies the miter.<br>
<mb>Right</mb> toggles between round and straight mitering.
</dl>
<b>See also</b> <a href=#127>SPLIT</a>,
<a href=#73>LINE</a>,
<a href=#113>ROUTE</a>,
<a href=#98>POLYGON</a>
<p>
The MITER command can be used to take the edge off a point where two wires join.
The two existing wires need to be on the the same layer and must have the same
width and wire style.
<h2>Mitering a point</h2>
If you select a point where exactly two straight wires join, an additional wire will
be inserted between these two wires, according to the given <i>radius</i>.
If you click&amp;drag on such a point with the left mouse button, you can define
the mitering wire dynamically.
<h2>Mitering a wire</h2>
If you select a wire (which may also be an arc) somewhere in the middle between its
end points, and that wire is connected to exactly two other straight wires (one at each
end), the selected wire will be "re-mitered" according to the given <i>radius</i>.
If you click&amp;drag on such a wire with the left mouse button, you can define
the mitering wire dynamically.
<h2>Straight versus round mitering</h2>
If <i>radius</i> is positive, the inserted wire will be an arc with the given radius;
if it is negative, a straight wire will be inserted (imagine the <tt>'-'</tt> sign as
indicating "straight"). You can toggle between round and straight mitering by pressing
the right mouse button.
<h2>Miter radius and wire bend style</h2>
The <i>radius</i> you give in the MITER command will be used in all other commands
that draw wires in case the wire bend style is one of the 90 or 45 degree styles.
If you have set round mitering, it will apply to both the 90 and 45 degree bend styles;
in case of straight mitering only the 90 degree bend styles are affected.


<a name=82>
<h1>MODULE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Creates a module.
Adds module instances into a sheet.
<dt>
<b>Syntax</b>
<dd>
<tt>MODULE [[width height] 'module_name'] ['prefix*'] [+offset] [orientation] &#149;..</tt><br>
<tt>MODULE [[width height] 'module_name'] ['module_instance_name'] [+offset] [orientation] &#149;..</tt><br>
<tt>MODULE 'variant_name@module_name' ['module_instance_name'] [+offset] [orientation] &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> mirrors the module instance.<br>
<mb>Right</mb> rotates the module instance.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#84>NAME</a>,
<a href=#100>PORT</a>,
<a href=#101>PREFIX</a>
<p>
The MODULE command is used to create modules used in hierarchical schematics
and add module instances into a sheet.
<p>
If <tt>+offset</tt> is given, the current module instance will use this offset
for naming the elements. The value has to be a multiple of 100 (e.g. +100).
Note that this is only supported for module instances in the main schematic
(details see below).
<p>
The <tt>orientation</tt> of the module instance may be defined textually
using the usual definitions as listed in the <a href=#31>ADD</a> command
(R0, R90 etc.).
<p>
The <a href=#100>PORT</a> command is used to add ports to a module.
<p>
A module instance adds the parts and nets of that module to the board.
Net names are composed using the module name and the net name (e.g. 'MODULE1:N$1').
If a net is exported through a <a href=#100>PORT</a>, it could
be overwritten with a net connected to this port.
Part names of a module instance with an offset are generated by adding
this offset (e.g. 'R17' with offset '100' becomes 'R117', details see below).
If no offset is set, part names are composed the same way as net names
(e.g. 'MODULE1:R17').
<p>
In order to choose a specific assembly variant of the module, its name has to
be prepended the module name (e.g. 'V1@ABC').
<h2>Naming, Offset Notation</h2>
If a prefix is given in the module definition, it will be used for the
automatic generation of the module instance name.
For syntactic distinction in the command line, the prefix has to be
followed by an asterisk ('*').
<p>
If neither prefix nor a name for the module instance is given,
the module name will be used as a prefix.
<p>
The module instance names may be modified with the <a href=#84>NAME</a>
command.
<p>
The offset notation for module instances has the advantage of creating shorter names
but it has to be used carefully, because it can lead to naming conflicts for the elements.<br>
Example:
<p>
If you have parts R1-R9 in a module M and
on the schematic main level the part (resp. element) names R201 to R209 are already used,
it's not possible to create a module instance MI of M with offset 200,
because the elements generated would also occupy names R201 to R209.
The same is if there's another module instance with parts R101 to R109 and offset 100.
EAGLE checks and refuses that with an error message in such cases.
It can easily be solved by trying another positive offset or using offset 0 (i.e. composite notation).
<p>
Even if the offset notation works without conflicts it can still be confusing:
in the upper sample if you decide to change to offset 300 but have parts on main level with names
R310, R311 etc., it's difficult to recognize that these parts do NOT belong to MI
but to main level. Because of that it's recommended to make the offsets large enough
to avoid such misunderstandings.
<p>
Depending on what you intend to do, the composite notation using short module instance names
may be the better alternative.
<p>
Also in order to reduce misunderstandings, any offset can only be used once in the
whole schematic. The properties dialog for module instances allows changing the offset
only to those values that are not yet occupied (or to 0).
<h2>Deeper Hierarchies</h2>
Module instances can also be placed into a module sheet. This way a hierarchy of
arbitrary depth can be created.
<p>
Offsets > 0 are not supported for deeper hierarchy levels. <br>
Example:
Instance F0 uses module FILTER with offset 100, instance SUB resides in FILTER and uses
SUBMODULE with offset 0.
For the elements corresponding to the parts for FILTER offset 100 is applied, for the elements
(and also signals) corresponding to SUBMODULE the composite notation is used like a directory path,
the same for nets/signals. For example, the name of the element corresponding to C1 in SUBMODULE
will be M0:SUB:C1.
<i>(Remark: if offsets were allowed for deeper hierarchies as well, there would be even
more possible name conflicts and misunderstandings).</i>
<h2>Size</h2>
The size of a module is set if <tt>width</tt> and <tt>height</tt> are given before
the module name.
<h2>Edit</h2>
The <a href=#83>MOVE</a> command can be used to edit the module symbol.
The border of the module symbol can be selected with <mb>Ctrl+Left</mb> for resizing it.


<a name=83>
<h1>MOVE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Moves objects.
<dt>
<b>Syntax</b>
<dd>
<tt>MOVE &#149; &#149;..</tt><br>
<tt>MOVE name &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Left</mb> selects an object at its origin or modifies it (see note).<br>
<mb>Shift+Left</mb> selects the whole polygon (see note).<br>
<mb>Ctrl+Right</mb> selects the group.<br>
<mb>Left&amp;Drag</mb> immediately moves the object.<br>
<mb>Ctrl+Right&amp;Drag</mb> immediately moves the group.<br>
<mb>Center</mb> mirrors the selected object or the group.<br>
<mb>Right</mb> rotates the selected object or the group.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#62>GROUP</a>,
<a href=#74>LOCK</a>,
<a href=#104>RATSNEST</a>
<p>
The MOVE command is used to move objects.
<p>
Parts, pads, smds, pins and gates can also be selected by their name,
which is especially useful if the object is outside the currently shown
window area. Note that when selecting a multi-gate part in a schematic by name,
you will need to enter the full instance name, consisting of part
and gate name.
<p>
Attributes of parts can be selected by entering the concatenation of
part name and attribute name, as in <tt>R5&gt;VALUE</tt>.
<p>
Elements can be moved only if the appropriate tOrigins/bOrigins
layer is visible.
<p>
The MOVE command has no effect on layers that are not
visible (refer to DISPLAY).
<p>
The ends of wires (tracks) that are connected to an element cannot
be moved at this point.
<p>
When moving elements, connected wires (tracks) that belong to a signal
are moved too (beware of short circuits!).
<p>
If an object is selected with the left mouse button and the button is
not released, the object can be moved immediately ("click&amp;drag").
The same applies to groups when using the right mouse button.
In this mode, however, it is not possible to rotate or mirror the object
while moving it.
<p>
Parts cannot be moved if they are <a href=#74>locked</a>,
or if any of their connected pads would extend outside the allowed area
(in case you are using a <a href=#409>limited edition</a> of EAGLE).
<p>
There are 3 different modes the MOVE command utilizes:
<ul>
    <li>Preserve Angles</li>
    <li>Free</li>
    <li>Disconnect</li>
</ul>
<p><b>Preserve Angles</b> mode will try to maintain the original angles when moving wires or objects connected to wires. When holding <tt>Ctrl</tt> wires that are not orthgonal will be snapped to grid.</p
<p><b>Free</b> mode will not try to maintain the angles and just move the selection following the mouse.</p>
<p><b>Disconnect</b> mode will disconnect the selected objects from their connections (pads, vias, wires, ...). This can be useful to re-route a subcircuit or aelement without disrupting the circuit that is already in place.<p>
<h2>Move Wires</h2>
If, following a MOVE command, two wires from different
signals are shorted together, they are maintained as separate signals
and the error will be flagged by the DRC command.
<h2>Move Groups</h2>
In order to move a group, the selected objects are defined in the
normal way (GROUP command and polygon) before selecting the MOVE command
and clicking the group with the right mouse button. The entire group
can now be moved and rotated with the right mouse button.
<h2>Move Polygons</h2>
If you select a polygon <i>wire</i> with <tt>Shift</tt> pressed, the polygon
can be moved as a whole.
<h2>Hints for Schematics</h2>
If a supply pin (Direction Sup) is placed on a net, the pin name is
allocated to this net.
<p>
Pins or ports placed on each other are connected together.
<p>
If unconnected pins of an element are placed on nets or pins then
they are connected with them.
<p>
If nets are moved over pins they are not connected with them.
<h2>Selecting objects at their origin</h2>
Normally a selected object remains within the grid it has been originally
placed on. If you press <tt>Ctrl</tt> while selecting an object, the point
where you have selected the object is pulled towards the cursor and snapped into
the current grid.
<p>
If you select a <i>wire</i> somewhere in the middle (not at one of its end points)
with <tt>Ctrl</tt> pressed, the end points stay fixed and you can bend the wire,
which changes it into an arc. The same way the curvature of an arc (which is basically
a wire) can be modified.
<p>
If you select a <i>rectangle</i> at one of its corners with <tt>Ctrl</tt> pressed,
you can resize both the rectangle's width and height. Selecting an edge of the
rectangle with <tt>Ctrl</tt> pressed lets you resize the rectangle's width or height,
respectively. Selecting the rectangle at its center with <tt>Ctrl</tt> pressed
pulls it towards the cursor and snaps it into the current grid.
<p>
If you select a <i>circle</i> at its circumference with <tt>Ctrl</tt> pressed, the
center stays fixed and you can resize the circle's diameter. Selecting the center point
this way pulls it towards the cursor and snaps it into the current grid.
<p>
If you select a <i>port</i> with <tt>Ctrl</tt> pressed, only the port is moved.
Of course this port moving takes affect on all instances of this module.
<h2>Move part of a sheet to an other sheet</h2>
You can move part of a sheet to an other sheet of the same schematic without
affecting the board (in case <a href=#406>Forward&amp;Back Annotation</a>
is active) by defining a <a href=#62>GROUP</a> that contains the objects
you want to move, selecting that group with the MOVE command and then switching to
the desired sheet, with the MOVE command still active and having the group attached
to the cursor. In the new sheet the MOVE command will be active again and will have
the previously defined group attached to the cursor. Now place the group as usual,
and all the affected objects will be transferred from the original sheet to the
current sheet. If the current sheet is the same as the original sheet, nothing
happens.
<p>
Note that only wires that have both ends in the group will be transferred, and
any part that is transferred takes all its electrical connections with it, even if
a net wire attached to one of its pins is not transferred because its other end
is not in the group.
In case a pin in the new sheet has an electrical connection, but no other pin,
wire or junction attached to it to make this visible, a junction will be
automatically generated at this point.
<p>
This process can even be scripted. For instance
<pre>
edit .s1
group (1 1) (1 2) (2 2) (2 1) (1 1)
move (&gt; 0 0)
edit .s2
(0 0)
</pre>
would switch to the first sheet, define a group, select that group with MOVE,
switch to the second sheet and place the group. Note the final <tt>(0 0)</tt>,
which are coordinates to the implicitly invoked MOVE command.
<p>
See the <a href=#54>EDIT</a> command if you want to just reorder the
sheets.
<h2>Click & Drag</h2>
You can MOVE objects by simply click and drag on any object already in the current group with
<a href=#165>Group Default On</a> options enabled.


<a name=84>
<h1>NAME</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Displays and changes names.
<dt>
<b>Syntax</b>
<dd>
<tt>NAME &#149;..</tt><br>
<tt>NAME new_name &#149;</tt><br>
<tt>NAME old_name new_name</tt>
</dl>
<b>See also</b> <a href=#68>LABEL</a>,
<a href=#117>SHOW</a>,
<a href=#122>REPOSITION</a>,
<a href=#136>VALUE</a>
<p>
The NAME command is used to display or edit the name of the selected object.
<p>
Parts, elements, pads, smds, pins and gates can also be selected by their name,
which is especially useful if the object is outside the currently shown
window area. Other object types (e.g. nets, busses, signals) have to be clicked first.
<h2>Library</h2>
When in library edit mode, the NAME command is used to display or
edit the name of the selected pad, smd, pin or gate.
<h2>Automatic Naming</h2>
EAGLE generates names automatically: N$.. for nets, E$.. for elements, S$.. for signals,
P$.. for pads, pins and smds. In general, it is convenient to substitute
commonly used names (e.g. 1...14 for a 14-pin dual inline package)
in place of these automatically generated names.
Automatic naming of parts can be controlled with <a href=#101>PREFIX</a>.
<h2>Name Rules</h2>
Letters for eagle object names are automatically converted to uppercase.
Beside normal characters EAGLE tolerates most other special characters
except blank and semicolon (';'). For nets, parts, module instances, signals and elements
the colon (':') is also not supported because it is needed for automatic naming
of objects in hierarchical designs in a unique way.<br>
For example, element AMP1:IC1 can only relate to a part IC1 in the module which
is used by module instance AMP1, assuming consistency.
<p>
Beside the main schematic each module has it's own <i>namespace</i>. So it's no problem
to have parts R1-R9 in main schematic and also in some modules.
See also <a href=#82>MODULE</a> command, naming section.
<h2>Schematic</h2>
If nets or busses are to be renamed, the program has to distinguish
between three cases because they can consist of several segments placed
on different sheets. Thus a menu will ask the user:
<p>
This segment<br>
Every segment on this sheet<br>
All segments on all sheets
<p>
These questions appear in a popup menu if necessary
and can be answered either by selecting the appropriate item with
the mouse or by pressing the appropriate hot key (T, E, A).
<p>
When changing nets and busses, there is a checkbox to confirm if the user wants to
place a label on the same netor bus after the NAME change is complete, which is
checked by default if a LABEL does not yet exist.  If the user confirms the
NAME change with this box checked, the LABEL command will start and once done,
control will return to the NAME command.
<h2>Polygon</h2>
When renaming a signal polygon in a board, you can choose whether to rename
only this polygon (and thus move it from one signal into another), or to
give the entire signal a different name.


<a name=85>
<h1>NET</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Draws nets on a schematic.
<dt>
<b>Syntax</b>
<dd>
<tt>NET [net_name] &#149; [curve | @radius] &#149;..</tt><br>
<tt>NET BREAKOUT [PIN | UNIQUE] [LENGTH=VALUE] &#149; &#149;..</tt><br>
<tt>NET BREAKOUT [AUTOINCR] [LENGTH=VALUE] net_name &#149; &#149;..</tt><br>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Right</mb> changes the wire bend style (see <a href=#116>SET Wire_Bend</a>).<br>
<mb>Shift+Right</mb> reverses the direction of switching bend styles.<br>
<mb>Ctrl+Right</mb> toggles between corresponding bend styles.
</dl>
<b>See also</b> <a href=#39>BUS</a>,
<a href=#40>BREAKOUTBUS</a>,
<a href=#44>CLASS</a>,
<a href=#84>NAME</a>,
<a href=#95>PINBREAKOUT</a>,
<a href=#116>SET</a>
<p>
The net command is used to draw individual connections (nets) onto
the Net layer of a schematic drawing. The first mouse click marks
the starting point for the net, the second marks the end point of
a segment. Two mouse clicks on the same point end the net.
<p>
Net wires snap to the tips of pins. When the mouse is within
SNAP_LENGTH of any portion of a pin (either before or after grid
snapping), a small circle will appear at the tip of the pin. This
indicates that if the mouse is clicked, the resulting net wire
point will be placed at the pin tip, creating a connection to the pin.
<p>
If a net wire is placed at a point where there is already another net
or bus wire or a pin, the current net wire will be ended at that point.
This function can be disabled with "<tt>SET AUTO_END_NET OFF;</tt>",
or by unchecking "Options/Set/Misc/Auto end net and bus".
<p>
If a net wire is placed at a point where there are at least two other
net wires and/or pins, a junction will automatically be placed.
This function can be disabled with "<tt>SET AUTO_JUNCTION OFF;</tt>",
or by unchecking "Options/Set/Misc/Auto set junction".
<p>
If the <i>curve</i> or <i>@radius</i> parameter is given, an arc can be drawn as part of the net
(see the detailed description in the <a href=#73>LINE</a> command).
<h2>Select Bus Signal</h2>
If a net is started on a bus, a popup menu opens from which one of
the bus signals can be selected. The net then is named correspondingly
and becomes part of the same signal. If the bus includes several part
buses, a further popup menu opens from which the relevant part bus
can be selected.
<h2>Net Names</h2>
If the NET command is used with a net name
then the net is named accordingly.
<p>
If no net name is included in the command line and the net is not
started on a bus, then a name in the form of N$1 is automatically
allocated to the net.
<p>
Nets or net segments that run over different sheets of a schematic and use
the same net name are connected.
<p>
Net names should not contain a comma (<tt>','</tt>), because this
is the delimiting character in <a href=#39>busses</a>.
Net names should also not contain '[' and ']', because they are used to
specify a range in a <a href=#39>bus</a>. Nets from such a range
have the index w/o these brackets. (E.g. the bus D[0..15] has the according
nets: D0, D1, ...)
<h2>Net BREAKOUT</h2>
The NET command includes breakout options that allow you to select any part pins in your
schematic (from any number of parts) and create new nets that breakout from the chosen pins, and
with the specified label format. The UI version of that command is available by clicking the
"Pin Breakout" button in the NET parameter toolbar, or by using NET BREAKOUT from the CLI.
<p> Start the command without any paremeters (or by NET parameter toolbar button) and you can specify the breakout type in the user interface. Then click any pins from any parts in schematic to breakout out new nets with labels matching the chosen option.
<p> The other command line options allow you to supply the type of label which can be PIN, UNIQUE, or net_name. If a net_name is supplied, this will be used for the net name regardless of what pin is connected.
<p> Keywords PIN, UNIQUE and AUTOINCR have special meanings and cannot be used as a net_name value:
using keyword PIN means the new net with be named after the pin it is connected to. Choosing UNIQUE will create a label string with format:
part_gate_pin, where the part, gate, and pin name are concatenated into a unique string for that net based on these values from the selected parts/pins.
<p>The optional keyword AUTOINCR goes before a custom net name, and indicates that, if the user keeps adding pins, they should auto-increment, if the last character in the net_name is a number.
For example using ADDR1 with auto-increment on, would result in ADDR2, ADDR3, etc as the nets are
placed on pins.
<p>The optional keyword LENGTH allows to set a minimum length, in # of grid units, for the new net
    segments created.  This length of the new nets will be this min length, or the length
    calculated for the width of the label text, whichever is larger.
<p> Buses can be broken out automatically with new labeled nets using the BREAKOUTBUS
command, available from the command-line and in the bus object right-click context menu.
See <a href=#40>BREAKOUTBUS</a> for details.
<p> Parts can be broken out automatically with new labeled nets using the PINBREAKOUT command,
available from the command-line and in the part instance right-click context menu.
See <a href=#95>PINBREAKOUT</a> for details.
<h2>Line Width</h2>
The width of the line drawn by the net command may be changed with
the command:
<pre>
SET NET_WIRE_WIDTH width;
</pre>
(Default: 6 mil).
<h2>Inverted signals</h2>
The name of an inverted signal ("active low") can be displayed overlined if it
is preceded with an exclamation mark (<tt>'!'</tt>), as in
<pre>
  !RESET
</pre>
which would result in
<pre>
  _____
  RESET
</pre>
You can find further details about this in the description of the <a href=#131>TEXT</a> command.


<a name=86>
<h1>OPEN</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a library for editing.
<dt>
<b>Syntax</b>
<dd>
<tt>OPEN library_name</tt><br>
<tt>OPEN library_urn</tt>
</dl>
<b>See also</b> <a href=#45>CLOSE</a>,
<a href=#135>USE</a>,
<a href=#54>EDIT</a>,
<a href=#115>SCRIPT</a>
<p>
The OPEN command is used to open an existing library or create a new
library. Once the library has been opened or created, an existing
or new symbol, device, or footprint may be edited.
<p>
If a library name is provided and a library of that name exists in the
library path, it will be opened; otherwise, a new library with the
given name will be created in the first directory in the library path.
If a URN is provided and a managed library with that URN exists, is
locally-available (downloaded), and belongs to the current user, it
will be opened.
<p>
This command is mainly used in script files.
<p>
To switch to the library editor
<pre>
OPEN .lbr
</pre>
can be used.


<a name=87>
<h1>OPTIMIZE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Joins wire segments.
<dt>
<b>Syntax</b>
<dd>
<tt>OPTIMIZE;</tt><br>
<tt>OPTIMIZE name ..</tt><br>
<tt>OPTIMIZE &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Right</mb> optimizes the group.
</dl>
<b>See also</b> <a href=#116>SET</a>,
<a href=#127>SPLIT</a>,
<a href=#83>MOVE</a>,
<a href=#113>ROUTE</a>
<p>
The OPTIMIZE command joins wire segments which lie
in one straight line. The individual segments must be on the same
layer and have the same width. This command is useful to reduce the
number of objects in a drawing and to facilitate moving a complete
track instead of individual segments.
<p>
If a signal, net or bus name is given, or such an object is selected, the command
affects only the respective object.
<p>
Note that when selecting a wire without name, all unnamed wires of the
drawing are optimized.
<p>
Note that when selecting a group of objects, only actual signal resp.
net or bus wires are optimized. To optimize all wires in a drawing, do
<pre>
OPTIMZE;
</pre>
<h2>Automatic Optimization</h2>
This wire optimization takes place automatically after MOVE, SPLIT,
or ROUTE commands unless it is disabled with the command:
<pre>
SET OPTIMIZING OFF;
</pre>
or you have clicked the same spot twice with the SPLIT command.
<p>
The OPTIMIZE command works in any case, no matter if Optimizing
is enabled or disabled.


<a name=88>
<h1>PACKAGE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a package variant for a device.
<dt>
<b>Syntax</b>
<dd>
<tt>PACKAGE</tt><br>
<tt>PACKAGE pname vname</tt><br>
<tt>PACKAGE pname.fpt vname</tt> (new in EAGLE 9.1)<br>
<tt>PACKAGE pname.pac vname</tt> (alternative for backwards compatibility)<br>
<tt>PACKAGE pname.p3d vname</tt><br>
<tt>PACKAGE urn vname</tt><br>
<tt>PACKAGE pname@lname vname</tt><br>
<tt>PACKAGE name</tt><br>
<tt>PACKAGE -old_name new_name</tt><br>
<tt>PACKAGE -name</tt><br>
<tt>PACKAGE @vname</tt><br>
<tt>PACKAGE @vname pname</tt><br>
<tt>PACKAGE @vname pname.pac</tt><br>
<tt>PACKAGE @vname pname.3d</tt><br>
<tt>PACKAGE @vname urn</tt><br>
</dl>
<b>See also</b> <a href=#46>CONNECT</a>,
<a href=#130>TECHNOLOGY</a>,
<a href=#101>PREFIX</a>
<p>
This command is used in the device edit mode to define, delete or rename
a package variant (footprint and optional 3D package).
In the schematic or board editor the PACKAGE command behaves exactly
like "<a href=#41>CHANGE PACKAGE</a>".
<p>
Without parameters a dialog is opened that allows you to select a footprint
(and 3D package) and define this variant's name.
<p>
The parameters <tt>pname vname</tt> assign the footprint <tt>pname</tt> to
the new variant <tt>vname</tt>. If there's exactly one 3D package in the
current library that references that footprint, and the 3D package references
only that footprint, the 3D package will also be added to the new variant.
To avoid including such a 3D package in the variant, use the notation
<tt>pname.fpt vname</tt> (or <tt>pname.fpt vname</tt>). Use the notation <tt>pname.p3d vname</tt> to
specify a 3D package in the library; this will create a new variant for each
footprint in the 3D package. Each variant will also include the 3D package.
<p>
The notation <tt>urn vname</tt> creates a new variant for each footprint in
the 3D package with the given urn. (The <tt>urn</tt> should be of the form
<tt>urn:adsk.eagle:package:123/1</tt>, where <tt>123</tt> is the id of the
3D package and <tt>1</tt> is the version of the 3D package.) If the specified
3D package is not already present in the library, it will be downloaded and
added to the library prior to creation of the variant(s).
<p>
The notation <tt>pname@lname vname</tt> fetches the footprint <tt>pname</tt>
from library <tt>lname</tt> and creates a new package variant.
This can also be done through the library objects'
<a href=#14>context menu</a> or via <i>Drag&amp;Drop</i> from
the Control Panel's tree view.
<p>
The single parameter <tt>name</tt> switches to the given existing package
variant.<br>
Compatibility with version 3.5:<br>
If no package variants have been defined yet, and a footprint of the
given <tt>name</tt> exists, a new package variant named '' (an "empty" name)
with the given footprint will be created.
<p>
If <tt>-old_name new_name</tt> is given, the package variant <tt>old_name</tt>
is renamed to <tt>new_name</tt>.
<p>
The single parameter <tt>-name</tt> deletes the given package variant.
<p>
The <tt>@vname</tt> syntax allows an existing package variant to be updated
by replacing its current footprint and 3D package with a different footprint and
3D package. The variant's existing connections and attributes will
be retained. If <tt>@vname pname</tt> is given, the variant's existing
footprint will be replaced with the footprint specified by <tt>pname</tt>. If
there's exactly one 3D package in the current library that references that
footprint, and the 3D package references only that footprint, the 3D package will
also be added to the variant. To avoid including such a 3D package in the
variant, use the notation <tt>@vname pname.fpt</tt> (or <tt>@vname pname.pac</tt>). Use the notation
<tt>@vname pname.p3d</tt> or <tt>@vname urn</tt> to specify a 3D package in
the library; if there's only one footprint in the 3D package, the footprint and
3D package will be assigned to the variant. (It's not currently possible to
assign a 3D package with more than one footprint to a variant.) If just
<tt>@vname</tt> is given, a dialog is opened that allows you to select the
replacement footprint and 3d package. Note that in all cases, the replacement
footprint and 3D package must already be present in the library.
<p>
The name of a package variant will be appended to the device set name to
form the full device name. If the device set name contains the character <tt>'?'</tt>,
that character will be replaced by the package variant name.
Note that the package variant is processed after the technology, so if the device set
name contains neither a <tt>'*'</tt> nor a <tt>'?'</tt> character, the resulting device
name will consist of <i>device_set_name</i><tt>+</tt><i>technology</i><tt>+</tt><i>package_variant</i>.
<p>
Following the PACKAGE command, the CONNECT command is used to define
the correspondence of pins in the schematic device to pads on the
package.
<p>
When the <a href=#38>BOARD</a> command is used in schematic
editing mode to create a new board, each device is represented on a board
layout with the appropriate package as already defined with the
PACKAGE command.
<p>
<h2>Devices without packages</h2>
Devices can also be created without assigning a package, for example for frames, supply devices,
external or other devices that only make sense in a schematic.
This can be done by creating a device set with adequate gates, technologies and attributes (if necessary)
without using the PACKAGE command. If saved, a packageless variant is created (with empty string as
variant name). As soon as a package is assigned, the packageless variant gets overwritten by this
and no further packageless variants can be created. <br>
As soon as gates contain pins, packageless devices only make limited sense (see below).
<h3>Supply devices</h3>
In order to use supply symbols in schematics, packageless supply devices are common. The device usually
consists of exactly one symbol with a <i>Sup</i> pin (see <a href=#93>PIN</a> command).
<h3>External devices</h3>
These are for documenting assemblies in schematic that are not relevant for the board because they are
externally added e.g for simulation or test purposes.<br>
Such devices must be marked with the attribute <b>_EXTERNAL_</b> (see <a href=#36>ATTRIBUTE</a> command).
The value is not relevant. In this case any gates with pins can be defined without a package.
The atttribute must have been assigned in the library, not in schematic or board.
<p>
Note that supply or external devices are no longer treated as such, as soon as packages are assigned.
The pins have to be connected with pads then.


<a name=89>
<h1>PAD</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds pads to a footprint.
<dt>
<b>Syntax</b>
<dd>
<tt>PAD [diameter] [shape] [orientation] [flags] ['name'] &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Right</mb> rotates the pad.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#123>SMD</a>,
<a href=#41>CHANGE</a>,
<a href=#52>DISPLAY</a>,
<a href=#116>SET</a>,
<a href=#84>NAME</a>,
<a href=#138>VIA</a>,
<a href=#168>Design Rules</a>
<p>
The PAD command is used to add pads to a footprint. When the PAD command
is active, a pad symbol is attached to the cursor and can be moved
around the screen. Pressing the left mouse button places a pad at
the current position.
Entering a number changes the diameter of the pad (in the actual unit).
Pad diameters can be up to 200 mm (7.7840 inch).
<p>
The <tt>orientation</tt> (see description in <a href=#31>ADD</a>)
may be any angle in the range <tt>R0</tt>...<tt>R359.9</tt>. The <tt>S</tt>
and <tt>M</tt> flags can't be used here.
<h2>Example</h2>
<pre>
PAD 0.06 &#149;
</pre>
The pad will have a diameter of 0.06 inch, provided the actual unit
is "inch". This diameter remains as a presetting for successive
operations.
<h2>Pad Shapes</h2>
A pad can have one of the following shapes:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Square    </td><td width=20><td></td></tr>
<tr><td>Round     </td><td width=20><td></td></tr>
<tr><td>Octagon   </td><td width=20><td>octagonal</td></tr>
<tr><td>Long      </td><td width=20><td>elongated</td></tr>
<tr><td>Offset    </td><td width=20><td>elongated with offset</td></tr>
</table>
<p>
These shapes only apply to the outer layers (Top and Bottom).
In inner layers the shape is always "round".
<p>
With elongated pads, the given diameter defines the smaller side of the pad.
The ratio between the two sides of elongated pads is given by the
parameter Shapes/Elongation in the <a href=#168>Design Rules</a>
of the board (default is 100%, which results in a ratio of 2:1).
<p>
The pad shape or diameter can be selected while the PAD command is
active, or it can be changed with the CHANGE command, e.g.:
<pre>
CHANGE SHAPE OCTAGON &#149;
</pre>
The drill size may also be changed using the CHANGE command. The existing
values then remain in use for successive pads.
<p>
Because displaying different pad shapes and drill holes in their real
size slows down the screen refresh, EAGLE lets you change between
real and fast display mode by the use of the SET commands:
<pre>
SET DISPLAY_MODE REAL | NODRILL;
</pre>
Note that the actual shape and diameter of a pad will be determined by the
<a href=#168>Design Rules</a> of the board the part is used in.
<h2>Arbitrary Pad Shapes</h2>
If the standard pad shapes are not sufficient for a particular footprint,
you can create arbitrary pad shapes by drawing a polygon around a pad,
or by drawing wires that have one end connected to the pad.
<p>
The following conditions apply:
<ul>
<li>A polygon in a signal layer (1-16) is considered connected to a pad if the center of
    the pad lies within the area defined by the center lines of the polygon wires.
<li>A wire in a signal layer is considered connected to a pad if one of its end points coincides
    with the center of the pad. Any wire connected to the other end of such a wire
    is also electrically connected to the pad.
<li>Only <b>one</b> polygon per pad is taken into account on any given signal layer.
    If more than one polygon is connected to the same pad in the same layer, they will
    cause DRC errors.
<li>Polygons connected to a pad will be ignored by the Autorouter when routing that
    signal. They will be considered obstacles when routing other signals.
<li>Wires connected to a pad will be handled like any other signal wires by the
    Autorouter, with the exception that they cannot be split.
<li>Solder stop masks are only generated for the pad itself. If any additional solder
    stop mask is required, it has to be drawn explicitly into the respective layer(s).
<li>When generating thermals, the additional polygon shape is taken into account.
<li>If a polygon or wire is connected to more than one pad within a footprint, only one
    of the pads will be considered electrically connected to the polygon or wire.
    The other pads will cause DRC errors, unless they are all
    <a href=#46>connected to the same pin</a> in a device.
<li>If a polygon contains more than one pad, only one of them (the first one found
    in the data structure) will generate thermals. If all of these pads shall
    generate thermals, you need to draw separate polygons (one per pad) that
    overlap accordingly.
<li>If several pads are connected to the same pin in a device, and these pads have
    overlapping wires or polygons in the footprint, DRC errors will occur unless the
    pin is actually connected to a net (i.e. the pads are connected to a signal).
</ul>
<h2>Pad Names</h2>
Pad names are generated by the program automatically
and can be changed with the NAME command. The name can also be defined
in the PAD command. Pad name display can be turned on or off by means
of the commands:
<pre>
SET PAD_NAMES OFF | ON;
</pre>
<h2>Flags</h2>
The following <i>flags</i> can be used to control the appearance of a pad:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>NOSTOP</tt>  </td><td width=20><td>don't generate solder stop mask</td></tr>
<tr><td><tt>NOTHERMALS</tt>       </td><td width=20><td>don't generate thermals</td></tr>
<tr><td><tt>FIRST</tt>            </td><td width=20><td>this is the "first" pad (which may be drawn with a special shape)</td></tr>
</table>
<p>
By default a pad automatically generates solder stop mask and thermals as necessary.
However, in special cases it may be desirable to have particular pads not do this.
The above <tt>NO...</tt> flags can be used to suppress these features.<br>
If the <a href=#168>Design Rules</a> of a given board specify that the
"first pad" of a footprint shall be drawn with a particular shape, the pad marked with
the <tt>FIRST</tt> flag will be displayed that way.<br>
A newly started PAD command resets all flags to their defaults. Once a flag is given
in the command line, it applies to all following pads placed within this PAD command
(except for <tt>FIRST</tt>, which applies only to the pad immediately following this
option).
<h2>Single Pads</h2>
Single pads in boards can be used only by defining a footprint
with one pad. Via-holes can be placed in board but they don't have
an element name and therefore don't show up in the netlist.


<a name=90>
<h1>PADARRAY</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Create arrays of pads.
<dt>
<b>Syntax</b>
<dd>
<tt>PADARRAY [sides base start count dx dy unit drawrect includename includevalue deleteobjs]</tt>
<dt>
<b>See also</b> <a href=#89>PAD</a>
<p>The PADARRAY command allows to create an array of pads in the Library Footprint Editor.
If the command is started from the icon in the PAD parameter toolbar, a dialog pops up where the options
    for sides, basename, start index, number of pads, and others are set before creating the array.
    If the command is started from the command line and arguments are provided, the same options are
    available as specified below.
<h2>Options</h2>
<p>If the arguments are provided after the command, all need to be present: <br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>sides</td>          <td width=20><td>This can be L, R, LR, T, B, or TB, which indicates onto which sides of a rectangle to draw
                            the pads, where L=Left, R=Right, T=Top, and B=Bottom. </td></tr>
<tr><td>base</td>           <td width=20><td>This is the base name to use when naming pads, where pads are named such that the first pin is &lt;base&gt;&lt;start&gt;
                            and subsequent pad are named with an increasing numerical suffix (i.e, ADDR1, ADDR2, .. ADDRN).  The last pad
                            placed with have a name given by &lt;base&gt;&lt;start+count-1&gt;</td></tr>
<tr><td>start</td>          <td width=20><td>The is the start index for pad naming. The first pad starts with a name &lt;base&gt;&lt;start&gt;</td></tr>
<tr><td>count</td>          <td width=20><td>The number of pads to place. </td></tr>
<tr><td>dx</td>             <td width=20><td>The distance in X direction between pads. </td></tr>
<tr><td>dy</td>             <td width=20><td>The distance in Y direction between pads. </td></tr>
<tr><td>unit</td>           <td width=20><td>Valid values are: MIC (for micron), MM (millimeter), MIL (mil = 0.001 inch), INCH.  </td></tr>
<tr><td>drawrect</td>       <td width=20><td>ON or OFF, indicates whether or not to draw a rectangle in the tplace layer as part of the operation</td></tr>
<tr><td>includename</td>    <td width=20><td>ON or OFF, indicates whether or not to place a text object with &gt;NAME as the value</td></tr>
<tr><td>includevalue</td>   <td width=20><td>ON or OFF, indicates whether or not to place a text object with &gt;VALUE as the value</td></tr>
<tr><td>deleteobjs</td>     <td width=20><td>ON or OFF, indicates whether or not to delete pads,labels,and line objects before placing the array</td></tr>
</table>


<a name=91>
<h1>PASTE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Copies the contents of the clipboard or a drawing or a design block file to a drawing.
<dt>
<b>Syntax</b>
<dd>
<tt>PASTE [ orientation ] &#149;</tt><br>
<tt>PASTE [ orientation ] [ offset ] filename &#149;</tt><br>
<tt>PASTE [ DBL ][ orientation ] [ offset ] filename &#149;</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> mirrors the contents of the clipboard.<br>
<mb>Right</mb> rotates the contents of the clipboard.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.<br>
<mb>Ctrl+V</mb> pastes the contents of the clipboard.
</dl>
<b>See also</b> <a href=#48>CUT</a>,
<a href=#47>COPY</a>,
<a href=#62>GROUP</a>
<p>
See the <a href=#31>ADD</a> command for an explanation of <tt>orientation</tt>.
<p>
Using the commands GROUP, CUT, and PASTE, parts of a drawing/library
can be copied to the same or different drawings/libraries. When using
the PASTE command, the following points should be observed:
<ul>
<li>CUT/PASTE cannot be used in device editing mode.
<li>Elements and signals on a board can only be copied to a board.
<li>Parts, buses and nets on a schematic can only be copied to a schematic.
<li>Pads and smds can only be copied from footprint to footprint.
<li>Pins can only be copied from symbol to symbol.
<li>When copying parts, elements, signals, pads, smds and pins, a new name is
allocated if the previous name is already used in the new drawing.
<li>Buses retain the same names.
<li>Nets retain the same name as long as one of the net segments
has a label, or is connected to a supply pin. Otherwise a new name is generated if the previous
name is already in use.
</ul>
If there are modified versions of devices or footprints in the clipboard,
an automatic <a href=#134>library update</a> will be started to replace
the objects in the schematic or board with the ones from the clipboard.<br>
<b>Note: You should always run a <a href=#53>Design Rule Check</a> (DRC) and an
<a href=#55>Electrical Rule Check</a> (ERC) after a library update has been performed!</b>
<h2>Pasting from a file</h2>
If a file name is given in the command line, the complete content of that file
is pasted into the current drawing. If the given file is one of a consistent
board/schematic pair and a consistent board/schematic pair is being edited,
both files will be pasted into the corresponding drawings.
If you set <tt>*</tt> instead of the file name or just a directory, a file dialog
opens in the project directory or the set directory.
<p>
Assume you have a consistent board/schematic pair that contains the design
of an amplifier, where the schematic may consist of several sheets. Now if
you want to place this amplifier several times into your project, you can
simply do
<pre>
PASTE 100 amplifier.sch &#149;
PASTE 200 amplifier.sch &#149;
</pre>
This example also shows the use of an <tt>offset</tt>, which adds the given
value to all part and net names in the pasted files (unless they retain their name,
see below). So the first amplifier channel will have all parts and nets named
starting at 100, while the second one will have them start at 200. If no offset
is given, new names are generated as necessary.
<p>
Just like in a normal PASTE operation, when pasting from a file, nets that have
a label or are connected to a supply pin, retain their name while all others
will get newly generated names. It is enough for a net to retain its name if
it is labeled or connected to a supply pin on one sheet, even if it appears
on several sheets.
<p>
Unless the PASTE operation is done in a script file, you will be offered a dialog
that shows all the net names. By clicking on the names in the "New name" column
you can edit individual net names. Icons indicate whether a net in the pasted
drawing has a label or a supply pin, and whether the net will be connected to
an existing net with the same name in the edited drawing.
<p>
If you paste a schematic into a schematic drawing, all sheets of the pasted
schematic will be added as separate new sheets to the edited drawing.
The corresponding board (if any) will be placed below the existing content of
the edited board drawing. If you want to have explicit control over where
the board is placed, you can perform the PASTE operation in the board, in which
case the schematic sheets will be added just the same, but the board will
be attached to the mouse cursor and you will be able to place it exactly
where you want it.
<p>
For global settings in the files like layer definitions, netclasses, design rules
and autorouter parameters this holds: The settings of the currently opened drawing
are kept. This means e.g., that for the pasted data the restring parameters of
current drawing are used which can lead to differences compared to source drawing.
Please consider running a <a href=#53>DRC</a> for this.<br>
Additional settings like additioal layers or netclasses are added to the current
drawing, of course.
<p>
You can also paste from a file using <i>Drag&amp;Drop</i>, by pressing the
<tt>Ctrl</tt> key when dropping the file.
<p>
If the file name could be mistaken as an orientation or an offset value,
you can enclose it in single quotes.
<h2>Pasting a Design Block (DBL)</h2>
If the DBL option is used, it pastes a design block by file name.
If no file name is given, a dialog similar to the <a href=#31>ADD</a> dialog pops up.
In general this option is equal to pasting from a drawing file or a consistent pair of drawing files.
<p>
A design block may contain a board and a schematic. It will paste all data it can.
If there is only an opened schematic, it will paste only the schematic part of the design block,
accordingly for boards. To paste both, a consistent pair has to be loaded.
If the command is started from board editor, it has the same behavior like pasting from a drawing file.
The board can be placed by mouseclick and new sheets are added to schematic.
If the command is started from schematic editor and the design block has only one sheet,
it can be placed by mouseclick into the current sheet as well. No automatic placement into
new sheets is done in that case.
<h2>Pasting a Pin List from external source</h2>
This option is only available in symbol editor. Source of pins can be any application that copies data
as comma, tab or space separated text to clipboard, this includes various PDF viewers, spreadsheet
and text editors.
<p>For best results format your data in a tabular manner with header row containing column names and
cells containing pin attribute values as described in <a href=#93>PIN</a> section.
<h3>An example of correctly formated pin table data:</h3>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Name          </td><td width=20><td>Length  </td><td width=20><td>Function </td><td width=20><td> Direction</td></tr>
<tr><td>IO_L1N_VREF_0 </td><td width=20><td>Middle  </td><td width=20><td>None     </td><td width=20><td> In       </td></tr>
<tr><td>TCK           </td><td width=20><td>Middle  </td><td width=20><td>DotClk   </td><td width=20><td> Io       </td></tr>
<tr><td>GND           </td><td width=20><td>Short   </td><td width=20><td>None     </td><td width=20><td> Sup      </td></tr>
<tr><td>GND           </td><td width=20><td>Short   </td><td width=20><td>None     </td><td width=20><td> Sup      </td></tr>
<tr><td>gnd           </td><td width=20><td>Long    </td><td width=20><td>None     </td><td width=20><td> Pwr      </td></tr>
<tr><td>gnd           </td><td width=20><td>Long    </td><td width=20><td>None     </td><td width=20><td> Pwr      </td></tr>
<tr><td>Vcc           </td><td width=20><td>Middle  </td><td width=20><td>Dot      </td><td width=20><td> Pwr      </td></tr>
<tr><td>VCC           </td><td width=20><td>Middle  </td><td width=20><td>Dot      </td><td width=20><td> Pwr      </td></tr>
<tr><td>VCC           </td><td width=20><td>Middle  </td><td width=20><td>Dot      </td><td width=20><td> Pwr      </td></tr>
</table>
<h3>Copying pin lists directly from other sources</h3>
<p>Copying directly from sources like PDF datasheets is also supported in either a single column
or multicolumn data modes. Hint: to copy only a single column from PDF use system supported PDF viewer
and hold <tt>Alt</tt> key while selecting the data. In single column mode it is assumed that every row
shall contain a single word representing a pin name. In multicolumn mode, accessible by holding <tt>Ctrl</tt>
key while starting a paste command, data is analyzed for the column that contains pin names.
Success in these two modes highly depends on the formatting of input data, some PDF sheets apply unusual
formatting styles. If you experience problems in this mode, paste data to text editor first to inspect data
layout formatting and correct it if needed.
<h3>Dealing with non compliant pin data</h3>
<p><a href=#93>PIN</a> section describes general requirements about names of the pins.
Default pin attribute values are used whenever values cannot be inferred from input data.
Following changes are applied to non compliant pin names.
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Description                                   </td><td width=20><td>Before                                          </td><td width=20><td>   After                 </td></tr>
<tr><td>Space characters are replaced by underscores  </td><td width=20><td>"A A"                                           </td><td width=20><td>   "A_A"                 </td></tr>
<tr><td>Spaces surrounding forward slash are removed  </td><td width=20><td>"A / B"                                         </td><td width=20><td>   "A/B"                 </td></tr>
<tr><td>Lowercase characters are promoted to uppercase</td><td width=20><td>"ABcde"                                         </td><td width=20><td>   "ABCDE"               </td></tr>
<tr><td>Duplicate names are resolved using @ notation </td><td width=20><td>"GND" in symbol and "Gnd, gnd" in input data    </td><td width=20><td>   "GND@1, GND@2, GND@3" </td></tr>
</table>


<a name=92>
<h1>PATTERN</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Make multiple copies of an object and arrange them in a linear or circular pattern.
<dt>
<b>Syntax</b>
<dd>
<tt>PATTERN &#149;..</tt>
<br />
<tt>PATTERN LINEAR item-count x-spacing x-unit y-spacing y-unit object-location first-item-location</tt>
<br />
<tt>PATTERN CIRCULAR item-count degree [ rotate ] object-location circle-center-location first-item-location</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Right</mb> rotates the selected object.<br>
<mb>Shift+Right</mb> reverses the direction of rotation.
</dl>
The PATTERN command can be started in the command line or with the PATTERN icon in the commands toolbar.
<p>
A dialog opens where you decide about the number of copies and the X and Y spacing in the linear mode. Click OK to close the dialog, then click the object to be duplicated. The next click into the drawing area fixes the position of the first object to be placed. The further duplicates will be placed according the given parameters.<br>
If you choose the circular mode, the number of items, and the angle steps in the dialog, the first click into the drawing area selects the object to be duplicated, the second determines the center of the circle, and the third click fixes the position of the first object to be placed. Further copies are placed automatically according the given parameters in the dialog.
<p>
The PATTERN command may be used in the Schematic, Layout, and Library Editor.
<h2>Options</h2>
<h3>Linear Pattern</h3>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>ITEM-COUNT</td> <td width=20><td>Number of copies in the pattern. </td></tr>
<tr><td>X-SPACING</td> <td width=20><td>Value of the distance between two copies in the pattern in x direction. </td></tr>
<tr><td>X-UNIT</td> <td width=20><td>INCH or MIL or MM or MIC. Unit of X-SPACING. </td></tr>
<tr><td>Y-SPACING</td> <td width=20><td>Value of the distance between two copies in the pattern in y direction. </td></tr>
<tr><td>Y-UNIT</td> <td width=20><td>INCH or MIL or MM or MIC. Unit of Y-SPACING.</td></tr>
<tr><td>OBJECT-LOCATION</td> <td width=20><td>Location of the object to be copied. </td></tr>
<tr><td>CIRCLE-CENTER-LOCATION</td> <td width=20><td>Location of the circle center of the circular pattern. </td></tr>
<tr><td>FIRST-ITEM-LOCATION</td> <td width=20><td>Location of the first item in the pattern. </td></tr>
</table>
<h3>Circular Pattern</h3>
<tr><td>ITEM-COUNT</td> <td width=20><td>Number of copies in the pattern. </td></tr>
<tr><td>DEGREE</td> <td width=20><td>Value of the angle (in degree) between two copies in the pattern. </td></tr>
<tr><td>ROTATE</td> <td width=20><td>Optional. By adding the "OPTIONAL" keyword, the items in the pattern will be rotated. </td></tr>
<tr><td>OBJECT-LOCATION</td> <td width=20><td>Location of the object to be copied. </td></tr>
<tr><td>FIRST-ITEM-LOCATION</td> <td width=20><td>Location of the first item in the pattern. </td></tr>
</table>
<h2>Example</h2>
<pre>
PATTERN CIRCULAR 20 45.0 ROTATE (1.5 1.6) (2.0 2.0) (3.0 2.0)
</pre>
This will generate a circular pattern consisting of 20 copies of the object from (1.5 1.6). The pattern center will be at (2.0 2.0), the first item of the pattern is at (3.0 2.0), the angle between two items is 45.0&#176; , every item is rotated.
<pre>
PATTERN LINEAR 5 1.5 INCH 200 MIL (1.5 1.5) (3.0 2.5)
</pre>
This will generate a linear pattern consisting of 5 copies of the object at (1.5 1.5). The pattern will start at (3.0 2.5) with x spacing of 1.5 inch and y spacing of 200 mil.


<a name=93>
<h1>PIN</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines connection points for symbols.
<dt>
<b>Syntax</b>
<dd>
<tt>PIN 'name' options &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Right</mb> rotates the pin.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#84>NAME</a>,
<a href=#117>SHOW</a>,
<a href=#41>CHANGE</a>,
<a href=#91>PASTE</a>,
<a href=#94>PINARRAY</a>
<h2>Options</h2>
There are six possible options:
<p>
Direction<br>
Function<br>
Length<br>
Orientation<br>
Visible<br>
Swaplevel
<h3>Direction</h3>
The logical direction of signal flow. It is essential for the Electrical
Rule Check (ERC) and for the automatic wiring of the power supply
pins. The following possibilities may be used:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>NC   </td><td width=20><td>not connected</td></tr>
<tr><td>In   </td><td width=20><td>input</td></tr>
<tr><td>Out  </td><td width=20><td>output (totem-pole)</td></tr>
<tr><td>IO   </td><td width=20><td>in/output (bidirectional)</td></tr>
<tr><td>OC   </td><td width=20><td>open collector or open drain</td></tr>
<tr><td>Hiz  </td><td width=20><td>high impedance output (e.g. 3-state)</td></tr>
<tr><td>Pas  </td><td width=20><td>passive (for resistors, capacitors etc.)</td></tr>
<tr><td>Pwr  </td><td width=20><td>power input pin (Vcc, Gnd, Vss, Vdd, etc.)</td></tr>
<tr><td>Sup  </td><td width=20><td>general supply pin (e.g. for ground symbol)</td></tr>
</table>
<p>
Default: IO
<p>
If Pwr pins are used on a symbol and a corresponding Sup pin exists
on the schematic, nets are connected automatically. The Sup pin is
not used for components.
<h3>Function</h3>
The graphic representation of the pin:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>None    </td><td width=20><td>no special function</td></tr>
<tr><td>Dot     </td><td width=20><td>inverter symbol</td></tr>
<tr><td>Clk     </td><td width=20><td>clock symbol</td></tr>
<tr><td>DotClk  </td><td width=20><td>inverted clock symbol</td></tr>
</table>
<p>
Default: None
<h3>Length</h3>
Length of the pin symbol:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Point   </td><td width=20><td>pin with no connection or name</td></tr>
<tr><td>Short   </td><td width=20><td>0.1 inch long connection</td></tr>
<tr><td>Middle  </td><td width=20><td>0.2 inch long connection</td></tr>
<tr><td>Long    </td><td width=20><td>0.3 inch long connection</td></tr>
</table>
<p>
Default: Long
<h3>Orientation</h3>
The orientation of the pin. When placing pins manually the right mouse
button rotates the pin. The parameter "orientation" is mainly
used in script files:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>R0    </td><td width=20><td>connection point on the right</td></tr>
<tr><td>R90   </td><td width=20><td>connection point above</td></tr>
<tr><td>R180  </td><td width=20><td>connection point on the left</td></tr>
<tr><td>R270  </td><td width=20><td>connection point below</td></tr>
</table>
<p>
Default: R0
<h3>Visible</h3>
This parameter defines if pin and/or pad name are visible in the schematic:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Off    </td><td width=20><td>pin and pad name not drawn</td></tr>
<tr><td>Pad    </td><td width=20><td>pad name drawn, pin name not drawn</td></tr>
<tr><td>Pin    </td><td width=20><td>pin name drawn, pad name not drawn</td></tr>
<tr><td>Both   </td><td width=20><td>pin and pad name drawn</td></tr>
</table>
<p>
Default: Both
<h3>Swaplevel</h3>
An integer number. Swaplevel = 0 indicates that a pin can
not be swapped with another. The allocation of a number greater than
0 indicates that a pin may be swapped with any other in the same symbol
with the same swaplevel number. For example: The inputs of a NAND
gate could be allocated the same swaplevel number as they are all
identical.
<p>
Default: 0
<h2>Using the PIN Command</h2>
The PIN command is used to define connection points on a symbol for
nets. Pins are drawn onto the Symbols layer while additional information
appears on the Pins layer. Individual pins may be assigned various
options in the command line. The options can be listed in any order
or omitted. In this case the default options are valid.
<p>
If a name is used in the PIN command, it must be enclosed in
apostrophes. Pin names can be changed in the symbol edit mode
using the NAME command.
<h2>Automatic Naming</h2>
Pins may be automatically numbered in the following way. In order
to place the pins D0...D7 on a symbol, the first pin is placed with
the following command:
<pre>
PIN 'D0' *
</pre>
and the location for the other pins defined with a mouse click for each.
<h2>Predefine options with CHANGE</h2>
All options may be predefined with CHANGE commands. The options remain
in use until edited by a new PIN or CHANGE command.
<p>
The SHOW command may be used to show pin options such as Direction
and Swaplevel.
<h2>Pins with the same Name</h2>
If it is required to define several pins in a component with the same
name, the following procedure can be used:
<p>
For example, suppose that three pins are required for
GND. The pins are allocated the names GND@1, GND@2 and GND@3 during
the symbol definition. Then only the characters before the "@"
sign appear in the schematic.
<p>
It is not possible to add or delete pins in symbols
which are already used by a device because this would change the pin/pad
allocation defined with the CONNECT command.
<h2>Pin Lettering</h2>
The position of pin and pad names on a symbol relative
to the pin connection point can not be changed, nor can the text size.
When defining new symbols please ensure their size is consistent with
existing symbols.
<h2>Inverted pins</h2>
The name of an inverted pin ("active low") can be displayed overlined if it
is preceded with an exclamation mark (<tt>'!'</tt>), as in
<pre>
  !RESET
</pre>
which would result in
<pre>
  _____
  RESET
</pre>
You can find further details about this in the description of the <a href=#131>TEXT</a> command.


<a name=94>
<h1>PINARRAY</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Create an array of pins.
<dt>
<b>Syntax</b>
<dd>
<tt>PINARRAY [sides base start numpins drawrect includename includevalue deleteobjs]</tt>
<dt>
<b>See also</b> <a href=#93>PIN</a>
<p>The PINARRAY command allows to create an array of pins in the Symbol editor.
    If the command is started from the icon in the PIN parameter toolbar, a dialog pops up where
    the options for sides, basename, start index, number of pins,
    and others are set before creating the array. If the command is started from the command
    line and arguments are provided, the same options are available as specified below.
<h2>Options</h2>
<p>If the arguments are provided after the command, all need to be present: <br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>SIDES</td>      <td width=20><td>This can be L|R|T|B, or any combination of these, which indicates onto which sides of a rectangle to draw
                        the pins, where L=Left, R=Right, T=Top, and B=Bottom. </td></tr>
<tr><td>BASE</td>       <td width=20><td>This is the base name to use for the pin names. Pins are named such that the first pin is &lt;base&gt;&lt;start&gt;
                        and subsequent pins are named with an increasing numerical suffix (i.e, ADDR1, ADDR2, .. ADDRn). The last pin
                        placed has a name given by &lt;base&gt;&lt;start+numpins-1&gt;.</td></tr>
<tr><td>START</td>      <td width=20><td>This is the start index for pin naming. The first pin's name is &lt;base&gt;&lt;start&gt;.</td></tr>
<tr><td>NUMPINS</td>    <td width=20><td>The number of pins to place. </td></tr>
<tr><td>DRAWRECT</td>   <td width=20><td>ON or OFF. Determines whether a rectangle should be drawn in the layer Symbols as part of the operation.</td></tr>
<tr><td>INCLUDENAME</td> <td width=20><td>ON or OFF. Determines whether a &gt;NAME text object should be placed.</td></tr>
<tr><td>INCLUDEVALUE</td> <td width=20><td>ON or OFF. Determines whether a &gt;VALUE should be placed.</td></tr>
<tr><td>DELETEOBJS</td> <td width=20><td>ON or OFF. Determines whether pins, labels, and wire objects should be deleted before placing the array.</td></tr>
</table>


<a name=95>
<h1>PINBREAKOUT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Creates nets with or without labels extending from all pins on the selected part.
<dt>
<b>Syntax</b>
<dd>
<tt>PINBREAKOUT name type</tt>
</dl>
<p>The PINBREAKOUT command breaks out each part selected by extending nets from the
part's pins, out a short distance from the pins, optionally named, and with labels.
<p>The name parameter must match a part in schematic, and type is a number from 1 to 4
corresponding to the options below:
<ul>
<li> Unique (&lt;part&gt;_&lt;gate&gt;_&lt;pin&gt;)
<li> Pin names (&lt;pin&gt;)
<li> Default (N$1)
<li> None
</ul>
<p>Note: The command with its various options is accessible on the right-click context menu when clicking on a part in schematic.


<a name=96>
<h1>PINTOBUS</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Automatically connect part instance pins to a nearby bus that includes the pin name in the bus specification with labeled nets.
<dt>
<b>Syntax</b>
<dd>
<tt>PINTOBUS name</tt>
</dl>
<p>The PINTOBUS command is used to extend nets from all pins on a part instance, out to a nearby bus, where
the bus specification includes a member that matches the pin name on the part.
<p>This command can be run from the command line, but is also available from the right-click context menu when clicking on parts in schematic.
<p>please note that the bus you wish to connect to has to be drawn either horizontally or vertically, and the pins must point into the direction of the bus.
<p>As an example, consider a part with pins named VDD and GND at one side, and VIN and VOUT on the other side.
If you were to draw a bus on one side with a spec that includes the names VDD and GND, and another bus on the other side that includes VIN and VOUT,
then this command automatically creates nets with labels named
VDD,GND,VIN, and VOUT extending from the respective pins to the corresponding busses.
<p>Note: You have to select the part and all busses you want to connect to before using the command, or EAGLE will prompt you to do so. The recommended way
to use this command is to incrementally select the busses and the part you wish to connect with Ctrl + left click, then run PINTOBUS from the context menu or command line.


<a name=97>
<h1>PINSWAP</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Swap pins or pads.
<dt>
<b>Syntax</b>
<dd>
<tt>PINSWAP &#149; &#149;..</tt>
</dl>
<b>See also</b> <a href=#93>PIN</a>
<p>
The PINSWAP command is used to swap pins within the same symbol which
have been allocated the same swaplevel (&gt; 0). Swaplevel, see PIN command.
If a board is tied to a schematic via
<a href=#406>Back Annotation</a>
two pads can only
be swapped if the related pins are swappable.
<p>
On a board without a schematic this command permits two pads in the
same footprint to be swapped. The Swaplevel is not checked in this case.
<p>
Wires attached to the swapped pins are moved with the pins so that
short circuits may appear. Please perform the DRC and correct possible
errors.


<a name=98>
<h1>POLYGON</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Draws polygon areas.
<dt>
<b>Syntax</b>
<dd>
<tt>POLYGON [signal_name] [width] &#149; [curve | @radius] &#149; &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.<br>
<mb>Right</mb> changes the wire bend style (see <a href=#116>SET Wire_Bend</a>).<br>
<mb>Shift+Right</mb> reverses the direction of switching bend styles.<br>
<mb>Ctrl+Right</mb> toggles between corresponding bend styles.<br>
<mb>Ctrl+Left</mb> when placing a wire end point defines arc radius.<br>
<mb>Left</mb> twice at the same point closes the polygon.
</dl>
<b>See also</b> <a href=#41>CHANGE</a>,
<a href=#49>DELETE</a>,
<a href=#104>RATSNEST</a>,
<a href=#111>RIPUP</a>,
<a href=#73>LINE</a>,
<a href=#81>MITER</a>
<a href=#99>POLYGONIZE</a>,
<p>
The POLYGON command is used to draw polygon areas. Polygons in the
layers Top, Bottom, and Route2..15 are treated as signals. Polygons
in the layers t/b/vRestrict are protected areas for the Autorouter.
<p>
If the <i>curve</i> or <i>@radius</i> parameter is given, an arc can be drawn as part of the polygon
definition (see the detailed description in the <a href=#73>LINE</a>
command).
<h2>Note</h2>
You should avoid using very small values for the <i>width</i> of a
polygon, because this can cause extremely large amounts of data when
processing a drawing with the <a href=#147>CAM Processor</a>.<br>
The polygon <i>width</i> should always be larger than the hardware
resolution of the output device. For example when using a Gerber photoplotter
with a typical resolution of 1 mil, the polygon <i>width</i> should
not be smaller than, say, 6 mil. Typically you should keep the polygon
<i>width</i> in the same range as your other wires.
<p>
If you want to give the polygon a name that starts with a digit (as in <tt>0V</tt>),
you must enclose the name in single quotes to distinguish it from a <i>width</i> value.
<p>
The parameters <tt>Isolate</tt> and <tt>Rank</tt> only have a meaning for polygons
in the signal layers.
<p>
To withdraw a mistake, always the last wire piece of the polygon can be removed
with the ESCape key.
<h2>Outlines or Real Mode</h2>
Polygons belonging to a signal can be displayed in two different
modes:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>1.&nbsp;Outlines   </td><td width=20><td>only the outlines as defined by the user are displayed.</td></tr>
<tr><td>2.&nbsp;Real&nbsp;mode  </td><td width=20><td>all of the areas are visible as calculated by the program.</td></tr>
</table>
<p>
In "outlines" mode a polygon is drawn with dotted wires, so that it can be
distinguished from other wires.
The board file contains only the "outlines".
<p>
The default display mode is "outlines" as the calculation is a time
consuming operation.
<p>
When a drawing is generated with the CAM Processor all polygons are
calculated.
<p>
The <a href=#104>RATSNEST</a>
command starts the calculation of the polygons
(this can be turned off with
<tt><a href=#116>SET</a> POLYGON_RATSNEST OFF;</tt>).
Clicking the STOP button terminates the calculation of the polygons. Already
calculated polygons are shown in "real mode", all others are shown in
"outline mode".
<p>
The
<a href=#111>RIPUP</a>
command changes the display mode of a polygon to "outline".
<p>
CHANGE operations re-calculate a polygon if it was shown in "real
mode" before.
<h2>Other commands and Polygons</h2>
Polygons are selected at their edges (like wires).
<p>
SPLIT: Inserts a new polygon edge.
<p>
DELETE: Deletes a polygon corner (if only three corners are left the
whole polygon is deleted).
<p>
CHANGE LAYER: Changes the layer of the whole polygon.
<p>
CHANGE WIDTH: Changes the parameter width of the whole polygon.
<p>
MOVE: Moves a polygon edge or corner (like wire segments).
<p>
COPY: Copies the whole polygon.
<p>
NAME: If the polygon is located in a signal layer the name of the
signal is changed.
<h2>Parameters</h2>
<h3>Width</h3>
Line width of the polygon edges. Also used for filling.
<h3>Layer</h3>
Polygons can be drawn into any layer.
Polygons in signal layers belong to a signal and keep the distance
defined in the design rules and net classes from other signals.
Objects in the tRestrict layer are substracted from polygons in the
Top layer (the same applies to bRestrict/Bottom). This allows you, for
instance, to generate "negative" text on a ground area.
<h3>Pour</h3>
Fill mode (Solid [default], Hatch or Cutout).
<h3>Rank</h3>
Defines how polygons are subtracted from each other. Polygons with
a lower 'rank' appear "first" and thus get subtracted from polygons with a higher 'rank'.<br>
Valid ranks are <tt>1..6</tt>.
Polygons with the same rank are checked against each other
by the <a href=#53>Design Rule Check</a>. The rank parameter only has a
meaning for polygons in signal layers (<tt>1..16</tt>) drawn in a board and will be ignored for
any other polygons. The default is <tt>1</tt>.
<h3>Thermals</h3>
Defines how pads and smds are connected (On
= thermals are generated [default], Off = no thermals).
<h3>Spacing</h3>
Distance between fill lines when Pour = Hatch
(default: 50 Mil).
<h3>Isolate</h3>
Distance between polygon areas and other signals or objects in
the Dimension or according restrict layer (default: 0).
If a particular polygon is given an Isolate value that exceeds that from the
design rules and net classes, the larger value will be taken.
See also <a href=#168>Design Rules</a> under <b>Distance</b> and <b>Supply</b>, respectively.
<b>Note that if you give a polygon an Isolate value that exceeds that from the
design rules and net classes, small gaps may result between the calculated polygon
and objects belonging to the same signal as the polygon itself, which may lead
to problems during manufacturing! It is therefore recommended to leave this
parameter at 0, unless you know exactly what you are doing!</b>
<h3>Orphans</h3>
As a polygon automatically keeps a certain distance
to other signals it can happen that the polygon is separated into
a number of smaller polygons. If such a polygon has no electrical
connection to any other (non-polygon) object of its signal,
the user might want it to disappear. With the parameter Orphans&nbsp;=&nbsp;Off
[default] these isolated zones will disappear. With Orphans&nbsp;=&nbsp;On they
will remain. If a signal consists only of polygons and has no other electrically
connected objects, all polygon parts will remain, independent of the setting of
the Orphans parameter.
<p>
Under certain circumstances, especially with Orphans&nbsp;=&nbsp;Off,
a polygon can disappear completely.
In that case the polygon's original outlines will be displayed on the
screen, to make it possible to delete or otherwise modify it.
When going to the printer or CAM Processor these outlines will not
be drawn in order to avoid short circuits.
A polygon is also displayed with its original outlines if there are
other non-polygon objects in the signal, but none of them is connected
to the polygon.
<h2>Thermal dimensions</h2>
The width of the conducting path in the thermal symbol is calculated
as follows:
<ul>
<li>Pads: half the drill diameter of the pad
<li>Smds: half the smaller side of the smd
<li>at least the width of the polygon
<li>a maximum of twice the width of the polygon
</ul>
<h2>Outlines data</h2>
The special signal name _OUTLINES_ gives a polygon certain properties that
are used to generate <a href=#164>outlines data</a> (for example
for milling prototype boards).
This name should not be used otherwise.
<h2>Hatched polygons and airwires </h2>
Depending on the value of the <i>spacing</i> parameter, pads, smds, vias and wires inside a
hatched polygon that are connected to the same signal as the polygon may "fall through"
the raster and thus have airwires generated to indicate their connection to the
signal.
<p>
When calculating whether such an object is actually solidly connected to the
hatched polygon, it is reduced to several "control points". For a round pad, for
instance, these would be the north, east, west and south point on the pad's
circumference, while for a wire it's the two end points. A solid connection is
considered to exist if there is at least one line in the calculated polygon (outline
or hatch line) that runs through these points with its center line.
<p>
Thermal and annulus rings inside a hatched polygon that do not have solid contact to
any of the polygon lines are not generated.
<h2>Polygon cutouts</h2>
The special pour style "Cutout" makes a polygon be subtracted from
all other signal polygons within the same layer, independent of their Rank.
<p>
Only polygons in signal layers can have the pour style "Cutout".
<p>
The outlines of a cutout polygon are always drawn as dotted lines on the
screen, even after the signal polygons have been calculated using
<a href=#104>RATSNEST</a>.
<p>
The wire width of a cutout polygon is taken into account when subtracting it from
other signal polygons. It may be arbitrarily small (even zero) without causing large
amounts of CAM data (as opposed to "solid" polygons, where the wire width should
not be too small).


<a name=99>
<h1>POLYGONIZE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Converts a closed set of wires into a polygon or vice versa.
<dt>
<b>Syntax</b>
<dd>
<tt>POLYGONIZE</tt>
<dt>
</dl>
<b>See also</b> <a href=#98>POLYGON</a>
<p>
The POLYGONIZE command is used to convert a closed set of wires into a polygon or vice versa. When converting wires into a polygon, execute POLYGONIZE and click on one of the wires to be converted. When converting a polygon into wires, execute POLYGONIZE and click on the outline of the polygon to be converted. Holding Alt while clicking will add the polygon as a new object, whereas not holding alt will replace the original object(s) with the new one(s).<p>
An alternative way of invoking POLYGONIZE is by right clicking on a wire or a polygon edge and choose "Convert To Polygon" or "Convert To Wires". After that you will get the option to either "Copy" or "Replace". <p>


<a name=100>
<h1>PORT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds ports to modules.
<dt>
<b>Syntax</b>
<dd>
<tt>PORT 'module_instance_name' 'net_name' options &#149;..</tt><br>
<tt>PORT 'module' 'net_name' options &#149;..</tt><br>
<tt>PORT 'module' 'net_name' options|DELETE</tt><br>
</tt>
</dl>
<b>See also</b> <a href=#82>MODULE</a>
<p>
The <tt>PORT</tt> command is used to add ports to modules used in hierarchical schematics.
<p>
The position and orientation are calculated automatically on the closest side of the
module symbol.
<p>
A port exports a net of a module to the outside and defines a connection point for
another net. The net connected to the port provides the common name and class.
<p>
If a simple bus name for <tt>net_name</tt> is used (see Names), this port
exports all nets of that bus at once to the outside and defines a connection
point for a proper bus.
<p>
If a net of a <a href=#82>MODULE</a> has an external connection
through a PORT, the net class of the net on this port is overwriting the net
class of the net in the module.
<h2>Names</h2>
The port name have to be chosen according to the net name within that module, which
should be exported.
<p>
The port name can even be a simple bus name with a single range like 'PA[0..7]'
(aliases are not allowed).
<h2>Options</h2>
<h3>Direction</h3>
The logical direction of signal flow. It is essential for the Electrical
Rule Check (ERC) and for the automatic wiring of the power supply
pins. The following possibilities may be used:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>NC   </td><td width=20><td>not connected</td></tr>
<tr><td>In   </td><td width=20><td>input</td></tr>
<tr><td>Out  </td><td width=20><td>output (totem-pole)</td></tr>
<tr><td>IO   </td><td width=20><td>in/output (bidirectional)</td></tr>
<tr><td>OC   </td><td width=20><td>open collector or open drain</td></tr>
<tr><td>Hiz  </td><td width=20><td>high impedance output (e.g. 3-state)</td></tr>
<tr><td>Pas  </td><td width=20><td>passive (for resistors, capacitors etc.)</td></tr>
<tr><td>Pwr  </td><td width=20><td>power input pin (Vcc, Gnd, Vss, Vdd, etc.)</td></tr>
</table>
<p>
Default: IO
<p>
In module context the direction of already existing ports can be changed.
<h3>DELETE</h3>
The option DELETE is used to delete an already existing port in module context.
<h2>Edit</h2>
The <a href=#83>MOVE</a> command can be used to edit the module symbol.
A port of a module symbol can be selected with <mb>Ctrl+Left</mb> at it's connecting end
for moving it along the module instance's border.
<p>
The <a href=#65>INFO</a> command can be used to get the port properties
by selecting it with <mb>Ctrl+Left</mb>.
<p>
The <a href=#49>DELETE</a> command can be used to delete a port
by selecting it with <mb>Ctrl+Left</mb>.
<p>
If connected with a net, the selection can be ambigous. Please use <mb>Ctrl+Right</mb>
in order to switch to the requested object (port in this case).


<a name=101>
<h1>PREFIX</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines the prefix for a symbol or module name.
<dt>
<b>Syntax</b>
<dd>
<tt>PREFIX prefix_string;</tt>
</dl>
<b>See also</b> <a href=#46>CONNECT</a>,
<a href=#82>MODULE</a>,
<a href=#88>PACKAGE</a>,
<a href=#136>VALUE</a>
<p>
This command is used in the device editor mode to determine the initial
characters of automatically generated symbol names when a symbol is
placed in a schematic using the ADD command.
<p>
This command can also be used if editing a sheet of a module to set the
prefix of this module.
<h2>Example</h2>
<pre>
PREFIX U;
</pre>
If this command is used when editing, for example, a 7400 device, then
gates which are later placed in a schematic using the ADD command
will be allocated the names  U1, U2, U3 in sequence. These names may
be changed later with the NAME command.


<a name=102>
<h1>PRINT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Prints a drawing to the system printer.
<dt>
<b>Syntax</b>
<dd>
<tt>PRINT [factor] [-limit] [options] [;]</tt>
</dl>
<b>See also</b> <a href=#147>CAM Processor</a>,
<a href=#143>printing to the system printer</a>
<p>
The PRINT command prints the currently edited drawing to the system printer.
<p>
Colors and fill styles are used as set in the editor window. This can be
changed with the <tt>SOLID</tt> and <tt>BLACK</tt> options.
The color palette used for the printout is always that for white background.
<p>
If you want to print pads and vias "filled" (without the drill holes
being visible), use the command
<pre>
<a href=#116>SET</a> DISPLAY_MODE NODRILL;
</pre>
<b>Please note that polygons in boards will not be automatically calculated
when printing via the PRINT command! Only the outlines will be drawn.
To print polygons in their calculated shape you have to use the
<a href=#104>RATSNEST</a> command before printing.</b>
<p>
You can enter a <tt>factor</tt> to scale the output.
<p>
The <tt>limit</tt> parameter is the maximum number of pages you want the
output to use. The number has to be preceded with a <tt>'-'</tt> to
distinguish it from the <tt>factor</tt>.
In case the drawing does not fit on the given number of pages, the <tt>factor</tt>
will be reduced until it fits.
Set this parameter to <tt>-0</tt> to allow any number of pages (and thus making sure
the printout uses exactly the given scale factor).
<p>
If the PRINT command is not terminated with a <tt>';'</tt>,
a <a href=#144>print dialog</a> will allow you to set
print options.
Note that options entered via the command line will not be stored permanently in the print setup
unless they have been confirmed in the <a href=#144>print dialog</a>
(i.e. if the command has not been terminated with a <tt>';'</tt>).
<p>
The following <tt>options</tt> exist:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>MIRROR</tt>        </td><td width=20><td>mirrors the output</td></tr>
<tr><td><tt>ROTATE</tt>        </td><td width=20><td>rotates the output by 90&deg;</td></tr>
<tr><td><tt>UPSIDEDOWN</tt>    </td><td width=20><td>rotates the drawing by 180&deg;. Together with <tt>ROTATE</tt>, the drawing is rotated by a total of 270&deg;</td></tr>
<tr><td><tt>BLACK</tt>         </td><td width=20><td>ignores the color settings of the layers and prints everything in black</td></tr>
<tr><td><tt>SOLID</tt>         </td><td width=20><td>ignores the fill style settings of the layers and prints everything in solid</td></tr>
<tr><td><tt>CAPTION</tt>       </td><td width=20><td>prints a caption at the bottom of the page</td></tr>
<tr><td><tt>FILE</tt>          </td><td width=20><td>prints the output into a file; the file name must immediately follow this option</td></tr>
<tr><td><tt>PRINTER</tt>       </td><td width=20><td>prints to a specific printer; the printer name must immediately follow this option</td></tr>
<tr><td><tt>PAPER</tt>         </td><td width=20><td>prints on the given paper size; the paper size must immediately follow this option</td></tr>
<tr><td><tt>SHEETS</tt>        </td><td width=20><td>prints the given range of sheets; the range (from-to) must immediately follow this option</td></tr>
<tr><td><tt>ALIGN</tt>         </td><td width=20><td>prints in a given alignment; the alignment setting must immediately follow this option</td></tr>
<tr><td><tt>WINDOW</tt>        </td><td width=20><td>prints the currently visible window selection of the drawing</td></tr>
<tr><td><tt>PORTRAIT</tt>      </td><td width=20><td>prints in portrait orientation</td></tr>
<tr><td><tt>LANDSCAPE</tt>     </td><td width=20><td>prints in landscape orientation</td></tr>
<tr><td><tt>HIERARCHY</tt>     </td><td width=20><td>prints sheets of modules in hierarchical use</td></tr>
</table>
<p>
If any of the <tt>options</tt> <tt>MIRROR</tt>...<tt>CAPTION</tt> is preceeded with a <tt>'-'</tt>, that option is turned off in case
it is currently on (from a previous PRINT).
A <tt>'-'</tt> by itself turns off all <tt>options</tt>.
<h2>Printing to a file</h2>
The <tt>FILE</tt> option can be used to print the output into a file.
If this option is present, it must be immediately followed by the name of the output file.
<p>
If the output file name has an extension of <tt>".pdf"</tt> (case insensitive),
a PDF file will be created. A PDF file can also be created by selecting "Print to File (PDF)"
from the "Printer" combo box in the <a href=#144>print dialog</a>.
Texts in a PDF file can be searched in a PDF viewer, as long as they are not
using the vector font.
<p>
If the output file name has an extension of <tt>".ps"</tt> (case insensitive),
a Postscript file will be created.
<p>
If the file name is only an <tt>"*"</tt> or <tt>"*.ext"</tt> (an asterisk followed
by an extension, as in <tt>"*.pdf"</tt>, for instance), a file dialog will be opened
that allows the user to select or enter the actual file name.
<p>
If the file name is only an extension, as in <tt>".pdf"</tt>, the output file name
will be the same as the drawing file name, with the extension changed to the given
string.
<p>
The file name may contain one or more of the following placeholders, which
will be replaced with the respective string:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%E</tt>     </td><td width=20><td>the loaded file's extension (without the <tt>'.'</tt>)</td></tr>
<tr><td><tt>%N</tt>     </td><td width=20><td>the loaded file's name (without path and extension)</td></tr>
<tr><td><tt>%P</tt>     </td><td width=20><td>the loaded file's directory path (without file name)</td></tr>
<tr><td><tt>%%</tt>     </td><td width=20><td>the character <tt>'%'</tt></td></tr>
</table>
<p>
For example, the file name
<p>
<tt>%N.cmp.pdf</tt>
<p>
would create <tt><i>boardname</i>.cmp.pdf</tt>.
<p>
If both the <tt>FILE</tt> and the <tt>PRINTER</tt> option are present, only the last one
given will be taken into account
<h2>Printing to a given paper size</h2>
The <tt>PAPER</tt> option defines the size of the paper to print on.
It must be immediately followed by one of the paper size names listed in
the <i>Paper</i> combo box of the PRINT dialog, like <tt>A4</tt>, <tt>Letter</tt> etc.
If a custom paper size shall be set, it has to be given in the format
<pre>
Width x Height Unit
</pre>
(without blanks), as in
<pre>
PRINT PAPER 200x300mm
PRINT PAPER 8.0x11.5inch
</pre>
<i>Width</i> and <i>Height</i> can be floating point numbers, and the <i>Unit</i>
may be either <tt>mm</tt> or <tt>inch</tt> (the latter may be abbreviated as <tt>in</tt>).
Paper names must be given in full, and are case insensitive.
If both the <tt>PRINTER</tt> and <tt>PAPER</tt> option are used, the <tt>PRINTER</tt>
option must be given first.
Custom paper sizes may not work with all printers. They are mainly for use
with Postscript or PDF output.
<h2>Printing a range of sheets</h2>
The <tt>SHEETS</tt> option can be used to print a range of sheets from a schematic.
The range is given as two numbers, delimited by a <tt>'-'</tt>, as in <tt>2-15</tt>.
Without this option, only the currently edited sheet is printed.
To print all sheets, the range <tt>ALL</tt> can be used (which is case insensitive,
but must be written in full).
A range can also consist of just a single number, as in <tt>42</tt>, which will
print exactly that sheet.
If no schematic is loaded, this option has no meaning.
<h2>Printing with an alignment</h2>
For the <tt>ALIGN</tt> option there are the settings T (top), C (center)
and B (bottom) for vertical and R (right), C (center) and L (left) for horizontal
alignment. For example, <tt>PRINT ALIGN TL;</tt> prints in alignment top left.
If only one direction is specified, the other direction is assumed center
(like in <tt>PRINT ALIGN B;</tt>, for printing with alignment bottom center).
The order of settings is not relevant.
<h2>Printing sheets of modules</h2>
If the currently edited sheet is part of a module, the range of sheets applies
to the module. With the option <tt>SHEETS ALL</tt> all sheets of the main
schematic and all sheets of all modules are printed.
If the option <tt>HIERARCHY</tt> is given additionally, sheets of a module are
printed for each use in a module instance with the according part and net names.
<h2>Examples</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PRINT</tt>     </td><td width=20><td>opens the <a href=#144>print dialog</a> in which you can set print options</td></tr>
<tr><td><tt>PRINT;</tt>    </td><td width=20><td>immediately prints the drawing with the default options</td></tr>
<tr><td><tt>PRINT - MIRROR BLACK SOLID;</tt>  </td><td width=20><td>prints the drawing mirrored, with everything in black and solid</td></tr>
<tr><td><tt>PRINT 2.5 -1;</tt>              </td><td width=20><td>prints the drawing enlarged by a factor of 2.5, but makes sure that it does not exceed <b>one</b> page</td></tr>
<tr><td><tt>PRINT FILE .pdf;</tt>           </td><td width=20><td>prints the drawing into a PDF file with the same name as the drawing file</td></tr>
<tr><td><tt>PRINT SHEETS 2-15 FILE .pdf;</tt> </td><td width=20><td>prints the sheets 2 through 15 into a PDF file with the same name as the drawing file</td></tr>
<tr><td><tt>PRINT SHEETS ALL;</tt> </td><td width=20><td>prints all sheets of the main schematic and of all modules as drawn</td></tr>
<tr><td><tt>PRINT HIERARCHY SHEETS ALL;</tt> </td><td width=20><td>prints all sheets of the main schematic and all sheets of the modules according to their module instances</td></tr>
</table>


<a name=103>
<h1>QUIT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Quits the program
<dt>
<b>Syntax</b>
<dd>
<tt>QUIT</tt>
</dl>
This command ends the editing session. If any changes have been made
but the drawing has not yet been saved, a popup menu will ask you
if you want to save the drawing/library first.
<p>
You can also exit from EAGLE at any time by pressing <tt>Alt+X</tt>.


<a name=104>
<h1>RATSNEST</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Calculates the shortest possible airwires and polygons.
<dt>
<b>Syntax</b>
<dd>
<tt>RATSNEST</tt><br>
<tt>RATSNEST signal_name ..</tt><br>
<tt>RATSNEST ! signal_name ..</tt>
</dl>
<b>See also</b> <a href=#118>SIGNAL</a>,
<a href=#83>MOVE</a>,
<a href=#98>POLYGON</a>,
<a href=#111>RIPUP</a>
<p>
The RATSNEST command assesses the airwire connections in order
to achieve the shortest possible paths, for instance, after components
have been moved. After reading a netlist via the
<a href=#115>SCRIPT</a>
command, it is also useful to use the RATSNEST command to optimize the
length of airwires.
<p>
The RATSNEST command also calculates all polygons belonging to a
signal. This is necessary in order to avoid the calculation of
airwires for pads already connected through polygons. All of the calculated
polygon areas are then being displayed in the "real mode".
You can switch back to the faster
"outline mode" with the RIPUP command.<br>
The automatic calculation of the polygons can be turned off with
<pre>
<a href=#116>SET</a> POLYGON_RATSNEST OFF;
</pre>
Note that RATSNEST doesn't mark the board drawing as modified, since the
calculated polygon data (if any) is not stored in the board, and the
recalculated airwires don't really constitute a modification of the drawing.
<h2>Zero length airwires</h2>
If two or more wires of the same signal on different routing layers end
at the same point without being connected through a pad or a via, a
<i>zero length airwire</i> is generated, which will be displayed
as an X-shaped cross in the Unrouted layer. The same applies to smds that
belong to the same signal and are placed on opposite sides of the board.
<p>
Such <i>zero length airwires</i> can be picked up with the
<a href=#113>ROUTE</a> command just like ordinary airwires.
They may also be handled by placing a <a href=#138>VIA</a>
at that point.
<h2>Making sure everything has been routed</h2>
If there is nothing left to be routed, the RATSNEST command will respond
with the message
<pre>
Ratsnest: Nothing to do!
</pre>
Otherwise, if there are still airwires that have not been routed, the
message
<pre>
Ratsnest: xx airwires.
</pre>
will be displayed, where <tt>xx</tt> gives the number of unrouted airwires.
<h2>Wildcards</h2>
If a <tt>signal_name</tt> parameter is given, the characters <tt>'*'</tt>, <tt>'?'</tt>
and <tt>'[]'</tt> are <i>wildcards</i> and have the following meaning:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>*</tt>    </td><td width=20><td>matches any number of any characters</td></tr>
<tr><td><tt>?</tt>    </td><td width=20><td>matches exactly one character</td></tr>
<tr><td><tt>[...]</tt></td><td width=20><td>matches any of the characters between the brackets</td></tr>
</table>
<p>
If any of these characters shall be matched exactly as such, it has to be enclosed
in brackets. For example, <tt>abc[*]ghi</tt> would match <tt>abc*ghi</tt> and not
<tt>abcdefghi</tt>.
<p>
A range of characters can be given as <tt>[a-z]</tt>, which results in any character
in the range <tt>'a'</tt>...<tt>'z'</tt>.
<h2>Hiding selected airwires</h2>
Sometimes it may be useful to hide the airwires of selected signals, for instance
if these will later be connected through a polygon. Typically this could be supply
signals, which have a lot of airwires that will never be routed explicitly and
just obscure the other signals' airwires.
<p>
To hide airwires the RATSNEST command can be given the exclamation mark (<tt>'!'</tt>),
followed by a list of signals, as in
<pre>
RATSNEST ! GND VCC
</pre>
which would hide the airwires of the signals <tt>GND</tt> and <tt>VCC</tt>.<br>
To have the airwires displayed again just enter the RATSNEST command without the
<tt>'!'</tt> character, and the list of signals:
<pre>
RATSNEST GND VCC
</pre>
This will activate the display of the airwires of the signals <tt>GND</tt> and <tt>VCC</tt>
and also recalculates them. You can also recalculate the airwires (and polygons) of
particular signals this way.
<p>
The signal names may contain wildcards, and the two variants may be combined, as in
<pre>
RATSNEST D* ! ?GND VCC
</pre>
which would recalculate and display the airwires of all signals with names beginning
with <tt>'D'</tt>, and hide the airwires of all the various GND signals (like AGND, DGND etc.)
and the VCC signal. Note that the command is processed from left to right, so in case
there is a DGND signal the example would first process it for display, but then
hide its airwires.
<p>
To make sure all airwires are displayed enter
<pre>
RATSNEST *
</pre>
Note that the <a href=#118>SIGNAL</a> command will automatically
make the airwires of a signal visible if a new airwire is created for that signal.
The <a href=#111>RIPUP</a> command on the other hand will not change
the state of hiding airwires if a wire of a signal is changed into an airwire.
<h2>Differential Pairs</h2>
Airwires for Differential Pair signals prefer open wire ends.


<a name=105>
<h1>RECT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds rectangles to a drawing.
<dt>
<b>Syntax</b>
<dd>
<tt>RECT [orientation] &#149; &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.
</dl>
<b>See also</b> <a href=#43>CIRCLE</a>
<p>
The RECT command is used to add rectangles to a drawing. The two points
define two opposite corners of the rectangle. Pressing the center
mouse button changes the layer to which the rectangle is to be added.
<p>
The <tt>orientation</tt> (see description in <a href=#31>ADD</a>)
may be any angle in the range <tt>R0</tt>...<tt>R359.9</tt>. The <tt>S</tt>
and <tt>M</tt> flags can't be used here.
Note that the coordinates are always defined at an orientation of <tt>R0</tt>.
The possibility of entering an <tt>orientation</tt> in the RECT command is
mainly for use in scripts, where the rectangle data may have been derived
through a User Language Program from the <a href=#242>UL_RECTANGLE</a>
object. When entering a non-zero orientation interactively, the corners of
the rectangle may not appear at the actual cursor position.
Use the <a href=#112>ROTATE</a> command to interactively rotate
a rectangle.
<h2>Not Part of Signals</h2>
Rectangles in the signal layers Top, Bottom, or Route2...15 don't
belong to signals. Therefore the DRC reports errors if they overlap
with wires, pads etc.
<h2>Restricted Areas</h2>
If used in the layers tRestrict, bRestrict, or vRestrict, the RECT
command defines restricted areas for the Autorouter.


<a name=106>
<h1>REDO</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Executes a command that was reversed by UNDO.
<dt>
<b>Syntax</b>
<dd>
<tt>REDO;</tt>
</dl>
<b>See also</b> <a href=#133>UNDO</a>,
<a href=#406>Forward&amp;Back Annotation</a>
<p>
In EAGLE it is possible to reverse previous actions with the UNDO
command. These actions can be executed again by the REDO command.
UNDO and REDO operate with a command memory which exists back to the
last EDIT, OPEN or REMOVE command.
<p>
UNDO/REDO is completely integrated within Forward&amp;Back Annotation.


<a name=107>
<h1>REMOVE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Deletes files, devices, symbols, footprints, 3D packages, modules, and sheets.
<dt>
<b>Syntax</b>
<dd>
<tt>REMOVE name</tt><br>
<tt>REMOVE name.Sxx</tt><br>
<tt>REMOVE name.mod</tt><br>
<tt>REMOVE name.Mxx</tt>
</dl>
<b>See also</b> <a href=#86>OPEN</a>,
<a href=#109>RENAME</a>,
<a href=#82>MODULE</a>
<h2>Files</h2>
The REMOVE command is used to delete the file <tt>name</tt> if in
board or schematic editing mode.
<h2>Devices, Symbols, Footprints, 3D Packages</h2>
The REMOVE command is used to delete the device, symbol, footprint or 3D package
"name" from the presently opened library.
The name may include an extension (for example REMOVE name.sym). If the name is given without
extension, you have to be in the respective mode to remove an object
(i.e. editing a symbol if you want to remove symbols).
<p>
Symbols, footprints, and 3D packages can be erased from a library only
if not used by a device (or, in the case of footprints, by a 3D package).
<p>
REMOVE in a library clears the UNDO buffer.
<h2>Sheets</h2>
The REMOVE command may also be used to delete a sheet from a schematic.
The name of the presently loaded schematic can be omitted.
The parameter xx represents the sheet number, for example:
<pre>
REMOVE .S3
</pre>
deletes sheet number 3 from the presently loaded schematic.
<p>
If you delete the currently loaded sheet, sheet number 1 will be loaded
after the command has been executed. All sheets with a higher number
than the one deleted will get a number reduced by one.
<h2>Modules</h2>
The REMOVE command may also be used to delete a module or a sheet of a
module from a schematic, for example:
<pre>
REMOVE name.mod
REMOVE name.m3
</pre>


<a name=108>
<h1>REMOVEMODEL</h1>
<dl>
<dt>
<b>Function</b>
<dd>
    Remove SPICE model mappings and attributes from selected parts. If using this command within a schematic, it can only work on parts that
    were mapped from within the schematic, and will not work on parts that were mapped within a library. If running this command within the
    library editor, it will clear all model mappings and attributes for all gates in the device.
<dt>
<b>Syntax</b>
<dd>
<tt>REMOVEMODEL name</tt><br>
</dl>
<b>See also</b> <a href=#32>ADDMODEL</a>


<a name=109>
<h1>RENAME</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Renames symbols, devices, footprints or modules.
<dt>
<b>Syntax</b>
<dd>
<tt>RENAME old_name new_name;</tt>
</dl>
<b>See also</b> <a href=#86>OPEN</a>
<p>
In the library editor the RENAME command is used to change the name of a symbol, device
or footprint in the currently opened library.
In the schematic editor modules of the current schematic can be renamed this way.
<p>
The names may include extensions (for example RENAME name1.sym name2[.sym] - note that the
extension is optional in the second parameter). If the first parameter
is given without extension in the library editor, you have to be in the respective mode to
rename an object (i.e. editing a package if you want to rename packages).
Supported extensions are '.fpt', 'sym', '.dev' and '.mod' for footprints,
symbols, devices and modules. Note: '.fpt' for footprints is new as of EAGLE 9.1; ".pac"
is also supported for backwards compatibility with previous EAGLE versions.
<p>
RENAME clears the UNDO buffer.


<a name=110>
<h1>REPLACE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Replace a part.
<dt>
<b>Syntax</b>
<dd>
<tt>REPLACE &#149;..</tt><br>
<tt>REPLACE device_name[@library_name] [P3D=3d_package] &#149;..</tt><br>
<tt>REPLACE part_name device_name[@library_name] [P3D=3d_package] ..</tt><br>
<tt>REPLACE footprint_name &#149;..</tt><br>
<tt>REPLACE element_name footprint_name ..</tt>
</dl>
<b>See also</b> <a href=#116>SET</a>,
<a href=#134>UPDATE</a>
<p>
The REPLACE command can be used to replace a part with a different
device (even from a different library). The old and new device must
be compatible, which means that their used gates and connected pins/pads must
match, either by their names or their coordinates.
<p>
Without parameters the REPLACE command opens a dialog from which a device
can be selected from all libraries that are currently in <a href=#135>use</a>.
After such a device has been selected, subsequent mouse clicks on parts
will replace those parts' devices with the selected one if possible.
<p>
If a <tt>device_name</tt> is given, that device will be used for the replace
operation.
<p>
With both a <tt>part_name</tt> and a <tt>device_name</tt>, the device of
the given part will be replaced (this is useful when working with scripts).
<p>
If a <tt>library_name</tt> is given and it contains blanks, the whole
<tt>device_name@library_name</tt> needs to be enclosed in single quotes.
<p>
The 3D package of the device can be selected using the <tt>P3D=3d_package</tt>
syntax. The <tt>3d_package</tt> can be either the name or URN of one of the
3D packages associated with the device. This term is not case sensitive and
may not contain wildcards.
<p>
If only a board is being edited (without a schematic), or if elements in the
board are being replaced that have no matching part in the schematic,
the REPLACE command has two different modes that are chosen by the
SET command.
<p>
The first mode (default) is activated by the command:
<pre>
SET REPLACE_SAME NAMES;
</pre>
In this mode the new footprint must have the same pad and smd names
as the old one. It may be taken from a different library and it may
contain additional pads and smds. The position of pads
and smds is irrelevant.
<p>
The second mode is activated by the command
<pre>
SET REPLACE_SAME COORDS;
</pre>
In this mode, pads and smds of the new footprint must
be placed at the same coordinates as in the old one (relative to the
origin). Pad and smd names may be different. The new footprint may be
taken from a different library and may contain additional pads and
smds.
<p>
Pads of the old footprint connected with signals must be present in the
new footprint. If this condition is true the new footprint may have less
pads than the old one.
<p>
REPLACE functions only when the appropriate tOrigins/bOrigins
layer is displayed.
<p>
If there is already a footprint with the same name (from the same library) in the drawing,
and the library has been modified after the original object was added, an automatic
<a href=#134>library update</a> will be started and you will be asked whether
objects in the drawing shall be replaced with their new versions.
<p>
<b>Note: A REPLACE operation automatically updates all involved library objects
as necessary. This means that other parts (on other schematic sheets or in
other locations on the board) may be changed, too.
You should always run a <a href=#53>Design Rule Check</a> (DRC) and an
<a href=#55>Electrical Rule Check</a> (ERC) after a REPLACE operation!</b>


<a name=111>
<h1>RIPUP</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Changes routed wires and vias into airwires.<br>
Changes the display of polygons to "outlines".
<dt>
<b>Syntax</b>
<dd>
<tt>RIPUP;</tt><br>
<tt>RIPUP [ @ ] [ ! ] &#149;..</tt><br>
<tt>RIPUP [ @ ] [ ! ] signal_name..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Right</mb> rips up the group.
</dl>
<b>See also</b> <a href=#49>DELETE</a>,
<a href=#62>GROUP</a>,
<a href=#98>POLYGON</a>,
<a href=#104>RATSNEST</a>
<p>
The RIPUP command changes routed wires (tracks) into airwires. That
can be done for:
<ul>
<li>all signals (RIPUP;)
<li>all signals except certain ones (e.g. RIPUP ! GND VCC;)
<li>one or more signals (e.g. RIPUP D0 D1 D2;)
<li>certain segments (chosen with one or more mouse clicks)
<li>all polygons (RIPUP @;)
<li>all polygons of certain signals (e.g. RIPUP @ GND VCC;)
<li>all polygons except those of certain signals (e.g. RIPUP @ ! GND VCC;)
</ul>
Selecting an airwire with RIPUP converts all adjacent routed wires and vias
into airwires, up to the next pad, smd or airwire.
<pre>
RIPUP signal_name..
</pre>
rips up the complete signal "signal_name", but only if it is connected
to elements (several signals may be listed, e.g. <tt>RIPUP D0 D1 D2;</tt>).
<pre>
RIPUP &#149;..
</pre>
rips up segments selected by the mouse click up to the next pad/smd.
<pre>
RIPUP;
</pre>
removes only signals which are connected to elements
(e.g. board crop marks are not affected). The same applies if RIPUP
is used on a group.
<p>
<b>Note:</b> in all cases the RIPUP command only acts on objects that
are in layers that are currently visible!
<h2>Wildcards</h2>
If a <tt>signal_name</tt> parameter is given, the characters <tt>'*'</tt>, <tt>'?'</tt>
and <tt>'[]'</tt> are <i>wildcards</i> and have the following meaning:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>*</tt>    </td><td width=20><td>matches any number of any characters</td></tr>
<tr><td><tt>?</tt>    </td><td width=20><td>matches exactly one character</td></tr>
<tr><td><tt>[...]</tt></td><td width=20><td>matches any of the characters between the brackets</td></tr>
</table>
<p>
If any of these characters shall be matched exactly as such, it has to be enclosed
in brackets. For example, <tt>abc[*]ghi</tt> would match <tt>abc*ghi</tt> and not
<tt>abcdefghi</tt>.
<p>
A range of characters can be given as <tt>[a-z]</tt>, which results in any character
in the range <tt>'a'</tt>...<tt>'z'</tt>.
<h2>Polygons</h2>
If the RIPUP command with a name is applied to a signal which contains a polygon
the polygon will be displayed with its outlines (faster screen
redraw!). Use the <a href=#104>RATSNEST</a> command to have polygons
displayed in the "real mode" again.
<h2>Default/Normal Mode</h2>
Use this option to convert a routed wire segment to its signal format, a polygon to its outline mode or remove a via
<h2>Connected Cooper Mode</h2>
Use this option to convert all the copper connected to the selected segment back to airwire form.
<h2>Connected Cooper on Same Layer Mode</h2>
Use this option to convert the selected routed trace to its signal format on the same layer.
<h2>Signal Mode</h2>
This option will convert all the traces that have the same name as the selected trace to unrouted signals.
<h2>Part to Part</h2>
Select two components to convert the traces shared between them into unrouted signals
<h2>Ripup All Polygons</h2>
Use this option to have all polygons return to outline mode
<h2>Ripup All Mode</h2>
This option is used to to convert all the traces on the design to a unrouted signal.


<a name=112>
<h1>ROTATE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Rotates objects.
<dt>
<b>Syntax</b>
<dd>
<tt>ROTATE orientation &#149; ..</tt><br>
<tt>ROTATE orientation 'name' ..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Right</mb> rotates the group.<br>
<mb>Left&amp;Drag</mb> rotates the object by any angle.<br>
<mb>Ctrl+Right&amp;Drag</mb> rotates the group by any angle.
</dl>
<b>See also</b> <a href=#31>ADD</a>,
<a href=#80>MIRROR</a>,
<a href=#83>MOVE</a>,
<a href=#74>LOCK</a>,
<a href=#62>GROUP</a>
<p>
The ROTATE command is used to change the orientation of objects.
<p>
If <tt>orientation</tt> (see description in <a href=#31>ADD</a>) is given,
that value will be added to the orientation of the selected object instead.
<p>
Prepending <tt>orientation</tt> with the character <tt>'='</tt> causes the value
not to be added, but instead to be set absolutely.
<p>
Parts, pads, smds and pins can also be selected by their name,
which is especially useful if the object is outside the currently shown
window area.
For example
<p>
<pre>
ROTATE =MR90 IC1
</pre>
<p>
would set the orientation of element IC1 to MR90, regardless of its previous setting.
<p>
Attributes of parts can be selected by entering the concatenation of
part name and attribute name, as in <tt>R5&gt;VALUE</tt>.
<p>
The quotes around <tt>name</tt> are necessary to distinguish it from an orientation parameter as in
<p>
<pre>
ROTATE R45 'R1'
</pre>
They can be left away if the context is clear.
<p>
You can use Click&amp;Drag to rotate an object by any angle.
Just click on the object and move the mouse (with the mouse
button held down) away from the object. After having moved the mouse a
short distance, the object will start rotating. Move the mouse until the
desired angle has been reached and then release the mouse button. If, at
some point, you decide to rather not rotate the object, you can press the
ESCape key while still holding the mouse button pressed.
The same operation can be applied to a group by using the right mouse button.
The group will be rotated around the point where the right mouse button has
been pressed down.
<p>
Parts cannot be rotated if they are <a href=#74>locked</a>,
or if any of their connected pads would extend outside the allowed area
(in case you are using a <a href=#409>limited edition</a> of EAGLE).
<h2>Elements</h2>
When rotating an element, wires (tracks) connected to the element are
moved at the connection points (beware of short circuits!).
<p>
Elements can only be rotated if the appropriate tOrigins/bOrigins
layer is visible.
<h2>Text</h2>
Text is always displayed so that it can be read from the bottom
or from the right - even when rotated. Therefore after every
two rotations it appears the same way, but the origin has moved from
the lower left to the upper right corner. Remember this if a text
appears to be unselectable!
<p>
If you want to have text that is printed "upside down", you can set the "Spin"
flag for that text.


<a name=113>
<h1>ROUTE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Converts unrouted connections into routed wires (tracks).
<dt>
<b>Syntax</b>
<dd>
<tt>ROUTE [width] &#149; [curve | @radius] &#149;..</tt><br>
<tt>ROUTE name ..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Left</mb> starts routing from any given point along a pad, via, wire, or airwire -OR- commits currently displayed intermediate route segments (and via, if layer changed).<br>
<mb>Shift+Left</mb> starts routing with the same width as an existing wire -OR- places a via and continues routing on the same layer.<br>
<mb>Center</mb> selects the next routing layer (and initiates via placement).<br>
<mb>Shift+Center</mb> presents start layer selection dialog when starting from a multi-layer object.<br>
<mb>Right</mb> cycles to the next wire bend style (see <a href=#116>SET Wire_Bend</a>).<br>
<mb>Shift+Right</mb> cycles to the previous wire bend style.<br>
<mb>Ctrl+Right</mb> toggles left/right direction of corresponding bend styles.<br>
<mb>Ctrl+Left</mb> defines arc radius (when placing a wire end point).
<dt>
<b>Keyboard</b>
<dd>
<mb>Enter</mb> commits current cursor position and auto-completes route to airwire anchor object.<br>
<mb>Space</mb> cycles to the next routing layer (and initiates via placement).<br>
<mb>Shift+Space</mb> cycles to the previous routing layer (and initiates via placement).<br>
<mb>Backspace</mb> (delete on MacOS) removes the effect of the most recent left mouse commit.<br>
<mb>Ctrl+Space</mb> cycles the start layer forward when starting from a multi-layer object.<br>
<mb>Ctrl+Shift+Space</mb> cycles the start layer in reverse when starting from a multi-layer object.<br>
</dl>
<p>
<b>See also</b> <a href=#37>AUTO</a>,
<a href=#58>FANOUT</a>,
<a href=#133>UNDO</a>,
<a href=#73>LINE</a>,
<a href=#81>MITER</a>,
<a href=#118>SIGNAL</a>,
<a href=#116>SET</a>,
<a href=#104>RATSNEST</a>
<p>
The ROUTE command activates the manual router which allows you to
convert airwires (unrouted connections) into real wires.
<p>
Select a signal object (pad, via, wire, or airwire) to begin routing.  When your
selection point lies on co-located objects, the ROUTE command resolves ambiguity
by selecting an object using the following priority:
<ul>
<li>Through-hole pad or current route layer SMD or via.
<li>Current route layer wire
<li>Airwire
<li>Non-current route layer SMD pad or via
<li>Non-current route layer wire
</ul>
When you select an airwire (a connection on the Unrouted layer), routing begins at the
signal object connected to the airwire that is closest to your selection point.
Otherwise, the ROUTE command automatically creates a new airwire from your selected
route start point to a nearby target object that is a member of the same signal.
Once you begin routing, intermediate routed wires automatically track according to
your movements of the mouse (see also <a href=#73>LINE</a>).  As you drag
intermediate wires around, remember that the Right mouse button cycles through the wire
bend styles, and the center mouse button changes the layer.  Note that only those signal
layers (1 through 16) are available that have been entered into the layer setup in
the <a href=#168>Design Rules</a>.
<p>
Use left mouse button as you reach each location on the design layout where you would
like to commit the intermediate (dragged) wires.  This places the wires, and begins a
new routed segment from that location.
<p>
As you proceed through the process of routing wires, you can also initiate layer changes
using the center mouse button, the Space key, and Shift+Space keys.  A layer change
automatically produces a via that drags at the end of the intermediate routes, at the
cursor location.  When you use the left mouse button to commit the routes (and the via
location), then the new route segments commence on the newly targeted layer from the
via location.  Incidentally, you can force placement of a via without changing layers,
by combining a left mouse with the Shift key.
<p>
When the ROUTE command creates and places a via, it uses the minimum layer span necessary
to traverse between layers (according to existing design conditions and the layer setup
in the <a href=#168>Design Rules</a>).  If the routed sequence begins or ends
at an SMD pad, and a via is required at that location to immediately traverse to the neighboring
layer, then a <i>micro via</i> will be used (if micro vias have been enabled in the
<a href=#168>Design Rules</a>).
<p>
While the ROUTE command is active you can enter the desired wire width
from the keyboard.
<p>
If the <i>curve</i> or <i>@radius</i> parameter is given, an arc can be drawn as part of the track
(see the detailed description in the <a href=#73>LINE</a> command).
<p>
If you provide a <tt>name</tt> in the command, the airwire of that signal that is
closest to the mouse cursor is selected. If <tt>name</tt> could be interpreted
as a <i>width</i>, <i>curve</i> or <i>@radius</i> then you should enclose it in
single quotes.
<h2>Single Layer Mode</h2>
With single layer mode active in routing mode, all layers except for the active one
are greyed out, creating a more focused environment to do some actual work.<p>
<pre>
SET SINGLE_LAYER_MODE ON | OFF;
</pre>
<h2>Interactive Routing Modes</h2>
Three interactive routing modes are available, each having its own separate behavior
when your dragged wires encounter obstacles during routing: Ignore Obstacles, Walkaround
Obstacles, and Push Obstacles. Change the current interactive routing mode by selecting
the Obstacle Avoidance option icons that appear on the parameter toolbar when the ROUTE
command is active. The default setting is Walkaround Obstacles.
<p>
<b>Ignore Obstacles (SET OBSTACLE_MODE IGNORE)</b>
<p>
Ignore Obstacles allows you to place wires and vias at any location on the design
layout, regardless of the Design Rules. When routing wires in Ignore Obstacles mode,
you must be careful not to create shorts between your routed signal and nearby ones.
<p>
<b>Walkaround Obstacles (SET OBSTACLE_MODE WALKAROUND)</b>
<p>
Walkaround Obstacles allows you to place wires and vias while automatically complying
with the Design Rules. The command identifies obstacles that lie in the path of your
routed wires, and automatically contours around them. When you change layers in
Walkaround Obstacles mode and via placement is required, the command automatically
finds the nearest valid via placement location (again, in compliance with the Design
Rules).
<p>
<b>Push Obstacles (SET OBSTACLE_MODE PUSH)</b>
<p>
Push Obstacles automatically complies with the Design Rules and pushes movable
obstacles aside to make room for your routed wires. When you change layers in Push
Obstacles mode, the command also pushes movable objects aside to provide clearance
around the via.
<p>
When you are using Walkaround Obstacles or Push Obstacles mode in areas of your
board design that are congested with many pre-routed objects, you will occasionally
encounter conditions where the ROUTE command cannot achieve a routing solution to
your cursor location. In this case, a route failure indicator appears at the end
of your routed wire to inform you that the route failed to complete to the requested
location.
<h2>Semi-automatic (Quick) Routing Modes</h2>
Several semi-automatic routing modes are available, each of which automatically
complies with the Design Rules, including clearance, route width, via size, and
diff-pair gap. The semi-automatic routing modes are: Quick Route Airwire, Quick Route
Signal, Quick Route Multi-Signals, and Smooth Signal. Each of these modes is provided
for the purpose of producing the indicated instant and complete result when you select
one or more signal member objects in your design.  If any of your selected signals are
one side of a differential pair, then the command automatically routes both differential
pair signals together. If the ROUTE command in any of these modes cannot successfully
complete the route for an airwire, then an audible beep indicates the failure. You can
change the semi-automatic routing mode by selecting icons that appear on the parameter
toolbar when the ROUTE command is active.
<p>
<b>Quick Route Airwire (SET ROUTE_MODE QUICK_ROUTE_AIRWIRE)</b>
<p>
In Quick Route Airwire mode, you select individual airwires that you wish to be
automatically routed, and the ROUTE command instantly routes them. You can also select
an existing wire, pad, or via in the design, and if the command can determine an
unambiguous nearby airwire then it will route that.
<p>
<b>Quick Route Signal (SET ROUTE_MODE QUICK_ROUTE_SIGNAL)</b>
<p>
In Quick Route Signal mode, you select any signal object (airwire, wire, pad, or via),
and the ROUTE command instantly routes all airwires that are members of that signal.
When the signal that you have selected is one side of a differential pair, then the
command automatically routes both differential pair signals together.
If no airwires are found, then the ROUTE command displays an error message.
<p>
<b>Quick Route Multi-Signals (SET ROUTE_MODE QUICK_ROUTE_MULTISIGNAL)</b>
<p>
In Quick Route Multi-Signals mode, you begin by drawing a selection line that intersects
through the signal objects that you wish to route concurrently (existing wires, pads, and
vias). Continue to draw additional selection lines to add more signal objects. Press the
ESC key if you need to clear the selection list and begin again. Press the enter key to
route all the airwires connected to the selected objects.
<p>
<b>Smooth Signal (SET ROUTE_MODE SIGNAL_CLEANUP)</b>
<p>
In Smooth Signal mode, you can select an existing routed signal wire, and the ROUTE
command smooths the wire sequence on the selected wire's layer by reducing the number of
wire bends in the sequence.
<p>
In Design Manager view, you can select one or more signal or airwire entries, and then
Right Click + Quick Route, to route their wires on the layer currently specified by the
ROUTE command.
<h2>Selecting the routing layer and wire width</h2>
When you select an airwire, the ROUTE command determines the initial layer in
which to route by considering the objects at the starting point, as follows:
<ul>
<li>If a start object exists on the current layer, then the current layer is used.
<li>Otherwise, the layer of an object at that point is used.
</ul>
<p>
When the start object of your route is a multi-layer pad or via, you can cycle the
routing start layer forward and backward, by pressing the <tt>Ctrl+Space</tt> and
<tt>Ctrl+Shift+Space</tt> keys, respectively.
<p>
When you select an airwire, the ROUTE command determines the wire width from the
the Design Rules and the net class of the selected signal, if the flag
"Options/Set/Misc/Auto set route width and drill" is set.  You can manually adjust
the width, and the intermidiate wires will appear with the new width.  This
behavior applies to via definitions when a layer change is involved, as well.
<p>
When you select an airwire for routing that starts at an existing wire, the
routed wire width will automatically initialize to the width of the existing wire,
if the <tt>Shift</tt> key is pressed when selecting the airwire.
<h2>Snap Function</h2>
Specifying a snap distance allows you to influence how the ROUTE command targets
same-signal objects that it should use as potential routing termination points.
The Snap Function comes into effect when you move the cursor within the snap radius
of the center of an object that is a target candidate for routing termination.  In
this condition, the cursor automatically snaps to that object's location, and an (X)
is displayed at the location as a visual indicator that a snap was achieved.
The ROUTE command automatically utilizes the snap distance independent of the
current grid setting.  Define the effective distance for this snap function with
the command
<pre>
SET SNAP_LENGTH distance;
</pre>
where the default unit for the "distance" snap radius is the current grid unit.
<h2>Undo Commit Sequence</h2>
If you make an errant mouse click or you wish to change your route path at any
time during the routing process, you can "undo" or "unwind" your routing.  Use the
Backspace key (delete key on MacOS) to perform sequential undo's of your left mouse
commits.  Via placements and layer changes are also undone by this process, as you
would expect.
<p>
NOTE: Backspace / delete keys are only operational within the ROUTE command when
the command window is empty of text.  Otherwise, Backspace / delete keys are processed
as normal by the command window.
<h2>Loop Removal</h2>
The Loop Remove mode allows you to re-route any portion of an existing path of routed
wires between two pads and automatically remove the redundant loop of wires (and
possibly vias).  The Loop Remove option consists of parameter buttons that appear
on the toolbar when the ROUTE command is active.
<p>
You can start your re-route at a pad, a via, a wire(s) vertex, or in the middle of a
wire, and terminate your re-route in the same fashion.  The default setting of the
Loop Remove mode is ON.  Beware that there are a few conditions required for Loop
Remove to operate properly:
<ul>
<li>The loop to be removed cannot incorporate a component pad.
<li>The existing routed wires cannot form a T-junction.
</ul>
<pre>
SET LOOP_REMOVAL ON | OFF;
</pre>
<h2>Switch to Opposite Airwire End Point</h2>
When routing an airwire, you can switch the active route to the opposite aiwire end point by pressing the
right-arrow key '?' (NOTE - the command edit box must be empty for the Route Command to recognize this
keystroke). If the opposite airwire end point is not within the window, then the window is automatically panned,
at the same zoom level, with the opposite airwire end point centered in the window. You may switch routing
ends of the airwire as many times as necessary while actively routing. NOTE - the use of the <backspace>
key will not "undo" the switching of the airwire endpoint.
<h2>Differential Pair routing</h2>
<i>Differential Pairs</i> are signals that need to be routed in parallel
and with a specific distance between them.
<p>
The following particularities apply:
<ul>
<li>A Differential Pair consists of two signals that have the same name, only
    one ending with <tt>_P</tt> (the "positive" signal) and the other one with
    <tt>_N</tt> (the "negative" signal), for instance <tt>CLOCK_P</tt> and <tt>CLOCK_N</tt>.
    The two signals must also belong to the same net class.
<li>When selecting an airwire of a Differential Pair, both signals are routed
    in parallel. The distance between the two signals as well as the wire and
    via sizes are determined by the signals' net class.
    This is done independent of the setting of "Options/Set/Misc/Auto set route width and drill".
<li>If you don't want to route both signals, you can press the ESCape key to
    drop the second airwire.
<li>At the beginning of routing a Differential Pair (when the starting points
    of the airwires don't have the necessary distance, yet) signal wires are
    generated from the starting points to the current mouse cursor position,
    according to the current wire bend style. Note that there may be cases where
    these wires overlap, so please make sure you choose a proper point from
    where to start the actual parallel routing.
<li>The coordinates given while routing a Differential Pair form a "center line"
    along which the actual signal wires are placed left and right with the
    proper distance.
<li>Since the pads a Differential Pair is connected to typically don't have the
    same distance as used for the signal wires, you may have to route such signals
    from both ends. This means, you start at one part, route towards the other
    part, and then route the rest starting from the other part. This is necessary
    because only the first step in a routing sequence generates wires that start
    at positions that don't have a proper distance.
<li>If you route towards the wire end points of a Differential Pair in a different
    layer, and the wires are fully aligned, the proper vias will be generated
    automatically.
<li>The special mouse key functions
    <mb>Shift+Left</mb> (place a via at the end point) and
    <mb>Ctrl+Left</mb> (define arc radius) don't work in Differential Pair mode.
<li>When you start routing at any point of a signal (with <mb>Ctrl+Left</mb>) you
    can only route the selected signal, and not the Differential Pair this signal
    might be part of.
<li>Differential Pairs can only be routed fully manually. The Follow-me router and
    the Autorouter treat them like regular signals.
</ul>
You can use the <a href=#78>MEANDER</a> command to balance the lengths
of the two signals that form a differential pair.
<p>
Snap Function, Undo Commit Sequence, and Loop Remove features are not currently
operational in Differential Pair routing mode.


<a name=114>
<h1>RUN</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Executes a <a href=#173>User Language</a> Program.
<dt>
<b>Syntax</b>
<dd>
<tt>RUN file_name [argument ...] </tt>
</dl>
<b>See also</b> <a href=#115>SCRIPT</a>
<p>
The RUN command starts the User Language Program from the file <tt>file_name</tt>.<br>
The optional <tt>argument</tt> list is available to the ULP through the
<a href=#286>Builtin Variables</a> <tt>argc</tt> and <tt>argv</tt>.
<p>
Started from a context menu the according object is assigned to a group.
It can be identified with the builtin function <a href=#346>ingroup()</a>
for further processing. In case of a wire the group bits are set according to it's selection state
(first, second or both endpoints). This allows to find which endpoint has been selected.
A previously defined group becomes invalid.
<h2>Running a ULP from a script file</h2>
If a ULP is executed from a script file and the program returns an integer value
other than <tt>0</tt> (either because it has been terminated through a
call to the <tt><a href=#306>exit()</a></tt> function or because
the STOP button was clicked), execution of the script file will be terminated.
<h2>Editor commands resulting from running a ULP</h2>
A ULP can also use the <tt><a href=#306>exit()</a></tt> function with a <tt>string</tt>
parameter to send a command string back to the editor window.


<a name=115>
<h1>SCRIPT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Executes a command file.
<dt>
<b>Syntax</b>
<dd>
<tt>SCRIPT file_name;</tt>
</dl>
<b>See also</b> <a href=#116>SET</a>,
<a href=#79>MENU</a>,
<a href=#35>ASSIGN</a>,
<a href=#57>EXPORT</a>,
<a href=#114>RUN</a>
<p>
The SCRIPT command is used to execute sequences of commands that are
stored in a script file. If SCRIPT is typed in at the keyboard and "file_name"
has no extension, the program automatically uses ".scr".
<h2>Examples</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SCRIPT nofill</tt>     </td><td width=20><td>executes nofill.scr</td></tr>
<tr><td><tt>SCRIPT myscr.</tt>     </td><td width=20><td>executes myscr (no Suffix)</td></tr>
<tr><td><tt>SCRIPT myscr.old</tt>  </td><td width=20><td>executes myscr.old</td></tr>
</table>
<p>
Please refer to the EXPORT command for different possibilities
of script files.
<p>
If the SCRIPT command is selected with the mouse, a popup menu will
show all of the files which have the extension ".scr" so that
they can be selected and executed.
<p>
The SCRIPT command provides the ability to customize
the program according to your own wishes. For instance:
<ul>
<li>change the command menu
<li>assign keys
<li>load pc board shapes
<li>change colors
</ul>
SCRIPT files contain EAGLE commands according to the syntax rules.
Lines beginning with <tt>'#'</tt> are comment.
<h2>Continued Lines</h2>
SCRIPT files contain one or more commands in every line according
to the syntax rules. The character '\' at the end of a command line ensures
that the first word of the next line is not interpreted as a command.
This feature allows you to avoid apostrophes in many cases.
<h2>Set Default Parameters</h2>
The SCRIPT file eagle.scr - if it exists in the project
directory or in the <a href=#15>script path</a> - is executed each time
a new drawing is loaded into an editor window (or when the drawing type is changed
in a library).<p>
<h2>Script Labels</h2>
The default SCRIPT file eagle.scr makes use of labels of the form <p>
<tt>EDITOR:</tt><p>
where EDITOR is one of SCH, BRD, LBR, DEV, PAC and SYM. This ensures that only the appropriate
section is executed in the editor. For example, when a new board is opened, only the section
starting with <tt>BRD:</tt> is executed (until the next label if any). This also offers the
possibility for editor specific menus using the <a href=#79>MENU</a> command.
The label must be at the line beginning.
<h2>Execute Script Files in the Library Editor</h2>
All of the layers are recognized only if the library editor has previously been loaded.


<a name=116>
<h1>SET</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Alters system parameters
<dt>
<b>Syntax</b>
<dd>
<tt>SET</tt><br>
<tt>SET options;</tt>
</dl>
Parameters which affect the behavior of the program, the screen display, or the user interface can be specified with the SET command. The precise syntax is described below.
<p>
A dialog in which all the parameters can be set appears if the SET command is entered without parameters.
<h2>User Interface</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Snap function            </td><td width=20><td><tt>SET SNAP_LENGTH number;</tt></td></tr>
<tr><td>                         </td><td width=20><td>This sets the limiting value for the snap function in the <a href=#113>ROUTE</a> command (using the current unit). It's also used for snapping nets to pins in the <a href="#85">NET</a> command.</td></tr>
<tr><td>                         </td><td width=20><td>Default: 20 mil</td></tr>
<tr><td>                         </td><td width=20><td>If tracks are being laid with the <a href=#113>ROUTE</a> command to pads that are not on the grid, the snap function will ensure that a route will be laid to the pad within the snap-length.</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET CATCH_FACTOR value;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Defines the distance from the cursor up to which objects are taken into account when clicking with the mouse. The value is entered relative to the height (or width, whichever is smaller) of the presently visible part of the drawing. It applies to a zoom level that displays at least a range of 4 inch and inrceases logarithmically when zooming further in. A value of 0 turns this limitation off.
                                          Values &lt; 1 are interpreted as factor, values &ge; 1 as percents. <br>Default: 0.05 (5%).</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET SELECT_FACTOR value;</tt></td></tr>
<tr><td>                         </td><td width=20><td>This setting controls the distance from the cursor within which nearby objects will be suggested for <a href=#22>selection</a>. The value is entered relative to the height (or width, whichever is smaller) of the presently visible part of the drawing.
                                          Values &lt; 1 are interpreted as factor, values &ge; 1 as percents. <br>Default: 0.02 (2%).</td></tr>
<tr><td>Menu contents            </td><td width=20><td><tt>SET USED_LAYERS name | number;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Specifies the layers which will be shown in the associated EAGLE menus. See the example file <tt>mylayers.scr</tt>.</td></tr>
<tr><td>                         </td><td width=20><td>The layers Pads, Vias, Unrouted, Dimension, Drills and Holes will in any case remain in the menu, as will the schematic layers. Any used signal layers also remain in the menus. <tt>SET Used_Layers All</tt> activates all layers.</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET WIDTH_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DIAMETER_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DRILL_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET SMD_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET SIZE_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET ISOLATE_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET SPACING_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET MITER_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DLINE_WIDTH_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DLINE_EXT_WIDTH_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DLINE_EXT_LENGTH_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td><tt>SET DLINE_EXT_OFFSET_MENU value..;</tt></td></tr>
<tr><td>                         </td><td width=20><td>The content of the associated popup menus can be configured with the above command for the parameters <i>width</i> etc.. A maximum of 16 values is possible for each menu (16 value-pairs in the SMD menu). Without any values (as in <tt>SET WIDTH_MENU;</tt>) the program default values will be restored.</td></tr>
<tr><td>                         </td><td width=20><td>Example:<br><tt>Grid Inch;</tt><br><tt>Set Width_Menu 0.1 0.2 0.3;</tt></td></tr>
<tr><td>Context menus            </td><td width=20><td><tt>SET CONTEXT objecttype text commands;</tt></td></tr>
<tr><td>                         </td><td width=20><td>For selectable object types context menus (right mouse button) can be extended
                                          by arbitrary entries. <i>objecttype</i> is not case sensitive. <i>text</i> is the
                                          menu text, <i>commands</i> is the command sequence, that is executed after click
                                          on the menu entry. Empty spaces are possible if the expression is set into apostrophs.
                                          apostrophs inside have to be doubled (see <a href=#131>TEXT</a>).
                                          Example:</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET CONTEXT Element Export 'run myexport.ulp';</tt></td></tr>
<tr><td>                         </td><td width=20><td>To the context menu for elements the entry <i>Export</i> is added, which starts an according ULP.</td></tr>
<tr><td>                         </td><td width=20><td>An existing userdefined entry can also be overwritten.</td></tr>
<tr><td>                         </td><td width=20><td>The settings are stored in the eaglerc file. The number of entries is unlimited.</td></tr>
<tr><td>                         </td><td width=20><td>Deletion of entries: </td></tr>
<tr><td>                         </td><td width=20><td><tt>SET CONTEXT objecttype;</tt> deletes all entries for this object type. With <tt>SET CONTEXT;</tt> all user defined menu entries are deleted.</td></tr>
<tr><td>                         </td><td width=20><td>All selectable object types are supported. These are attribute, circle, dimension, element,
                                          frame, gate, hole, instance, junction, label, modinst (module instance), pad, pin, rectangle, smd, text, via and wire.</td></tr>
<tr><td>                         </td><td width=20><td><i>Restriction note on ULP execution:</i></td></tr>
<tr><td>                         </td><td width=20><td>In order to have the selected object available for function <a href=#346>ingroup()</a> please avoid setting the ';' within the apostrophs
                                          (i.e. not <tt>'run myexport.ulp;'</tt>, but <tt>'run myexport.ulp'</tt>).</td></tr>
<tr><td>Bend angle for wires and lines</td><td width=20><td><tt>SET WIRE_BEND bend_nr;</tt></td></tr>
<tr><td>                         </td><td width=20><td><i>bend_nr</i> can be one of:</td></tr>
<tr><td>                         </td><td width=20><td><tt>0</tt>: Starting point - horizontal - vertical - end</td></tr>
<tr><td>                         </td><td width=20><td><tt>1</tt>: Starting point - horizontal - 45&deg; - end</td></tr>
<tr><td>                         </td><td width=20><td><tt>2</tt>: Starting point - end (straight connection)</td></tr>
<tr><td>                         </td><td width=20><td><tt>3</tt>: Starting point - 45&deg; - horizontal - end</td></tr>
<tr><td>                         </td><td width=20><td><tt>4</tt>: Starting point - vertical - horizontal - end</td></tr>
<tr><td>                         </td><td width=20><td><tt>5</tt>: Starting point - arc - horizontal - end</td></tr>
<tr><td>                         </td><td width=20><td><tt>6</tt>: Starting point - horizontal - arc - end</td></tr>
<tr><td>                         </td><td width=20><td><tt>7</tt>: "Freehand" (arc that fits to wire at start, straight otherwise)</td></tr>
<tr><td>                         </td><td width=20><td><tt>8</tt>: Route short end of airwire in <a href=#113>Follow-me router</a></td></tr>
<tr><td>                         </td><td width=20><td><tt>9</tt>: Route both ends of airwire in <a href=#113>Follow-me router</a></td></tr>
<tr><td>                         </td><td width=20><td>Note that <tt>0</tt>, <tt>1</tt>, <tt>3</tt> and <tt>4</tt> may contain additional miter wires (see <a href=#81>MITER</a>).</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET WIRE_BEND @ bend_nr ...;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Defines the bend angles that shall be actually used when switching with the right mouse button.</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET WIRE_BEND @;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Switches back to using all bend angles.</td></tr>
<tr><td>Beep on/off              </td><td width=20><td><tt>SET BEEP OFF | ON;</tt></td></tr>
</table>
<h2>Screen display</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Color for grid lines</td><td width=20><td><tt>SET COLOR_GRID color;</tt></td></tr>
<tr><td>Layer color              </td><td width=20><td><tt>SET COLOR_LAYER layer color;</tt></td></tr>
<tr><td>Fill pattern for layer   </td><td width=20><td><tt>SET FILL_LAYER layer fill;</tt></td></tr>
<tr><td>Grid parameters          </td><td width=20><td><tt>SET MIN_GRID_SIZE pixels;</tt></td></tr>
<tr><td>                         </td><td width=20><td>The grid is only displayed if the grid size is greater than the set number of pixels.</td></tr>
<tr><td>Min. text size shown     </td><td width=20><td><tt>SET MIN_TEXT_SIZE size;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Text less than <tt>size</tt> pixels high is shown as a rectangle on the screen. The setting <tt>0</tt> means that all text will be displayed readably.</td></tr>
<tr><td>Net wire display         </td><td width=20><td><tt>SET NET_WIRE_WIDTH width;</tt></td></tr>
<tr><td>Pad display              </td><td width=20><td><tt>SET DISPLAY_MODE REAL | NODRILL;</tt></td></tr>
<tr><td>                         </td><td width=20><td>REAL: Pads are displayed as they will be plotted.<br>NODRILL: Pads are shown without drill hole.</td></tr>
<tr><td>                         </td><td width=20><td><tt>SET PAD_NAMES OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Pad names are displayed/not displayed.</td></tr>
<tr><td>Bus line display         </td><td width=20><td><tt>SET BUS_WIRE_WIDTH width;</tt></td></tr>
<tr><td><a href=#53>DRC</a>-Parameter </td><td width=20><td><tt>SET DRC_FILL fill_name;</tt></td></tr>
<tr><td>Polygon calculation      </td><td width=20><td><tt>SET POLYGON_RATSNEST OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>See <a href=#98>POLYGON</a> command.</td></tr>
<tr><td>Vector font              </td><td width=20><td><tt>SET VECTOR_FONT OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>See <a href=#131>TEXT</a> command.</td></tr>
<tr><td>Cross-reference labels   </td><td width=20><td><tt>SET XREF_LABEL_FORMAT string;</tt></td></tr>
<tr><td>                         </td><td width=20><td>See <a href=#68>LABEL</a> command.</td></tr>
<tr><td>Part cross-references    </td><td width=20><td><tt>SET XREF_PART_FORMAT string;</tt></td></tr>
<tr><td>                         </td><td width=20><td>See <a href=#131>TEXT</a> command.</td></tr>
</table>
<h2>Mode parameters</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Package check            </td><td width=20><td><tt>SET CHECK_CONNECTS OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>The <a href=#31>ADD</a> command checks whether every pin has been connected to a pad (with <a href=#46>CONNECT</a>). This check can be switched off. Nevertheless, no board can be generated from a schematic if a device is found which does not have a package.</td></tr>
<tr><td><a href=#110>REPLACE</a> mode </td><td width=20><td><tt>SET REPLACE_SAME NAMES | COORDS;</tt></td></tr>
<tr><td><a href=#133>UNDO</a> buffer on/off </td><td width=20><td><tt>SET UNDO_LOG OFF | ON;</tt></td></tr>
<tr><td>Wire/Line optimizing     </td><td width=20><td><tt>SET OPTIMIZING OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>If set <i>on</i>, wires/lines which lie collinear after a MOVE, ROUTE or SPLIT are subsumed into a single wire/line. See also <a href=#87>OPTIMIZE</a>.</td></tr>
<tr><td>Net wire termination     </td><td width=20><td><tt>SET AUTO_END_NET OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Automatic ending of nets or busses. See <a href=#85>NET</a> or <a href=#39>BUS</a>.</td></tr>
<tr><td>Automatic junctions      </td><td width=20><td><tt>SET AUTO_JUNCTION OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Automatic setting of junctions. See <a href=#67>JUNCTION</a>.</td></tr>
<tr><td>Automatic confirmation   </td><td width=20><td><tt>SET CONFIRM OFF | NO | YES | OPT1 | OPT2 | OPT3 | OPT4 | OPT5 | OPT6 | OPT7 | OPT8 | OPT9;</tt></td></tr>
<tr><td>                         </td><td width=20><td>Allows confirmation dialogs to be handled automatically (see below for details).</td></tr>
<tr><td>File locking             </td><td width=20><td><tt>SET LOCKING OFF | ON;</tt></td></tr>
<tr><td>                         </td><td width=20><td>To deactivate or activate File locking. The setting takes effect immediately, so locks of currently open files are deleted resp. created. See <a href=#405>File Locking</a> for further details.</td></tr>
</table>
<h2>Colors</h2>
There are three <i>palettes</i> for black, white and colored background,
respectively. Each palette has 64 color entries, which can be set to any
ARGB value. The palette entry number 0 is used as the background color
(in the "white" palette this entry cannot be modified, since this palette
will also be used for printing, where the background is always white).
<p>
The color palettes can be modified either through the dialog under
"Options/Set.../Colors" or by using the command
<pre>
SET PALETTE <i>index</i> <i>argb</i>
</pre>
where <i>index</i> is a number in the range 0..63 and <i>argb</i> is a hexadecimal
value defining the Alpha, Red, Green and Blue components of the color, like 0xFFFFFF00
(which would result in a bright yellow). The alpha component defines how "opaque"
the color is. A value of 0x00 means it is completely transparent (i.e. invisible),
while 0xFF means it is totally opaque.
The alpha component of the background color is always 0xFF.
Note that the ARGB value must begin with "0x", otherwise it would be taken as a
decimal number. You can use
<pre>
SET PALETTE BLACK|WHITE|COLORED
</pre>
to switch to the black, white or colored background palette, respectively.
Note that there will be no automatic window refresh after this command, so
you should do a WINDOW; command after this.
<p>
By default only the palette entries 0..15 are used and they contain the
colors listed below.
<p>
The palette entries are grouped into "normal" and "highlight" colors. There
are always 8 "normal" colors, followed by the corresponding 8 "highlight"
colors. So colors 0..7 are "normal" colors, 8..15 are their "highlight"
values, 16..23 are another 8 "normal" colors with 24..31 being their
"highlight" values and so on. The "highlight" colors are used to visualize
objects, for instance in the SHOW command.
<p>
<tt>Color</tt>, listed according to color numbers, which can be used instead of the color names. Used to specify colors:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>0       </td><td width=20><td>Black</td></tr>
<tr><td>1       </td><td width=20><td>Blue</td></tr>
<tr><td>2       </td><td width=20><td>Green</td></tr>
<tr><td>3       </td><td width=20><td>Cyan</td></tr>
<tr><td>4       </td><td width=20><td>Red</td></tr>
<tr><td>5       </td><td width=20><td>Magenta</td></tr>
<tr><td>6       </td><td width=20><td>Brown</td></tr>
<tr><td>7       </td><td width=20><td>LGray</td></tr>
<tr><td>8       </td><td width=20><td>DGray</td></tr>
<tr><td>9       </td><td width=20><td>LBlue</td></tr>
<tr><td>10      </td><td width=20><td>LGreen</td></tr>
<tr><td>11      </td><td width=20><td>LCyan</td></tr>
<tr><td>12      </td><td width=20><td>LRed</td></tr>
<tr><td>13      </td><td width=20><td>LMagenta</td></tr>
<tr><td>14      </td><td width=20><td>Yellow</td></tr>
<tr><td>15      </td><td width=20><td>White</td></tr>
</table>
<p>
<tt>Fill</tt> specifies the style with which wires and rectangles in a particular layer are to be filled. This parameter can also be replaced with the number at the beginning of each line:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>0       </td><td width=20><td>Empty</td></tr>
<tr><td>1       </td><td width=20><td>Solid</td></tr>
<tr><td>2       </td><td width=20><td>Line</td></tr>
<tr><td>3       </td><td width=20><td>LtSlash</td></tr>
<tr><td>4       </td><td width=20><td>Slash</td></tr>
<tr><td>5       </td><td width=20><td>BkSlash</td></tr>
<tr><td>6       </td><td width=20><td>LtBkSlash</td></tr>
<tr><td>7       </td><td width=20><td>Hatch</td></tr>
<tr><td>8       </td><td width=20><td>XHatch</td></tr>
<tr><td>9       </td><td width=20><td>Interleave</td></tr>
<tr><td>10      </td><td width=20><td>WideDot</td></tr>
<tr><td>11      </td><td width=20><td>CloseDot</td></tr>
<tr><td>12      </td><td width=20><td>Stipple1</td></tr>
<tr><td>13      </td><td width=20><td>Stipple2</td></tr>
<tr><td>14      </td><td width=20><td>Stipple3</td></tr>
<tr><td>15      </td><td width=20><td>Stipple4</td></tr>
</table>
<h2>Automatic Confirmation</h2>
At times EAGLE prompts the user with informational or warning messages,
or requires a decision on how to proceed. This may be unwanted in automated
processes (like <a href=#115>script files</a>).
The command
<pre>
SET CONFIRM YES
</pre>
will automatically confirm every message dialog as if the user had clicked on
the "positive" button ("OK" or "Yes"). The dialog itself isn't even presented
to the user.
Similarly, the command
<pre>
SET CONFIRM NO
</pre>
acts as if the user had clicked on the "negative" button ("No"), if such a button
is present. Otherwise it just confirms the dialog.
<p>
There are the key words OPT1..9 to confirm dialogs with additional options
(e.g. renaming a net segment or a signal polygon).
<pre>
SET CONFIRM OPT2
NAME GND (x y)
</pre>
Finally, the command
<pre>
SET CONFIRM OFF
</pre>
turns off automatic confirmation. If automatic confirmation is not turned off
explicitly, it will automatically fall back to <tt>OFF</tt> the next time the
editor window accepts some interactive input from the user.
<p>
You should not put a <tt>SET CONFIRM YES</tt> at the beginning of a script
and then execute lots of commands "silently". It is better to explicitly
put this around individual commands, as in
<pre>
SET CONFIRM YES
REMOVE <i>filename</i>
SET CONFIRM OFF
</pre>
<b>Be extremely careful when using this command! Blindly confirming message
dialogs may cause important messages to be overlooked. The result may then
not be what the user expected.</b>
<h2>Board Limits (only Make Pro Edition)</h2>
The Make Pro Edition has a limited board area but allows variable width
and height (see <a href=#409>EAGLE Editions</a>). In order to adjust these limits, the commands
<pre>
SET LIC_WIDTH<i>width</i>
SET LIC_HEIGHT<i>height</i>
</pre>
can be used. If width is set, then height adjusts accordingly and vice versa.
<h2>EagleRc Parameters</h2>
Sometimes a small detail of functionality needs to be made adjustable, for
instance because some users absolutely need to have it work differently.
These parameters are not available in any dialogs, but can only be changed
through an entry in the eaglerc file. In order to make this easier, any
parameter that is not found among the keywords listed above will be looked
up in the eaglerc parameters and can thus be changed using the SET command.
Principally all parameters from eaglerc file can be changed this way.
Note that the parameter names must be written in full and exactly as
listed below (case sensitive). The parameter value is typically '0' or '1',
to turn the functionality 'off' or 'on', respectively. After changing any
of these parameters that influence the way the screen display is drawn, a
window refresh may be necessary.
<p>
<b>Example</b>
<pre>
SET Option.DrawUnprocessedPolygonEdgesContinuous 1;
</pre>
The following eaglerc parameters have been created for special adjustments:
<p>
<dl>
<dt><b>Cmd.Copy.ClassicEagleMode</b>
<dd>
In older versions of EAGLE the COPY command was used solely to copy objects
within a drawing, as opposed to the Windows behavior, where COPY places a
copy of the selected objects (i.e. the GROUP) into the system's clipboard.
As of version 6, EAGLE's COPY command primarily behaves the same way as
in other Windows applications, by putting a copy of the current group
into the clipboard. The original functionality of copying selected objects,
or copying library objects between libraries, is still fully available,
which is especially important to keep existing scripts and ULPs working.
What has also often irritated Windows users is that in EAGLE the CUT
command has only copied the current group to the clipboard, but did not
actually delete the group from the drawing. Since a CUT command that deletes
the group would not be of much use in a board/schematic pair that is connected
via forward-&amp;backannotation, the CUT command has been removed from the
main pulldown menu and the command button toolbar. It is still fully available
from the command line or within scripts.
Setting this parameter to '1' restores the old behavior of both the COPY
and the CUT command. Note that this setting only takes effect the next time
you open an editor window.
<dt><b>Cmd.Delete.WireJointsWithoutCtrl</b>
<dd>
If you insist on having the DELETE command delete wire joints
without pressing the Ctrl key, you can set this parameter to '1'.
<dt><b>Cmd.Name.RenameEntireNetByDefault</b>
<dd>
If a net consists of more than one segment, the NAME command by default acts only
upon the selected segment. By setting this parameter to '1' this can be changed
to rename the entire net by default.
This parameter also applies to busses.
<dt><b>Cmd.Name.RenameEntireSignalByDefault</b>
<dd>
If a signal contains a polygon, and the NAME command is applied to that polygon,
by default only the polygon gets renamed. Setting this parameter to '1' makes
the NAME command act upon the entire signal by default.
<dt><b>Cmd.Wire.IgnoreCtrlForRadiusMode</b>
<dd>
If you don't like the special mode in wire drawing commands that allows
for the definition of an arc radius by pressing the Ctrl key when placing
the wire, you can set this parameter to '1'.
This will turn this feature off for all commands that draw wires.
<dt><b>ControlPanel.View.AutoOpenProjectFolder</b>
<dd>
The automatic opening of the project folder at program start (or when
activating a project by clicking on its gray button) can be disabled
by setting this parameter to '0'.
<dt><b>Erc.AllowUserOverrideConsistencyCheck</b>
<dd>
In order to handle board/schematic pairs that have only minor inconsistencies,
the user can enable a dialog that allows him to force the editor to
perform forward-/backannotation, even if the ERC detects that the files are
inconsistent. This can be done by setting this parameter to '1'.
<b>PLEASE NOTE THAT YOU ARE DOING THIS AT YOUR OWN RISK</b> - if the files get
corrupted in the process, there may be nothing anybody can do to recover
them. After all, the ERC <b>did</b> state that the files were inconsistent!
<dt><b>Interface.MouseButtonReleaseTimeout</b>
<dd>
The time (in milliseconds) within which a mouse button release that follows
a mouse button press on a button (like, for instance, toolbar buttons)
triggers the button's action, even if the mouse button release happened
outside the button's area. Default is 500, set this to 0 to turn off this
feature. If this parameter is 0 when the program is started, any change
to it will only take effect the next time the program is started.
<dt><b>Interface.PreferredUnit</b>
<dd>
When displaying a numerical value in dialog input fields, the units are determined
automatically, so that the representation with the least number of decimal
digits is chosen. This can be controlled by setting this parameter to
'0' for automatic unit determination (default),
'1' for imperial units, and
'2' for metric units.
<dt><b>Interface.UseCtrlForPanning</b>
<dd>
Panning is done by moving the mouse while holding the center mouse button
(or mouse wheel) down. In older versions this was done by pressing the Ctrl
key instead. If you want the old functionality back, you can set this
parameter to '1'.
Note, though, that the Ctrl key is now used for special functions in some
commands, so when using these special functions (like selecting an object
at its origin in MOVE) with this parameter enabled you may inadvertently
pan your draw window.
<dt><b>Interface.VectorFont</b>
<dd>
Always displays texts in drawings with the builtin vector font, regardless of
which font is actually set for a particular text and regardless of the setting
<tt><a href=#116>SET</a> VECTOR_FONT OFF|ON</tt>
in the current drawing. See <a href=#131>TEXT</a> command.
<dt><b>Option.AutoLoadMatchingDrawingFile</b>
<dd>
If you have a board and schematic editor window open and load an other board
(or schematic) in one of these windows, and if that other drawing has a matching
schematic (or board), EAGLE asks whether that other drawing shall also be loaded.
By setting this parameter to '1', this query can be suppressed, and EAGLE will
always automatically load the other drawing.
<dt><b>Option.DrawUnprocessedPolygonEdgesContinuous</b>
<dd>
If you don't like the way unprocessed polygons display their edges (as dotted lines),
you can set this parameter to '1'. The edges of unprocessed polygons will then be
displayed as continuous lines, as was the case before version 5 (however, they will
not be highlighted).
<dt><b>Option.LayerSequence</b>
<dd>
The internal layers are rendered in a sequence that mimics the actual layer
stack, so that the result looks useful even on printers and PDF or Postscript
files, where layers are not transparent. Sometimes user defined layers may need to
be rendered before internal layers instead of after them. This parameter can be
used to define the sequence in which layers are rendered. It consists of a string of
layer numbers or layer ranges, followed by an optional 't' or 'b'.
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>123</td> <td width=20><td>renders layer 123</td></tr>
<tr><td>123t</td><td width=20><td>renders layer 123 if the output is "viewed from top" (not mirrored)</td></tr>
<tr><td>123b</td><td width=20><td>renders layer 123 if the output is "viewed from bottom" (mirrored)</td></tr>
<tr><td>123-140</td><td width=20><td>renders layers 123 through 140 in the given sequence</td></tr>
<tr><td>140-123</td><td width=20><td>renders layers 140 through 123 in the given sequence</td></tr>
<tr><td>*</td><td width=20><td>inserts the default sequence of the internal layers</td></tr>
<tr><td>123b * 123t</td><td width=20><td>makes layer 123 always be rendered first</td></tr>
</table>
<dd>
Note that each layer is rendered only once, even if it is listed several times.
The default sequence of the internal layers is<br>
48t 49t 19t 47t 20t 46t 23 27 25 59 57 55 53 50 51 21 44t 45t 37 35 31 29 33 39 41 43t 18t 17t 1-16 17b 18b 43b 42 40 34 30 32 36 38 45b 44b 22 52 54 56 58 60 26 28 24 46b 20b 47b 19b 49b 48b 61-99.<br>
When viewed from top, the layer sequence is rendered from right to left, while
when viewed from bottom (mirrored) it is rendered from left to right. For instance,
layer 48 (Document) is entered as 48t and 48b to always have it rendered as the last one.
Layers 21 (tPlace) and 22 (bPlace), on the other hand, are listed only once, to have
them rendered at the proper place, depending on whether the output is mirrored or not.<br>
Any layers that are not explicitly mentioned in the layer sequence are rendered after
the given sequence in ascending order.
<dt><b>Option.RatsnestLimit</b>
<dd>
The RATSNEST command processes all points of a signal, even if that
signal is very complex (in previous versions it dropped wire end points
from processing if the total number of connection points exceeded 254).
This requires more memory when calculating the ratsnest. In case this
is a problem on your system, you can revert to the original method
by setting this parameter to '254'.  The value given
here is the number of connection points up to which all wire end points
will be taken into account and thus limits the amount of memory used
(processing will use up to the square of this value in bytes, so a value
of 1024 will limit the used memory to 1MB). A value of '0' means there is
no limit. A value of '1' will result in airwires being connected only to
pads, smds and vias.
<dt><b>Option.RepositionMouseCursorAfterContextMenu</b>
<dd>
Normally EAGLE doesn't automatically position the mouse cursor. However,
some users want the cursor to be repositioned to the point where it has been
before a context menu in the drawing editor was opened. Set this parameter to
'1' to get this functionality.
<dt><b>Option.ShowPartOrigins</b>
<dd>
The origins of parts in a schematic are indicated by small crosses.
Set this parameter to '0' to turn this off.
<dt><b>Option.ShowTextOrigins</b>
<dd>
The origins of texts are indicated by small crosses.
Set this parameter to '0' to turn this off.
<dt><b>Option.SignalNamesOnPads</b>
<dd>
If this parameter is set to '1', the signal name is displayed on the contacts of
the signal in the color of the Unrouted layer. The default value is '1'.
<dt><b>Option.SignalNamesOnTraces</b>
<dd>
If this parameter is set to '1', the signal name is displayed on the signal
wires in the color of the Unrouted layer. The default value is '1'.
<dt><b>Option.ToggleCtrlForGroupSelectionAndContextMenu</b>
<dd>
Since the context menu function on the right mouse button interferes
with the selection of groups as it was done before version 5, a group is
now selected with Ctrl plus right mouse button. If you want to have the old
method of selecting groups back, you can set this parameter to '1'.
This will allow selecting groups with the right mouse button only and require
Ctrl plus right mouse button for context menus.
<dt><b>Option.UnpopulatedMarkScaling</b>
<dd>
With this parameter it's possible to scale the size of the mark of
not populated parts in the current assembly variant.
The default value is '1.0'.
<dt><b>Option.ViaLength</b>
<dd>
If this parameter is set to '1', the via length is textually displayed on
each via. The default value is '0'.
<dt><b>Sch.Cmd.Add.AlwaysUseDeviceNameAsValue</b>
<dd>
Some users always want to use the device name as part value, even if the
part needs a user supplied value. Those who want this can set this
parameter to '1'.
<dt><b>Warning.Cam.DrillsAndHolesConcurrent</b>
<dd>
If you don't want the warning message about using one file for drills and holes
by the CAM Processor, you can turn it off by setting this parameter to '0'.
<dt><b>Warning.PartHasNoUserDefinableValue</b>
<dd>
If you don't want the warning message about a part not having a user
definable value, you can turn it off by setting this parameter to '0'.
<dt><b>Warning.SupplyPinAutoOverwriteGeneratedNetName</b>
<dd>
Some users don't want the warning message about a supply pin overwriting
a generated net default name (starting with N$). Setting this option to '1' disables that warning.
</dl>


<a name=117>
<h1>SHOW</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Highlights objects.
<dt>
<b>Syntax</b>
<dd>
<tt>SHOW &#149;..</tt><br>
<tt>SHOW name..</tt><br>
<tt>SHOW @ name..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Left</mb> toggles the show state of the selected object.
</dl>
<b>See also</b> <a href=#65>INFO</a>
<p>
The SHOW command is used to highlight objects.
Details are listed in the status bar.
Complete signals and nets can be highlighted with the SHOW command.
If a bus is selected, all nets belonging to that bus will also be
highlighted.
<h2>Cross Probing</h2>
With active <a href=#406>Forward&amp;Back Annotation</a> an object
that is highlighted with the SHOW command in a board will also be
highlighted in the schematic, and vice versa.
<h2>Different Objects</h2>
If you select different objects with the SHOW command every single
object is highlighted separately.
You can select more than one object for highlighting by pressing the
Ctrl key when clicking on the objects. When you click on an object that
is already highlighted with the Ctrl key pressed, that object will
be displayed non-highlighted again.
<p>
If several names are entered in one line, all matching objects are
highlighted at the same time.
<h2>Small Objects</h2>
If the <tt>@</tt> character is given in the command line, a pointer rectangle
is drawn around the shown object. This is helpful in locating small objects that
wouldn't show up too well just through highlighting. If more than one object is
shown, the rectangle is drawn around all the objects. It may be necessary to
zoom out (or do a WINDOW FIT command) in order to see the pointer.
If an object with the literal name <tt>@</tt> shall be shown, the name must
be enclosed in single quotes.
<h2>Wildcards</h2>
If a <tt>name</tt> parameter is given, the characters <tt>'*'</tt>, <tt>'?'</tt>
and <tt>'[]'</tt> are <i>wildcards</i> and have the following meaning:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>*</tt>  </td><td width=20><td>matches any number of any characters</td></tr>
<tr><td><tt>?</tt>           </td><td width=20><td>matches exactly one character</td></tr>
<tr><td><tt>[...]</tt>       </td><td width=20><td>matches any of the characters between the brackets</td></tr>
</table>
<p>
If any of these characters shall be matched exactly as such, it has to be enclosed
in brackets. For example, <tt>abc[*]ghi</tt> would match <tt>abc*ghi</tt> and not
<tt>abcdefghi</tt>.
<p>
A range of characters can be given as <tt>[a-z]</tt>, which results in any character
in the range <tt>'a'</tt>...<tt>'z'</tt>.
<p>
The special pattern <tt>[number..number]</tt> forms a <a href=#39>bus name range</a>
and is therefore not treated as a wildcard pattern in a schematic.
<h2>Objects on different Sheets</h2>
If an object given by name is not found on the current schematic sheet, a dialog
is presented containing a list of sheets on which the object is found. If the object
is not found on any sheet, the sheet number is '-' in this list. Note that this
dialog only appears if any of the objects given by name (or wildcards) is not found
on the current sheet. If all given objects are found on the current sheet, no dialog
appears (even if some of the objects are also present on other sheets). Once the
dialog appears, it contains all objects found, even those on the current sheet.
<h2>Examples</h2>
<pre>
SHOW IC1
</pre>
IC1 is highlighted and remains highlighted until the SHOW command is ended
or a different name is entered.
<pre>
SHOW IC*
</pre>
Highlights all objects with names starting with "IC".


<a name=118>
<h1>SIGNAL</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines signals.
<dt>
<b>Syntax</b>
<dd>
<tt>SIGNAL &#149; &#149;..</tt><br>
<tt>SIGNAL signal_name &#149; &#149;..</tt><br>
<tt>SIGNAL signal_name element_name pad_name..;</tt>
</dl>
<b>See also</b> <a href=#37>AUTO</a>,
<a href=#113>ROUTE</a>,
<a href=#84>NAME</a>,
<a href=#44>CLASS</a>,
<a href=#73>LINE</a>,
<a href=#104>RATSNEST</a>,
<a href=#57>EXPORT</a>
<p>
The SIGNAL command is used to define signals (connections between
the various footprints). The user must define a minimum of two element_name/pad_name
pairs, as otherwise no airwire can be generated.
<h2>Mouse Input</h2>
To do that you select (with the mouse) the pads (or smds) of the elements
to be connected, step by step. EAGLE displays the part signals as airwires
in the Unrouted layer.
<p>
If input with signal_name the signal will be allocated the specified
name.
<h2>Text Input</h2>
Signals may also be defined completely by text input (via keyboard
or script file). The command
<pre>
SIGNAL GND IC1 7 IC2 7 IC3 7;
</pre>
connects pad 7 of IC1...3. In order to enter a whole netlist, a script
file may be generated, with the extension *.scr. This file
should include all of the necessary SIGNAL commands in the format shown
above.
<h2>Connection Check</h2>
If the SIGNAL command is used to connect pads (or smds) that already
belong to different signals, a popup menu will appear and ask the
user if he wants to connect the signals together, and which name the
signal should get.
<h2>Outlines data</h2>
The special signal name _OUTLINES_ gives a signal certain properties that
are used to generate <a href=#164>outlines data</a>.
This name should not be used otherwise.


<a name=119>
<h1>SLICE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Splits lines.
<dt>
<b>Syntax</b>
<dd>
<tt>SLICE [width] [ripup] &#149; &#149;</tt><br>
<dt>
</dl>
<b>See also</b> <a href=#49>DELETE</a>,
<a href=#111>RIPUP</a>
<p>
The SLICE command is used to cut lines in two. This can be used to separate
board traces or schematic nets for rerouting. The width defines how much of
the line is removed by the slice. The amount of a line that is removed is the
larger of either the width setting or twice the line width.
Only lines from from displayed layers can be sliced. Air lines and polygons
are not sliced.
<p>
Three ripup options are available for Slicing:
1) Slice without ripup (the default)
2) Ripup segments left of the slice
3) Ripup segments right of the slice.
These options are available as icons on the parameter bar. Additionally, the SLICE command can be
invoked from the command line with optional control over ripup: "SLICE None" for no ripup, "SLICE L"
for ripup left of the slice line, and "SLICE R" for ripup right of the slice line.  The ripup direction
is in relation to the direction of the slice line, where the slice line is like an arrow or vector from the start point to the end point.


<a name=120>
<h1>SIM</h1>
<dl>
    <dt>
        <b>Function</b>
    <dd>
        Run spice simulation.
    <dt>
        <b>Syntax</b>
    <dd>
        <tt>SIM</tt><br>
    <dt>
</dl>
<b>See also</b> <a href=#57>EXPORT</a>,
<a href=#65>INFO</a>,
<a href=#32>ADDMODEL</a>,
<a href=#75>MAPTOMODEL</a>,
<a href=#125>SOURCESETUP</a>,
<a href=#136>VALUE</a>
<br>
<h2>Spice Simulation</h2>
<h3>Basic Operation</h3>
The SIM command is used to kickoff a spice simulation from Eagle.  Parts must be simulation-capable, and
a managed library called <b>ngspice-simulation</b> is provided with Eagle.  Start the SIM command by typing SIM in the
Eagle command-line, or click the SIM command button.  Configuration, netlist, sim results and plot are shown
in the corresponding tabs in the simulation dialog.  <br><br>
Supported simulators are listed below: <br>
<ul>
    <li> Ngspice (version 26), http://ngspice.sourceforge.net/</li>
</ul>
<h3>Passive Sign Convention</h3>
Note that Eagle uses the passive sign convention (PSC) which states that the power is positive when current
flows into the positive terminal of a device.  This means typically loads have positive power dissipation
(they use power) and sources have negative power dissipation (they deliver power).  <br>
<h3>Simulation Dialog Tabs</h3>
<div style="margin-left: 20px">
    When the SIM command starts, the simulation dialog pops up.
    The dialog has multiple tabs:
    <ul>
        <li><b>Configuration:</b> Setup, save, and run a specific type of simulation</li>
        <li><b>Netlist:</b> View and edit a circuit netlist, and run a simulation from a manually edited netlist</li>
        <li><b>Simulator Output:</b> View raw simulator output</li>
        <li><b>Plot:</b> View and interact with the data via signal plotter</li>
    </ul>
</div>
<h3>Simulation-capable Library Parts</h3>
<div style="margin-left: 20px">
    To use the simulator, all parts must be simulation-capable.  This means that there
    are certain attributes the parts must have to work within the Eagle simulation environment.
    The library called <b>ngspice-simulation</b> is a basic simulation-capable library that is
    provided with Eagle, and all parts from that library can be used in a simulation.  <br><br>
    <b>Ground</b><br>
    A valid ground symbol has an attribute SPICEGROUND with empty value.
    One ground symbol must be present and connected to some net in your circuit for the simulator to calculate without errors.<br><br>
    <b>Initial Conditions</b><br>
    In addition to being able to set the values and attributes for simulation-capable parts, you can also set
    initial conditions for the part (such as initial voltage for a capacitor).  Initial conditions are
    added as attributes (see below).<br><br>
    <b>Spice Mapping</b><br>
    For spice simulation-capable parts, each pin must have an order with which it is mapped to the spice model.
    This property maps the pin to the correct input in a spice subcircuit, or model card, or intrinsic model.
    For example, consider an opamp part that 5 pins.  In the library symbol for the opamp, there must be 5 pins and correspondingly, in the spice
    model there must be 5 inputs.  The order value for each pin is a number, starting with 1, that maps the pin
    to the model input parameter.  This mapping is done by making a part spice-compatible using
    ADDMODEL then using the MAPTOMODEL command in the library device editor, and in schematic.  <br><br>
    When a part is mapped in a library, it stores the spice model in the libary part.  Regardless of whether
    a part had a preconfigured mapping from a library, the user can always remap a part in the schematic, in which
    case the part itself will store the information and override the library information.
    There is a mapping interface provided by the <a href=#32>ADDMODEL</a> and <a href=#75>MAPTOMODEL</a> commands
    to allow you to map part pins to model pins.<br><br>
    <b>Part Attributes</b>: When users map parts in a schematic, the following attributes are used.
    <ul>
        <li><b>SPICEMODEL: </b> Empty or the name of a valid spice model file without the .mdl extension</li>
        <li><b>SPICEPREFIX: </b> The single-letter valid spice prefix used for this type of device.  (ex: R, L, C, X, .. )</li>
        <li><b>SPICEINITCOND: </b> Initial conditions for a spice part, (voltage for capacitor, current for inductor)</li>
        <li><b>SPICEEXTRA: </b> These are optional values that you want in the netlist after the device model name, typically used for
            physical parameter specifiers (such as L=10 W=20).  </li>
        <li><b>_EXTERNAL_: </b> Optional attribute for parts that should be simulation-compatible but have no package, value should be empty. </li>
    </ul>
</div>
<h3>Spice Model Usage</h3>
<div style="margin-left: 20px">
    Some components (such as transistors, diodes, and sub-circuits), by definition, require
    the use of spice models and spice model cards.  To use a model for a component, there are
    two steps<br>
    <b>Using Models</b>
    <ol>
        <li>Use the MAPTOMODEL command to add the proper attributes to the part, and </li>
        <li>Place the model file in either the global <b>/models/</b> directory or in the same directory as the schematic</li>
    </ol>
    Note that the search order is as follows:
    <ol>
        <li>If the part was mapped in a library, it must exist in the library, otherwise ... </li>
        <li>The model file is first searched in the directory where the schematic design resides</li>
        <li>If not present there, then the user-configurable /models/ directory is searched</li>
    </ol>
    If the model is not found in one of the three places noted above, then it will not be added
    to the netlist and the simulation will fail.  The simulation results will note that
    the model was not found.
</div>
<h3>Netlists</h3>
<div style="margin-left: 20px">
    Eagle can generate spice-compatible netlists at any time by invoking the <a href=#57>EXPORT SPICENETLIST</a>
    command.  Netlists are saved in the same folder as the schematic and have the extension <b>*.sch.net</b>.  <br><br>
    The files with extension <b>*.sch.final.net</b> are the same netlists but with the latest simulation configuration
    included.  These are the files sent to the simulator, and the <b>*.sim</b> files are the simulator raw output.<br><br>
 The <b>*.sim.proc.log</b> files are the response from the system when running the simulator, and can be helpful in case of
    system or setup issues.<br><br>
    <b>Netlist Features</b><br>
    The netlist is generated by Eagle, and used for simulation, however, you have the ability to manually modify the netlist,
    and run a simulation based on the manually-edited netlist.  To edit a netlist, just make changes in the netlist tab,
    and if you click simulate <i>from the netlist tab</i>, it will simulate using the manually-edited netlist.
</div>
<h3>Plotting</h3>
<div style="margin-left: 20px">
    For simulations that have results that can be plotted (AC, DC, TRAN), the plot tab will automatically open and
    plot the data.  IF the design contains no probes, node voltages for all named nodes, and currents for all
    sources will be shown.  If there are probes in the design, then only those signals probed will show.  <br><br>
    Use the mouse to zoom in on a particular area on the plot by clicking and dragging a zoom window.  To zoom out,
    double click on the plot.  As the mouse moves all signals are traced and the corresponding values are shown in
    the plot legend.
</div>
<h3>Source Setup</h3>
<div style="margin-left: 20px">
    For spice smiulation-enabled parts that have a prefix of V or I (spice independent sources), the
    <a href=#125>SOURCESETUP</a> command offers a user-interface for setting up the DC, AC, and
    transient function parameters for a source part. Sine, exponential and pulse functions are currently supported.
</div>
<h3>Supported Features</h3>
<div style="margin-left: 20px">
    <ul>
        <li>Using control statements and scripting within netlists is not supported</li>
        <li>Simulation types: AC, DC, TRAN, and OP</li>
        <li>Use of valid spice subcircuit models and model cards.  Subcircuits may contain models and other subcircuits.  </li>
        <li>Netlist validation is done prior to simulations, and any invalid netlist lines are noted for the user. </li>
        <li>Simulation results are plotted and given in raw text form. </li>
        <li>Mapping parts in libraries is supported, and spice models are saved in the library part for easy of sharing. </li>
        <li>Mapping parts in schematic is supported, and part mappings take precedence over library mappings.  </li>
        <li>Preconfigured spice-compatible parts are supplied in the ngspice-simulation library.  </li>
        <li>Simulation settings are automatically loaded/saved from/to a .simcfg file in the same directory as the schematic.</li>
        <li>Spice model files are supported and user files should be in the same directory with the schematic they are
        used in, or in the /models/ application directory to be properly loaded.  </li>
    </ul>
</div>


<a name=121>
<h1>SIMOPTOGGLE</h1>
<dl>
    <dt>
        <b>Function</b>
    <dd>
        Toggle O.P. simulation results on or off
    <dt>
        <b>Syntax</b>
    <dd>
        <tt>SIMOPTOGGLE</tt><br>
    <dt>
</dl>
<b>See also</b> <a href=#120>SIM</a>
<br>


<a name=122>
<h1>REPOSITION</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Separates text variables and attributes from parts or elements.
<dt>
<b>Syntax</b>
<dd>
<tt>REPOSITION &#149;..</tt><br>
<tt>REPOSITION name ..</tt><br>
<tt>SMASH &#149;..</tt><br>
<tt>SMASH name ..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Ctrl+Right</mb> smashes the group.<br>
<mb>Shift+Left</mb> reverses the text separation ("unsmashes" the part).<br>
<mb>Ctrl+Shift+Right</mb> reverses the text separation for the group.
</dl>
<b>See also</b> <a href=#84>NAME</a>,
<a href=#136>VALUE</a>,
<a href=#131>TEXT</a>,
<a href=#36>ATTRIBUTE</a>
<p>
The REPOSITION command is used with parts or elements in order to separate the text
parameters (in the same way the former SMASH command did) indicating name, value or
attributes. The text may then be placed in fixed positions (Top-Left, Top, Top-Right,
Left, Center, Right, Bottom-Left, Bottom and Bottom-Right) or in a new and more
convenient location by using the MOVE command.
<p>
Parts and elements can also be selected by their name,
which is especially useful if the object is outside the currently shown
window area. Note that when selecting a multi-gate part in a schematic by name,
you will need to enter the full instance name, consisting of part
and gate name.
<p>
Use of the REPOSITION command allows the text to be treated like any other
text, e.g. with CHANGE SIZE, ROTATE, etc., but the actual text may not
be changed.
<p>
A "smashed" element can be made "unsmashed" by clicking on it with the
<tt>Shift</tt> key pressed (and of course the REPOSITION command activated).


<a name=123>
<h1>SMD</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds smd pads to a footprint.
<dt>
<b>Syntax</b>
<dd>
<tt>SMD [x_width y_width] [-roundness] [orientation] [flags] ['name'] &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.<br>
<mb>Right</mb> rotates the smd.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#89>PAD</a>,
<a href=#41>CHANGE</a>,
<a href=#84>NAME</a>,
<a href=#113>ROUTE</a>,
<a href=#168>Design Rules</a>
<p>
The SMD command is used to add pads for surface mount devices to a
footprint. When the SMD command is active, an smd symbol is attached
to the cursor. Pressing the left mouse button places an smd pad at
the current position.
Entering numbers changes the x- and y-width of the smd pad, which
can be up to 200 mm (7.7840 inch). These parameters
remain as defaults for successive SMD commands and can be changed
with the CHANGE command. Pressing
the center mouse button changes the layer onto which the smd pad will be drawn.
<p>
The <tt>orientation</tt> (see description in <a href=#31>ADD</a>)
may be any angle in the range <tt>R0</tt>...<tt>R359.9</tt>. The <tt>S</tt>
and <tt>M</tt> flags can't be used here.
<h2>Roundness</h2>
The <tt>roundness</tt> has to be entered as an integer number between
<tt>0</tt> and <tt>100</tt>, with a negative sign to distinguish it
from the width parameters. A value of <tt>0</tt> results in fully
rectangular smds, while a value of <tt>100</tt> makes the corners
of the smd fully round. The command
<pre>
SMD 50 50 -100 '1' &#149;
</pre>
for example would create a completely round smd named '1' at the given
mouseclick position. This can be used to create BGA (Ball Grid Array) pads.
<h2>Arbitrary Pad Shapes</h2>
If the standard smd pad shapes are not sufficient for a particular footprint,
you can create arbitrary smd pad shapes by drawing a polygon around an smd pad,
or by drawing wires that have one end connected to the smd pad.
<p>
The following conditions apply:
<ul>
<li>A polygon is considered connected to an smd pad on the same layer if the center
    of the pad lies within the area defined by the center lines of the polygon wires.
<li>A wire is considered connected to an smd pad on the same layer if one of its end
    points coincides with the center of the pad. Any wire connected to the other end
    of such a wire is also electrically connected to the pad.
<li>Only <b>one</b> polygon per pad is taken into account.
    If more than one polygon is connected to the same pad, they will cause DRC errors.
<li>Polygons connected to a pad will be ignored by the Autorouter when routing that
    signal. They will be considered obstacles when routing other signals.
<li>Wires connected to a pad will be handled like any other signal wires by the
    Autorouter, with the exception that they cannot be split.
<li>Solder stop and cream masks are only generated for the pad itself. If any additional
    solder stop or cream mask is required, it has to be drawn explicitly into the
    respective layer(s).
<li>When generating thermals, the additional polygon shape is taken into account.
<li>If a polygon or wire is connected to more than one pad within a footprint, only one
    of the pads will be considered electrically connected to the polygon or wire.
    The other pads will cause DRC errors, unless they are all
    <a href=#46>connected to the same pin</a> in a device.
<li>If a C-shaped polygon connected to a pad would cause a signal polygon in the board
    to have an "orphan" that lies within the C area, such an orphan will disappear
    regardless whether the signal polygon in question has its Orphans parameter set
    to on or off.
</ul>
<h2>Names</h2>
SMD names are generated automatically and may be modified with the
NAME command. Names may be included
in the SMD command if enclosed in single quotes.
<h2>Flags</h2>
The following <i>flags</i> can be used to control the appearance of an smd:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>NOSTOP</tt>  </td><td width=20><td>don't generate solder stop mask</td></tr>
<tr><td><tt>NOTHERMALS</tt>       </td><td width=20><td>don't generate thermals</td></tr>
<tr><td><tt>NOCREAM</tt>          </td><td width=20><td>don't generate cream mask</td></tr>
</table>
<p>
By default an smd automatically generates solder stop mask, cream mask and thermals as necessary.
However, in special cases it may be desirable to have particular smds not do this.
The above <tt>NO...</tt> flags can be used to suppress these features.<br>
A newly started SMD command resets all flags to their defaults. Once a flag is given
in the command line, it applies to all following smds placed within this SMD command.
<h2>Single Smds</h2>
Single smd pads in boards can only be used by defining
a footprint with one smd.


<a name=124>
<h1>SMDARRAY</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Create arrays of smds.
<dt>
<b>Syntax</b>
<dd>
<tt>SMDARRAY [sides base start count dx dy unit drawrect includename includevalue deleteobjs]</tt>
<dt>
<b>See also</b> <a href=#123>SMD</a>
<p>The SMDARRAY command allows to create an array of smds in the Library Footprint Editor.
If the command is started from the icon in the SMD parameter toolbar, a dialog pops up where the options
    for sides, basename, start index, number of smds, and others are set before creating the array.
    If the command is started from the command line and arguments are provided, the same options are
    available as specified below.
<h2>Options</h2>
<p>If the arguments are provided after the command, all need to be present: <br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>sides</td>          <td width=20><td>This can be L, R, LR, T, B, OR TB, which indicates onto which sides of a rectangle to draw
                            the smds, where L=Left, R=Right, T=Top, and B=Bottom. </td></tr>
<tr><td>base</td>           <td width=20><td>This is the base name to use when naming smds, where smds are named such that the first pin is &lt;base&gt;&lt;start&gt;
                            and subsequent smd are named with an increasing numerical suffix (i.e, ADDR1, ADDR2, .. ADDRN).  The last smd
                            placed with have a name given by &lt;base&gt;&lt;start+count-1&gt;</td></tr>
<tr><td>start</td>          <td width=20><td>The is the start index for smd naming. The first smd starts with a name &lt;base&gt;&lt;start&gt;</td></tr>
<tr><td>count</td>          <td width=20><td>The number of smds to place. </td></tr>
<tr><td>dx</td>             <td width=20><td>The distance in X direction between smds. </td></tr>
<tr><td>dy</td>             <td width=20><td>The distance in Y direction between smds. </td></tr>
<tr><td>unit</td>           <td width=20><td>Valid values are: MIC (for micron), MM (millimeter), MIL (mil = 0.001 inch), INCH.  </td></tr>
<tr><td>drawrect</td>       <td width=20><td>ON or OFF, indicates whether or not to draw a rectangle in the tplace layer as part of the operation</td></tr>
<tr><td>includename</td>    <td width=20><td>ON or OFF, indicates whether or not to place a text object with &gt;NAME as the value</td></tr>
<tr><td>includevalue</td>   <td width=20><td>ON or OFF, indicates whether or not to place a text object with &gt;VALUE as the value</td></tr>
<tr><td>deleteobjs</td>     <td width=20><td>ON or OFF, indicates whether or not to delete smds,labels,and line objects before placing the array</td></tr>
</table>


<a name=125>
<h1>SOURCESETUP</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Used to setup the DC, AC, and transient parameters for a simulation-compatible source part.
<dt>
<b>Syntax</b>
<dd>
<tt>SOURCESETUP name</tt>
</dl>
<b>See also</b> <a href=#32>ADDMODEL</a>,
    <a href=#120>SIM</a>,
    <a href=#126>DSOURCESETUP</a>
<p>
    This command is used to set the value of a spice-compatible source part (valid for
    parts with spice prefix V or I).  DC, AC, and Transient function (sine, exponential and pulse)
    values are avialable from within the UI. The user can always set the value directly for other
    valid source values.  Command available as context-menu item on part instances in schematic, as well as via
    command-line and via a toolbar command button.  If the part is not yet spice compatible, ADDMODEL
    is started to convert the part before setting up the part.


<a name=126>
<h1>DSOURCESETUP</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Used to setup a digital stimulation source for a simulation-compatible digital source part.
<dt>
<b>Syntax</b>
<dd>
<tt>DSOURCESETUP name</tt>
</dl>
<b>See also</b> <a href=#120>SIM</a>,
<b>See also</b> <a href=#32>ADDMODEL</a>,
<b>See also</b> <a href=#125>SOURCESETUP</a>
<h2>Typical Usage</h2>
    Used to setup a "digital source" part to provide input signal stimuli for digital
    circuit simulations. Data can be entered in a table manually, or loaded from a .csv
    file.
<p>
    EAGLE provides 1, 4, and 8-output digital source parts ready to use in the ngspice-digital
    library for your convenience and the DSOURCESETUP command is used to configure it.
    <br><br>
    After you place a digital source part, connect all the part pins to nets, then run
    DSOURCESETUP and click on the part, (or alternatively, right-click on the part and
    choose Digital Source Setup), to configure it.  You will be presented with
    a table-based interface, with one column for time, and one column for each output of the device.
    Data is entered into the table so that each row has a time value (i.e. 0.010s, or 10m, or 10ms, or 10e-3)
    then a series of digital values (0 or 1) for each output of the device.  The table below
    gives an example of the data that could be entered for a 4-output digital source.  <br><br>
<pre>
TIME       OUT1      OUT2      OUT3      OUT4
 0          0         0         0         0
 10ms       1         0         1         0
 15ms       0         1         1         1
</pre>
<h2>Advanced Usage</h2>
    The digital values can be entered simply as 0 or 1 or U (for unknown state), or also optionally ending with
    a signal strength/type indicator suffix character which is one of s, r, z, or u (these stand for
    strong, resistive, hi-impedance, and undetermined).  The full list of possible values
    is: <pre>0s, 1s, Us, 0r, 1r, Ur, 0z, 1z, Uz, 0u, 1u, Uu</pre>.
<p>
    If you want convert an arbitrary device to work as a digital source, you need to map it to a
    subcircuit SPICE model that contains the d_source digital model inside of it. The DRIVERD1,
    DRIVERD4, and DRIVERD8 models are provided in the example models directory for you
    and provide a template for how to use the d_source ngspice model. The model can be adjusted to include
    any number of outputs.  Consult the ngspice manual for more detail on the d_source model.
<p>
    Consult the ngspice manual included in the EAGLE install directory for more details on digital source parts.


<a name=127>
<h1>SPLIT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Splits wires and polygon edges into segments.
<dt>
<b>Syntax</b>
<dd>
<tt>SPLIT &#149; [curve | @radius] &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Right</mb> changes the wire bend style (see <a href=#116>SET Wire_Bend</a>).<br>
<mb>Shift+Right</mb> reverses the direction of switching bend styles.<br>
<mb>Ctrl+Right</mb> toggles between corresponding bend styles.<br>
<mb>Ctrl+Left</mb> when placing a wire end point defines arc radius.
</dl>
<b>See also</b> <a href=#81>MITER</a>,
<a href=#83>MOVE</a>,
<a href=#87>OPTIMIZE</a>,
<a href=#116>SET</a>
<p>
The SPLIT command is used to split a wire (or segment) or a polygon
edge into two segments in order, for example, to introduce a bend.
This means you can split wires into parts that can be moved with the
mouse during the SPLIT command. A mouseclick defines the point at
which the wire is split. The shorter of the two new segments follows
the current wire bend rules and may therefore itself become two segments
(see SET Wire_Bend), the longer segment is a straight segment running
to the next end point.
<p>
If the <i>curve</i> or <i>@radius</i> parameter is given, an arc can be drawn as part of the wire segment
(see the detailed description in the <a href=#73>LINE</a> command).
<p>
On completion of the SPLIT command, the segments are automatically
rejoined if they are in line unless the command
<pre>
SET OPTIMIZING OFF;
</pre>
has previously been given, or the wire has been clicked at the same
spot twice. In this case the split points remain and can be used,
for example, to <b>reduce the width of a segment</b>. This is achieved by
selecting the SPLIT command, marking the part of the wire which is
to be reduced with two mouse clicks, and using the command
<pre>
CHANGE WIDTH width
</pre>
The segment is then clicked on to complete the change.


<a name=128>
<h1>FUSIONSYNC</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Synchronise a board with a Fusion PCB.
<dt>
<b>Syntax</b>
<dd>
<tt>FUSIONSYNC</tt><br>
</dl>
<p>
The FUSIONSYNC command is used to synchronise a board with a Fusion PCB model.
<p>
It allows the user to easily create a 3D representation of a PCB.
When a board is edited in EAGLE, the command allows to push these changes to the Fusion PCB model.
When a board is edited in Fusion, the command allows to pull and merge these changes into the EAGLE board file.
A link to the Fusion PCB model is stored in the board.
A board can be linked to a different Fusion PCB model using the command.


<a name=129>
<h1>FUSIONTEAM</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Publishes the schematic and board files and/or manufacturing data files to Fusion Team.
<dt>
<b>Syntax</b>
<dd>
<tt>FUSIONTEAM </tt>
</dl>
A schematic and/or board file can be uploaded to Fusion Team. The command can be activated in the layout editor by clicking on the Fusion Team tab or by typing the command in the command line.
Select a CAM Job file in order to process manufacturing data. The manufacturing data will be uploaded to Fusion Team as a zipped archive automatically.
The Fusion Team tab can be (de)activated together with the Fusion 360 tab in the Options/User interface menu.


<a name=130>
<h1>TECHNOLOGY</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines the possible <i>technology</i> parts of a device name.
<dt>
<b>Syntax</b>
<dd>
<tt>TECHNOLOGY name ..;</tt><br>
<tt>TECHNOLOGY -name ..;</tt><br>
<tt>TECHNOLOGY -* ..;</tt>
</dl>
<b>See also</b> <a href=#88>PACKAGE</a>,
<a href=#36>ATTRIBUTE</a>
<p>
This command is used in the device editor mode to define the possible <i>technology</i>
parts of a device name.
In the schematic or board editor the TECHNOLOGY command behaves exactly
like "<a href=#41>CHANGE TECHNOLOGY</a>".
<p>
Exactly one of the names given in the TECHNOLOGY command will
be used to replace the <tt>'*'</tt> in the device set name when an actual device is added
to a schematic.
The term <i>technology</i> stems from the main usage of this feature in creating
different variations of the same basic device, which all have the same schematic
symbol(s), the same package and the same pin/pad connections. They only differ in
a part of their name, which for the classic TTL devices is related to their
different technologies, like "L", "LS" or "HCT".
<p>
The TECHNOLOGY command can only be used if a package variant has been selected with the <a href=#88>PACKAGE</a> command.
<p>
If no <tt>'*'</tt> character is present in the device set name, the technology will
be appended to the device set name to form the full device name. Note that the technology
is processed before the package variant, so if the device set name contains neither
a <tt>'*'</tt> nor a <tt>'?'</tt> character, the resulting device name will consist
of <i>device_set_name</i><tt>+</tt><i>technology</i><tt>+</tt><i>package_variant</i>.
<p>
The names listed in the TECHNOLOGY command will be added to an already existing list
of technologies for the current device.
Starting a name with <tt>'-'</tt> will remove that name from the list of technologies.
If a name shall begin with <tt>'-'</tt>, it has to be enclosed in single quotes.
Using <tt>-*</tt> removes all technologies.
<p>
Only ASCII characters in the range 33..126 may be used in technologies (lowercase characters
will be converted to uppercase).
<p>
The special "empty" technology can be entered as two single quotes (<tt>''</tt>, an empty string).
<p>
Note that the Technologies dialog contains all technologies from all devices in
the loaded library, with the ones referenced by the current device checked.
<h2>Example</h2>
In a device named "<tt>74*00</tt>" the command
<pre>
TECHNOLOGY -* '' L LS S HCT;
</pre>
would first remove any existing technologies and then create the individual technology variants
<pre>
7400
74L00
74LS00
74S00
74HCT00
</pre>


<a name=131>
<h1>TEXT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds text to a drawing.
<dt>
<b>Syntax</b>
<dd>
<tt>TEXT  any_text  [orientation] &#149;..</tt><br>
<tt>TEXT 'any_text' [orientation] &#149;..</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Center</mb> selects the layer.<br>
<mb>Right</mb> rotates the text.<br>
<mb>Shift+Right</mb> reverses the direction of rotating.
</dl>
<b>See also</b> <a href=#41>CHANGE</a>,
<a href=#83>MOVE</a>,
<a href=#80>MIRROR</a>,
<a href=#93>PIN</a>,
<a href=#112>ROTATE</a>,
<a href=#36>ATTRIBUTE</a>
<p>
The TEXT command is used to add text to a library element or drawing.
When entering several texts it is not necessary to invoke the
command each time, as the text command remains active after placing
text with the mouse.
<h2>Orientation</h2>
The orientation of the text may be defined by the TEXT command (orientation)
using the usual definitions as listed in the <a href=#31>ADD</a> command (R0, R90
etc.). The right mouse button will change the rotation of the text
and the center mouse button will change the current layer.
<p>
Text is always displayed so that it can be read from in front or from
the right - even if rotated. Therefore after every two rotations it
appears the same way, but the origin has moved from the lower left
to the upper right corner. Remember this if a text appears to be unselectable.
<p>
The reading direction for vertical texts can be changed from "up" to "down" in the
<a href=#17>user interface dialog</a>.
<p>
If you want to have text that is printed "upside down", you can set the "Spin"
flag for that text.
<h2>Multi Line Texts</h2>
Texts can contain line breaks. In the text dialog they can be entered directly with
Shift-Enter, in the command line "\n" has to be used.
<h2>Special Characters</h2>
If the text contains several successive blanks or a semicolon, the
whole string has to be enclosed in single quotes. If the text contains
single quotes then each one itself has to be enclosed in single quotes.
If apostrophes are required in the text, each must be enclosed
in single quotes.<br>
If the text shall contain plain backslashes, each one has to be escaped with another backslash.
(e.g. <tt>TEXT 'abc\\\\def'</tt> produces <tt>abc\\def</tt>).
<h2>Key Words</h2>
If the TEXT command is active and you want to type in a text that
contains a string that can be mistaken for a command (e.g. "red"
for "REDO") then this string has to be enclosed in single
quotes.
<h2>Text Height</h2>
The height and thickness of characters can be changed with the
CHANGE commands:
<pre>
CHANGE SIZE text_size &#149;..
CHANGE RATIO ratio &#149;..
CHANGE LINEDISTANCE value &#149;..
</pre>
Maximum text height:  2 inches<br>
Maximum text thickness: 200 mm (7.7840 inch)<br>
Ratio: 0...31 (% of text height)<br>
Line distance: 0...250 (% of text height).
<h2>Text Font</h2>
Texts can have three different fonts:
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>Vector</tt></td>           <td width=20><td>the program's internal vector font</td></tr>
<tr><td><tt>Proportional</tt></td>     <td width=20><td>a proportional pixel font (usually 'Helvetica')</td></tr>
<tr><td><tt>Fixed</tt></td>            <td width=20><td>a monospaced pixel font (usually 'Courier')</td></tr>
</table>
<p>
The text font can be changed with the CHANGE command:
<pre>
CHANGE FONT VECTOR|PROPORTIONAL|FIXED &#149;..
</pre>
The program makes great efforts to output texts with fonts other than
<tt>Vector</tt> as good as possible. However, since the actual font is drawn
by the system's graphics interface, <tt>Proportional</tt> and <tt>Fixed</tt> fonts
may be output with different sizes and/or lengths.
<p>
If you set the option "Always vector font" in the <a href=#17>user interface dialog</a>,
all texts will always be displayed and printed using the builtin vector font,
independent from the settings of the individual texts and for each drawing.
This option is useful if the system doesn't display the other fonts correctly.<br>
You can use the <tt><a href=#116>SET</a> Interface.VectorFont 0|1</tt>
command to change this setting.
<p>
When creating a new board or schematic, the current setting of this option is stored
in the option "Persistent in this drawing" of the drawing file.
This makes sure that the drawing will be printed with the correct setting if
it is transferred to somebody else who has a different setting of this option.<br>
You can use the <tt><a href=#116>SET</a> VECTOR_FONT OFF|ON</tt> command
to change the setting in an existing board or schematic drawing.
<p>
When creating output files with the CAM Processor, texts will always be drawn with
<tt>Vector</tt> font. Other fonts are not supported.
<p>
If a text with a font other than <tt>Vector</tt> is subtracted from a signal
polygon, only the surrounding rectangle is subtracted. Due to the
above mentioned possible size/length problems, the actually printed
font may exceed that rectangle. Therefore, if you need to subtract
a text from a signal polygon it is recommended that you use the <tt>Vector</tt>
font.
<p>
The <i>Ratio</i> parameter has no meaning for texts with fonts other than <tt>Vector</tt>.
<h2>Text Alignment</h2>
The text alignment defines where the origin shall be put within the text.
There are nine different possible alignments, which consist of combinations
of the keywords <tt>left</tt>, <tt>bottom</tt>, <tt>center</tt>, <tt>right</tt>
and <tt>top</tt>. These keywords can be given in any sequence, but only the
last one of left/right and top/bottom will be taken into account for the
respective direction. The center keyword only applies to those directions
where no other keyword has been given. The default is left and bottom.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CHANGE ALIGN TOP CENTER; TEXT 'ABC' &#149;</tt>   </td><td width=20><td>draws the text ABC with the origin at its top/center</td></tr>
</table>
<h2>Character Sets</h2>
Only the characters with ASCII codes below 128 are guaranteed to be printed correctly.
Any characters above this may be system dependent and may yield different results
with the various fonts.
<h2>Text Variables</h2>
Special texts in a symbol or footprint drawing, marked with the <tt>'&gt;'</tt>
character, will be replaced with actual values in a board or schematic:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>&gt;NAME</tt>             </td><td width=20><td>Component name (ev.+gate name) 1)</td></tr>
<tr><td><tt>&gt;VALUE</tt>            </td><td width=20><td>Comp. value/type 1)</td></tr>
<tr><td><tt>&gt;PART</tt>             </td><td width=20><td>Component name 2)</td></tr>
<tr><td><tt>&gt;GATE</tt>             </td><td width=20><td>Gate name 2)</td></tr>
<tr><td><tt>&gt;XREF</tt>             </td><td width=20><td>Part cross-reference 2)</td></tr>
<tr><td><tt>&gt;CONTACT_XREF</tt>     </td><td width=20><td>Contact cross-reference 2)</td></tr>
<tr><td><tt>&gt;ASSEMBLY_VARIANT</tt> </td><td width=20><td>Name of the current assembly variant</td></tr>
<tr><td><tt>&gt;DRAWING_NAME</tt>     </td><td width=20><td>Drawing name</td></tr>
<tr><td><tt>&gt;LAST_DATE_TIME</tt>   </td><td width=20><td>Time of the last modification</td></tr>
<tr><td><tt>&gt;PLOT_DATE_TIME</tt>   </td><td width=20><td>Time of the plot creation</td></tr>
<tr><td><tt>&gt;SHEETNR</tt>          </td><td width=20><td>Sheet number of a schematic 3)</td></tr>
<tr><td><tt>&gt;SHEETS</tt>           </td><td width=20><td>Total number of sheets of a schematic 3)</td></tr>
<tr><td><tt>&gt;SHEET</tt>            </td><td width=20><td>equivalent to "&gt;SHEETNR/&gt;SHEETS" 3)</td></tr>
<tr><td><tt>&gt;MODULE</tt>           </td><td width=20><td>Module name (available in module sheets, otherwise empty) 3)</td></tr>
<tr><td><tt>&gt;SHEET_HEADLINE</tt>   </td><td width=20><td>Headline of the sheet 3)</td></tr>
<tr><td><tt>&gt;SHEETNR_TOTAL</tt>    </td><td width=20><td>Sheet number of a schematic with modules 3)</td></tr>
<tr><td><tt>&gt;SHEETS_TOTAL</tt>     </td><td width=20><td>Total number of sheets of a schematic with modules 3)</td></tr>
<tr><td><tt>&gt;SHEET_TOTAL</tt>      </td><td width=20><td>equivalent to "&gt;SHEETNR_TOTAL/&gt;SHEETS_TOTAL"       3)</td></tr>
</table>
<p>
1) Only for footprint or symbol<br>
2) Only for symbol<br>
3) Only for symbol or schematic
<p>
The format in which a part cross-reference is displayed can be controlled
through the "Xref part format" string, which is defined in the "Options/Set/Misc"
dialog, or with the <a href=#116>SET</a> command.
The following placeholders are defined, and can be used in any order:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%S</tt></td>  <td width=20><td>the sheet number</td></tr>
<tr><td><tt>%C</tt></td>  <td width=20><td>the column on the sheet</td></tr>
<tr><td><tt>%R</tt></td>  <td width=20><td>the row on the sheet</td></tr>
</table>
<p>
The default format string is <tt>"/%S.%C%R"</tt>. Apart from the defined
placeholders you can also use any other ASCII characters.
<h2>Attributes</h2>
If a symbol or footprint drawing shall display an <a href=#36>attribute</a>
of the actual part or element, a text with the name of that attribute, marked with
the <tt>'&gt;'</tt> character, can be used. By default, only the actual value of the
given attribute will be displayed. If the attribute name is followed by one of the
special characters <tt>'='</tt>, <tt>'~'</tt> or <tt>'!'</tt>, the actual display
is as follows:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td with=100><tt>&gt;ABC </tt></td><td width=20><td><tt>123</tt></td></tr>
<tr><td><tt>&gt;ABC=</tt></td><td width=20><td><tt>ABC = 123</tt></td></tr>
<tr><td><tt>&gt;ABC~</tt></td><td width=20><td><tt>ABC</tt></td></tr>
<tr><td><tt>&gt;ABC!</tt></td><td width=20><td><tt><i>nothing</i></tt></td></tr>
</table>
<p>
Note that for each attribute name there should be only one such text in any given symbol
or footprint!
If there is more than one such text in a symbol or footprint that all reference the
same attribute name, only one of them will be displayed when the part using
this symbol or package is smashed.
<h2>Overlined text</h2>
Text can be <i>overlined</i>, which is useful for instance for the names of inverted
signals ("active low", see also
<a href=#85>NET</a>, <a href=#39>BUS</a> and <a href=#93>PIN</a>).
To do so, the text needs to be preceded with an exclamation mark (<tt>'!'</tt>), as in
<pre>
  !RESET
</pre>
which would result in
<pre>
  _____
  RESET
</pre>
This is not limited to signal names, but can be used in any text. It is
also possible to overline only part of a text, as in
<pre>
  !RST!/NMI
  R/!W
</pre>
which would result in
<pre>
  ___
  RST/NMI
    _
  R/W
</pre>
Note that the second exclamation mark indicates the end of the overline.
There can be any number of overlines in a text. If a text shall contain
an exclamation mark that doesn't generate an overline, it needs to be
escaped by a backslash. In order to keep the need for escaping exclamation
marks at a minimum, an exclamation mark doesn't start an overline if it
is the last character of a text, or if it is immediately followed by a
blank, a double or single quote, or by a right
parenthesis, bracket or brace. Any non-escaped exclamation mark or comma
that appears after an exclamation mark that started an overline will end
the overline (the comma as an overline terminator is necessary for busses).


<a name=132>
<h1>EXPORTSTEP</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Exports the board into a STEP file.
<dt>
<b>Syntax</b>
<dd>
<tt>EXPORTSTEP</tt>
</dl>
The EXPORTSTEP command can be used in the command line or from the Export/STEP menu in the Layout Editor window.
<p>
EAGLE uses the cloud service for Fusion Sync to do the translation. The STEP file can be accessed on the Control Panel's home tab. It's listed in the Recent Generated 3D files section. A mouse click onto the the entry in the list opens the file manager to access this step file.


<a name=133>
<h1>UNDO</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Cancels previous commands.
<dt>
<b>Syntax</b>
<dd>
<tt>UNDO</tt><br>
<tt>UNDO LIST</tt>
</dl>
<b>See also</b> <a href=#106>REDO</a>,
<a href=#116>SET</a>,
<a href=#406>Forward&amp;Back Annotation</a>
<p>
The UNDO command allows you to cancel previously executed commands.
This is especially useful if you have deleted things by accident.
Multiple UNDO commands cancel the corresponding number of commands
until the last EDIT, OPEN or REMOVE command is reached.
<p>
The UNDO command uses up memory space. If you are short of
this you can switch off this function with the SET command
<pre>
SET UNDO_LOG OFF;
</pre>
UNDO/REDO is completely integrated within Forward&amp;Back Annotation.
<h2>UNDO buffer dialog</h2>
The option LIST in the UNDO command opens a dialog that contains the
entire contents of the undo buffer. You can navigate through the list of
undo/redo steps by click&amp;dragging the list delimiter, or by directly
clicking on any given step you wish to go back or forward to. If there
are several steps between the current delimiter position and the clicked
list item, all steps in between will be executed in the proper sequence.
Going upward in the list means doing UNDO, going downward results in REDO.<br>
The icon at each list item indicates in which drawing this particular command
has been executed.
<p>
If you confirm this dialog with "OK", the drawing will be left in the
condition as selected in the list. If you cancel the dialog, it will be
restored to the condition it had before the dialog was opened.
<p>
<b>CAUTION:</b> this is a very powerful tool! By going all the way back in the
UNDO list (which can be done with a single mouse click) and executing any
new command, the undo buffer will be truncated at that point, and there
is no way back! So use this with care!


<a name=134>
<h1>UPDATE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Updates library objects.
<dt>
<b>Syntax</b>
<dd>
<tt>UPDATE</tt><br>
<tt>UPDATE;</tt><br>
<tt>UPDATE library_name..;</tt><br>
<tt>UPDATE footprint_name@library_name..;</tt><br>
<tt>UPDATE +@ | -@ [library_name..];</tt><br>
<tt>UPDATE old_library_name = new_library_name;</tt>
</dl>
<b>See also</b> <a href=#31>ADD</a>,
<a href=#110>REPLACE</a>
<p>
The UPDATE command checks the parts in a board or schematic against
their respective library objects and automatically updates them if
they are different. If UPDATE is invoked from the library editor, the
footprints within the loaded library will be updated from the given
libraries.
<p>
If you activate the UPDATE command without a parameter, a dialog will
be presented to select the library from which to update.
<p>
If one or more libraries are given, only parts from those libraries will be checked.
The library names can be either a plain library name (like "ttl" or "ttl.lbr"), a full
file name (like "/home/mydir/myproject/ttl.lbr" or "../lbr/ttl"), or the URN of a
downloaded managed library (like "urn:adsk.eagle:library:42").
<p>
If a <tt>library_name</tt> contains blanks, it needs to be enclosed in single quotes.
<h2>Update in a board or schematic</h2>
If the command is terminated with a <tt>';'</tt>, but has no parameters,
all parts will be checked.
<p>
If the first parameter is <tt>'+@'</tt>, the names of the given local libraries (or all local libraries,
if none are given) will get a <tt>'@'</tt> character appended, followed by a number.
This can be used to make sure the libraries contained in a drawing will not be modified when
a part from a newer library with the same name is added to the drawing. Library names that
already end with a <tt>'@'</tt> character followed by a number will not be changed, nor will
the names of managed libraries.
<p>
If the first parameter is <tt>'-@'</tt>, the <tt>'@'</tt> character (followed by a number) of the given
libraries (or all libraries, if none are given) will be stripped from the library name.
This of course only works if there is no local library with that new name already in the drawing.
<p>
Please note that "UPDATE +@;" followed by "UPDATE -@;" (and vice versa) does not necessarily
result in the original set of library names, because the sequence in which the names are processed
depends on the sequence in which the libraries are stored in the drawing file.
<p>
The libraries stored in a board or schematic drawing are identified by their
base name (e.g. "ttl") and, for managed libraries, by their URN (e.g. "urn:adsk.eagle:library:462").
In matching the library to be updated with the library to update with, preference is given
first to cases where the URN of the two matches (managed libraries) or the name matches and
there is no URN (local libraries). If there is no such match, UPDATE falls back to cases where
the names match and either of the two libraries has no URN. (Matches are never
made between managed libraries with different URNs, even if their names are the same.) If there
is more than one potential match, a dialog will be shown to select the library to use. Note
that the library names stored in a drawing are handled case insensitively and that the path of
local libraries is not taken into account (except when the path was provided on the command
line). It does not matter whether a specific library is currently "in use", although managed
libraries will only be used if they have been downloaded. If a library is
not found, no update will be performed for that library. An error will only be shown for
libraries entered on the command line. No errors will be shown for missing libraries when
updating all libraries present in a board or schematic.
<p>
Using the UPDATE command in a schematic or board that are connected via active
<a href=#406>Forward&amp;Back Annotation</a> will act on both the
schematic and the board.
<p>
At some point you may need to specify whether gates, pins or pads shall
be mapped by their names or their coordinates. This is the case when the respective library
objects have been renamed or moved. If too many modifications have been made (for example, if
a pin has been both renamed and moved) the automatic update may not be possible. In that case
you can either do the library modification in two steps (one for renaming, another for moving),
or give the whole library object a different name.
<p>
When used with <tt>old_library_name = new_library_name</tt> (note that there has to be
at least one blank before and after the <tt>'='</tt> character), the UPDATE command
locates the library named <i>old_library_name</i> in the current board or schematic,
and updates it with the contents of <i>new_library_name</i>. Note that <i>old_library_name</i>
must be the pure library name, without any path, while <i>new_library_name</i>
may be a full path name or URN. If the update was performed successfully, the library in the current board/schematic file will
also be renamed accordingly - therefore this whole operation is, of course, only
possible if <i>new_library_name</i> has not yet been used in the current board or schematic.
<p>
<b>Note: You should always run a <a href=#53>Design Rule Check</a> (DRC) and an
<a href=#55>Electrical Rule Check</a> (ERC) after a library update has been performed
in a board or a schematic!</b>
<h2>Update in a library</h2>
The update in a library replaces all footprints within that library with the versions
from the given libraries.
<p>
By specifying the footprint name (footprint_name@library_name) you can have only a
specific footprint be replaced.


<a name=135>
<h1>USE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Marks a library for use.
<dt>
<b>Syntax</b>
<dd>
<tt>USE</tt><br>
<tt>USE -*;</tt><br>
<tt>USE library_name..;</tt><br>
<tt>USE -library_name..;</tt>
</dl>
<b>See also</b> <a href=#31>ADD</a>,
<a href=#110>REPLACE</a>
<p>
The USE command marks a library for later use with the
<a href=#31>ADD</a> or <a href=#110>REPLACE</a> command.
<p>
If you activate the USE command without a parameter, a dialog
will appear that allows for library management: marking libraries for use, removing them from
use, and downloading and updating managed libraries.
<p>
The special parameter <tt>-*</tt> causes all previously marked libraries
to be dropped.
With <tt>-library_name</tt> the library <tt>library_name</tt> will be dropped.
<p>
<tt>library_name</tt> can be the full name of a library or it can contain
wildcards. It can also be the URN of a downloaded managed library.
If <tt>library_name</tt> is the name of a directory, all libraries from
that directory will be marked.
<p>
The suffix <tt>.lbr</tt> can be omitted.
<p>
Note that when adding a device or package to a drawing, the complete library
information for that object is copied into the drawing file, so that
you don't need the library for changing the drawing later.
<p>
Changes in a library have no effect on existing drawings.
See the <a href=#134>UPDATE</a> command if you want to
update parts from modified libraries.
<h2>Using Libraries via the Control Panel</h2>
Libraries can be easily marked for use in the <a href=#13>Control Panel</a>
by clicking on their activation icon (which changes its color to indicate that this
library is being used), or by selecting "Use" from the library's context menu.
Through the context menu of the "Libraries" entry in the Control Panel it is also
possible to use <i>all</i> of the libraries or <i>none</i> of them.
<h2>Used Libraries and Projects</h2>
The libraries that are currently in use will be stored in the project file
(if a project is currently open).
<h2>Examples</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>USE</tt>              </td><td width=20><td>opens the file dialog to choose a library</td></tr>
<tr><td><tt>USE -*;</tt>          </td><td width=20><td>drops all previously marked libraries</td></tr>
<tr><td><tt>USE demo trans*;</tt> </td><td width=20><td>marks the library demo.lbr and all libraries with names matching trans*.lbr</td></tr>
<tr><td><tt>USE urn:adsk.eagle:library:462;</tt> </td><td width=20><td>marks the managed library with the URN urn:adsk.eagle:library:462</td></tr>
<tr><td><tt>USE -* /eagle/lbr;</tt>  </td><td width=20><td>first drops all previously marked libraries and then marks all libraries from the directory /eagle/lbr</td></tr>
</table>


<a name=136>
<h1>VALUE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Displays and changes values.
<dt>
<b>Syntax</b>
<dd>
<tt>VALUE &#149;..</tt><br>
<tt>VALUE value &#149;..</tt><br>
<tt>VALUE name value ..</tt><br>
<tt>VALUE ON;</tt><br>
<tt>VALUE OFF;</tt>
</dl>
<b>See also</b> <a href=#84>NAME</a>,
<a href=#122>REPOSITION</a>,
<a href=#137>VARIANT</a>
<h2>In Boards and Schematics</h2>
Elements can be assigned a value, e.g. '1k' for a resistor or '10uF'
for a capacitor. This is done with the VALUE command. The
command selects an element and opens a popup menu that allows you
to enter or to change a value.
<p>
If you type in a value before you select an element, then all of the subsequently
selected elements receive this value. This is very useful if you want
for instance a number of resistors to have the same value.
<p>
If the parameters name and value are specified, the
element name gets the specified value.
<p>
The VALUE command can only be used in the default assembly variant.
If you want to change the value of another assembly variant,
you need to use the <a href=#137>VARIANT</a> command.
<h2>Example</h2>
<pre>
VALUE R1 10k R2 100k
</pre>
In this case more than one element has been assigned a value. This
possibility can be used in script files:
<pre>
VALUE R1   10k \
      R2  100k \
      R3  5.6k \
      C1  10uF \
      C2  22nF \
      ...
</pre>
The '\' prevents the following line from being mistaken for an EAGLE
key word.
<h2>In Device Mode</h2>
If the VALUE command is used in the device edit mode, the parameters
ON and OFF may be used:
<p>
On: Permits the actual value to be changed in the schematic.
<p>
Off: Automatically enters the actual device name into the schematic
(e.g.74LS00N). The user can only modify this value after a confirmation.


<a name=137>
<h1>VARIANT</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Manages assembly variants.
<dt>
<b>Syntax</b>
<dd>
<tt>VARIANT</tt><br>
<tt>VARIANT name part_name [NO]POPULATE [ value [ technology ] ];</tt><br>
<tt>VARIANT [ + | - ] name;</tt>
</dl>
<b>See also</b> <a href=#136>VALUE</a>,
<a href=#130>TECHNOLOGY</a>
<p>
By default all parts of the schematic are populated on the board (provided they
have a package). However, sometimes different variants of a design may require that
some parts are not populated, or that they have different values or technologies
than the default. The VARIANT command allows you to define which parts are actually
populated in a given assembly variant, and to give them particular values and
technologies.
<p>
<i>name</i> is the name of the variant. It is treated case-insensitive and must be
enclosed in single quotes if it contains blanks or '+' or '-'.
<p>
If <i>part_name</i> followed by the keyword <tt>POPULATE</tt> or <tt>NOPOPULATE</tt>
is given, a variant of the given <i>name</i> is created for that part, in which
it will be marked as either "populated" or "not populated".
<p>
Parts that are not populated in the current assembly variant are indicated with
an X drawn over their entire bounding rectangle in the schematic.
In the board anything that is related to actually placing the part on the board
(like placeplan, names, values etc.) is not drawn in such a case.
<p>
The optional <i>value</i> and <i>technology</i> (which is only applicable in a
schematic) can be used to further refine the variant.
A value may only be given if the part's device set has its "user value" parameter
enabled.
If only the technology shall be specified without using a different value, an
empty string (<tt>''</tt>) can be entered for the value.
<p>
A new variant can be created by preceding <tt>name</tt> with a <tt>'+'</tt>.
If a variant with that name already exists, nothing happens.
<p>
If the variant name is preceded with a <tt>'-'</tt>, the given variant will be
deleted. If <tt>name</tt> is <tt>'*'</tt>, all variants will
be deleted. Unless this command is used in a script, a confirmation
prompt will ask the user whether this action should really be taken.
<p>
Giving only a variant name will switch the whole project to that variant.
This means that all "populate" flags, values and technologies will appear as
specified in that variant for each part. Using an empty string (<tt>''</tt>)
here switches to the default assembly variant, which is the same as if there
were no variants at all.
Note that when loading a drawing it is always in its default state, with no
assembly variant selected.
<p>
If used without any parameters, a dialog will open that allows you to manage
all assembly variants.
<p>
The name of the current assembly variant can be displayed by using the
<a href=#131>text variable</a> <tt>&gt;ASSEMBLY_VARIANT</tt>.
<p>
The commands ADD, CHANGE PACKAGE | TECHNOLOGY, REPLACE, UPDATE and VALUE
can only be used if no assembly variant is active.
<p>
The COPY command doesn't copy assembly variants.
<p>
In the board the VARIANT command is not supported, everything is controlled from
schematic if f/b annotation is active (the variant combobox in the board editor
is only for informational reasons). However, for standalone boards it's possible
to set the populate option of elements with the <a href=#41>CHANGE</a>
command or in the properties dialog.
<h2>Module Assembly Variants</h2>
Assembly variants can also be created for a module. A specific assembly variant
of the module can be selected in each module instance that refers to it.
<p>
The assembly variants of the schematic and assembly variants of modules are
completely independent. The VARIANT command is not intended to switch assembly
variants of a module.
<p>
Therefore for more clarity we distinguish between <b><i>Module Assembly Variants</i></b>
and <b><i>Main Assembly Variants</i></b>.
Within a module the VARIANT command refers to its module assembly variants,
on the schematic's main sheets it refers to the main assembly variants.


<a name=138>
<h1>VIA</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Adds vias to a board.
<dt>
<b>Syntax</b>
<dd>
<tt>VIA ['signal_name'] [diameter] [shape] [layers] [flags] &#149;..</tt>
</dl>
<b>See also</b> <a href=#123>SMD</a>,
<a href=#41>CHANGE</a>,
<a href=#52>DISPLAY</a>,
<a href=#116>SET</a>,
<a href=#89>PAD</a>,
<a href=#168>Design Rules</a>
<p>
When the VIA command is active, a via symbol is attached to the cursor.
Pressing the left mouse button places a via at the current position.
The via is added to a signal if it is placed on an existing signal wire.
If you try to connect different signals, EAGLE will ask you if you really
want to connect them.
<h2>Signal name</h2>
The <tt>signal_name</tt> parameter is intended mainly to be used in
script files that read in generated data. If a <tt>signal_name</tt>
is given, all subsequent vias will be added to that signal, and no
automatic checks will be performed.<br>
<b>This feature should be used with great care because it could result
in short circuits, if a via is placed in a way that it would connect
wires belonging to different signals. Please run a
<a href=#53>Design Rule Check</a> after using the VIA command
with the <tt>signal_name</tt> parameter!</b>
<h2>Via diameter</h2>
Entering a number changes the diameter of the via (in the actual
unit) and the value remains in use for further vias. Via diameters
can be up to 200 mm (7.7840 inch).
<p>
The drill diameter of the via is the same as the diameter set for
pads. It can be changed with
<pre>
CHANGE DRILL diameter &#149;
</pre>
<h2>Shape</h2>
A via can have one of the following shapes:
<p>
     Square<br>
     Round<br>
     Octagon
<p>
These shapes only apply to the outer layers (Top and Bottom).
In inner layers the shape is always "round".
<p>
Vias generate drill symbols in the Drills layer and the solder
stop mask in the tStop/bStop layers.
<p>
Like the diameter, the via shape can be entered while
the VIA command is active, or it can be changed with the CHANGE command.
The shape then remains valid for the next vias and pads.
<p>
Note that the actual shape and diameter of a via will be determined by the
<a href=#168>Design Rules</a> of the board the via is used in.
<h2>Layers</h2>
The <tt>layers</tt> parameter defines the layers this via shall
cover. The syntax is <tt>from-to</tt>, where 'from' and 'to' are the layer numbers
that shall be covered. For instance <tt>2-7</tt> would create a via that goes from
layer 2 to layer 7 (<tt>7-2</tt> would have the same meaning). If that exact via is
not available in the layer setup of the <a href=#168>Design Rules</a>, the next longer via
will be used (or an error message will be issued in case no such via can be
set). With <a href=#116>SET</a> <b>Option.ViaLength 1</b>
the via length is textually displayed.
<h2>Flags</h2>
The following <i>flags</i> can be used to control the appearance of a via:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>STOP</tt>  </td><td width=20><td>always generate solder stop mask</td></tr>
</table>
<p>
By default a via with a drill diameter that is less than or equal to the value of
the <a href=#168>Design Rules</a> parameter "Masks/Limit" will not
have a solder stop mask. The above <tt>STOP</tt> flag can be used to force a solder
stop mask for a via.


<a name=139>
<h1>WINDOW</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Zooms in and out of a drawing.
<dt>
<b>Syntax</b>
<dd>
<tt>WINDOW;</tt><br>
<tt>WINDOW &#149;;</tt><br>
<tt>WINDOW &#149; &#149;;</tt><br>
<tt>WINDOW &#149; &#149; &#149;</tt><br>
<tt>WINDOW scale_factor</tt><br>
<tt>WINDOW FIT</tt><br>
<tt>WINDOW LAST</tt><br>
<tt>WINDOW FLIP</tt>
<dt>
<b>Mouse keys</b>
<dd>
<mb>Left&amp;Drag</mb> defines a rectangular window (shortcut for "<tt>&#149; &#149;;</tt>").
<dt>
<b>Keyboard</b>
<dd>
<tt>Alt+F2: WINDOW FIT </tt>   Fit drawing on the screen<br>
<tt>F2:     WINDOW;    </tt>   Redraw screen<br>
<tt>F3:     WINDOW 2   </tt>   Zoom in by a factor of 2<br>
<tt>F4:     WINDOW 0.5 </tt>   Zoom out by a factor of 2<br>
<tt>F5:     WINDOW (@);</tt>   Cursor pos. is new center (if a command is active)
</dl>
The WINDOW command is used to zoom in and out of the drawing and to
change the position of the drawing on the screen. The command can
be used with up to three mouse clicks. If there are fewer, it must
be terminated with a semicolon.
<h2>Refresh screen</h2>
If you use the WINDOW command followed by a semicolon, EAGLE redraws
the screen without changing the center or the scale. This is useful
if error messages cover part of the drawing.
<h2>New center</h2>
The WINDOW command with one point causes that point to become
the center of a new screen display of the drawing. The scaling of
the drawing remains the same. You can also use the sliders of the
working area to move the visible area of the drawing. The function
key F5 causes the current position of the cursor to be the new center.
<h2>Corner points</h2>
The WINDOW command with two points defines a rectangle with
the specified points at opposite corners. The rectangle expands to
fill the screen providing a close-up view of the specified portion
of the drawing.
<h2>New center and zoom</h2>
You can use the WINDOW command with three points. The first
point defines the new center of the drawing and the display becomes
either larger or smaller, depending on the ratios of the spacing between
the other points. In order to zoom in, the distance between point
1 and point 3 should be greater than the distance between point 1
and 2; to zoom out place point 3 between points 1 and 2.
<h2>Zoom in and out</h2>
<pre>
WINDOW 2;
</pre>
Makes the elements appear twice as large.
<pre>
WINDOW 0.5;
</pre>
Reduces the size of the elements by a factor of two.
<p>
You can specify an integer or real number as the argument to the WINDOW
command to scale the view of the drawing by the amount entered. The
center of the window remains the same.
<h2>The whole drawing</h2>
<pre>
WINDOW FIT;
</pre>
fits the entire drawing on the screen.
<h2>Back to the previous window</h2>
<pre>
WINDOW LAST;
</pre>
switches back to the previous window selection. A window selection is stored by
every WINDOW command, except for zoom-only WINDOW commands and modifications of
the window selection with the mouse.
<h2>Window Flip</h2>
<pre>
WINDOW FLIP;
</pre>
allows the user to view and edit the board from the perspective of the bottom side of the board.
<h2>Very large zoom factors</h2>
By default the maximum zoom factor is limited in such a way that
an area of 1mm (about 40mil) in diameter will be shown using the full editor window.
If you need to zoom in further, you can uncheck "Options/User interface/Limit zoom factor"
and will then be able to zoom in all the way until the finest editor grid
can be seen.
<p>
When zooming very far into a drawing, the following things may happen:
<ul>
<li>Texts that are not using the vector font may not be shown if they are larger
    than the editor window.
<li>Circles and Arcs are approximated and therefore may not appear at their exact
    location (especially if they have a very small width).
<li>Whether or not the finest grid will be visible when zooming all the way in depends
    on your screen resolution, the editor window size and the value of
    "Options/Set/Misc/Min. visible grid size".
</ul>
<h2>Parameter Aliases</h2>
Parameter aliases can be used to define certain parameter settings to the
WINDOW command, which can later be referenced by a given name.
The aliases can also be accessed by clicking on the "WINDOW Select" button
and holding the mouse button pressed until the list pops up.
A right click on the button also pops up the list.
<p>
The syntax to handle these aliases is:
<dl>
<dt>
<tt>WINDOW = <i>name</i> <i>parameters</i></tt>
<dd>
Defines the alias with the given <i>name</i> to expand to the given
<i>parameters</i>. The <i>name</i> may consist of any number of letters,
digits and underlines, and is treated case insensitive. It must begin
with a letter or underline and may not be one of the option keywords.
<dt>
<tt>WINDOW = <i>name</i> @</tt>
<dd>
Defines the alias with the given <i>name</i> to expand to the current
window selection.
<dt>
<tt>WINDOW = ?</tt>
<dd>
Asks the user to enter a name for defining an alias for the current
window settings.
<dt>
<tt>WINDOW = <i>name</i></tt>
<dd>
Allows the user to select a window that will be defined as an alias
under the given <i>name</i>.
<dt>
<tt>WINDOW = <i>name</i>;</tt>
<dd>
Deletes the alias with the given <i>name</i>.
<dt>
<tt>WINDOW <i>name</i></tt>
<dd>
Expands the alias with the given <i>name</i> and executes the WINDOW command with
the resulting set of parameters. The <i>name</i> may be abbreviated and
there may be other parameters before and after the alias (even other
aliases). Note that in case <i>name</i> is an abbreviation, aliases have precedence
over other parameter names of the command.
</dl>
Example:
<p>
<tt>WINDOW = MyWindow (0 0) (4 3);</tt>
<p>
Defines the alias "MyWindow" which, when used as in
<p>
<tt>WINDOW myw</tt>
<p>
will zoom to the given window area.
Note the abbreviated use of the alias and the case insensitivity.


<a name=140>
<h1>WIRE</h1>
<p>
<b>The keyword 'WIRE' is deprecated. The WIRE command has been renamed to <a href=#73>LINE</a></b>


<a name=141>
<h1>WRITE</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Saves the current drawing or library or design block.
<dt>
<b>Syntax</b>
<dd>
<tt>WRITE;</tt><br>
<tt>WRITE name</tt><br>
<tt>WRITE @name</tt><br>
<tt>WRITE 7 [ name ] </tt><br>
<tt>WRITE [ DBL ] name </tt>
</dl>
The WRITE command is used to save a drawing or library or design block. If 'name'
is entered, EAGLE will save the file under the new name.
<p>
The file name may also be entered with a pathname if it is to
be saved in another directory. If no pathname is given, the file is
saved in the
<a href=#15>project directory or design block directory (option DBL)</a>
<p>
If the new name is preceded with a <tt>@</tt>, the name of the loaded
drawing will also be changed accordingly. The corresponding board/schematic
will then also be saved automatically under this name and the UNDO buffer
will be cleared.
<p>
If WRITE is selected from the menu, a popup window will appear asking
for the name to use (current drawing name is default). This name may
be edited and accepted by clicking the OK button. Pressing the ESCAPE
key or clicking the CANCEL button cancels the WRITE command.
<p>
To assure consistency for
<a href=#406>Forward&amp;Back Annotation</a>
between board and schematic drawings, the WRITE
command has the following additional functionality:
<ul>
<li>when a board/schematic is saved under the same name, the
corresponding schematic/board is also saved if it has been modified
<li>when a board/schematic is saved under a different name, the user
will be asked whether he also wants to save the schematic/board
under that different name
<li>saving a drawing under a different name does not clear the "modified" flag
</ul>
<h2>Saving for EAGLE 7.x</h2>
If the word <tt>7</tt> is provided after <tt>write</tt>, the file(s) will be saved for EAGLE 7.x.
All XML attributes added in EAGLE 8.x will be omitted, and other adjustments will be made to
ensure the file can be opened in EAGLE 7.x. Note that some information, such as the URNs of
managed libraries and the assets inside them, will be lost.
<p>
If no file name is provided on the command line, the user will be prompted to select one. Note
that the <tt>@name</tt> format (to change the name of the loaded drawing) is not supported when
saving for EAGLE 7.x.
<h2>Generate and write a Design Block</h2>
<h3>General</h3>
With option DBL, a desgin block is generated from the currently loaded schematic and/or board
(depending, from which editor executed and whether schematic and board are in consistent state)
and saved under the given name.
<p>
If no name is given, a dialog for design block generation pops up. It additionally allows
entering an HTML description and attributes. In the upper left there is a preview of the description.
The description can be written in the text field below. Attributes can be managed in the bottom left.
There are also automatically generated attributes which are not editable.
The preview on the right side represents the drawing(s) to be included in the design block.
At the bottom you can enter the file name or select where to store it.
<h3>Consistent Selection</h3>
Via the pulldown menu entry File/"Save selection as Design Block" it is possible to select
parts of the current schematic, board or of both and save it as a design block.
<p>
After having clicked this menu entry you do a selection in the first editor.
The selection works in additive mode and may be adjusted several times.
Deselection with Ctrl-Click is also supported.
The selection in the first editor can be finished with Ctrl-Rightclick.
There are a couple of criteria for such a selection that will be checked (see below).
If these criteria are not met, an according error message is displayed and the user
may continue the selection to correct his selection Ctrl-Rightclick again.
<p>
If there's only one editor open, the design block dialog like above pops up, presenting
current selection in the preview. The selection can be saved this way.
<p>
If both editors are open, with the Ctrl-Rightclick you can continue the selection
in the second editor. <br>
In the second editor, initially the corresponding objects from first editor are selected
for f/b annotation
(e.g element R1 if part instance R1 has been selected first). With the selection in the
second editor additional objects can be selected, as long as they do not disturb <i>consistency</i>.
Selection or deselection of any objects that would disturb consistency are automatically
filtered out.
For example objects without electrical meaning like texts, dimensions etc. can be selected,
routed wires or polygons from signals can be added or removed from the selection
if the corresponding nets have been selected.
The selection can be finished with another Ctrl-Rightclick and the design block dialog appears.
Now the combined selection is visible in the preview and can be saved as a desgin block
for future reuse.<br>
The combined selection is only possible if a consistent schematic/board pair is loaded
and it works in both directions. It is not supported yet within hierarchical designs.
<h3>Selection criteria</h3>
If the schematic has multiple sheets and the selection is started from board, only objects
with counterparts on current sheet are supported.<br>
If the selection is started from schematic, it is checked that the user selects net segments
completely, in particular not leaving behind some net wires or labels.<br>
For each part all it's instances must be selected.<br>
With a net segment being selected, all connected part instances connected to this segment must be selected.


<a name=142>
<h1>Generating Output</h1>
<ul>
<li><a href=#143>Printing</a>
<li><a href=#147>CAM Processor</a>
<li><a href=#164>Outlines data</a>
</ul>


<a name=143>
<h1>Printing</h1>
The parameters for printing to the system printer can be modified through
the following three dialogs:
<ul>
<li><a href=#144>Printing a Drawing</a>
<li><a href=#145>Printing a Text</a>
<li><a href=#146>Printer Page Setup</a>
</ul>
<p>
<b>See also</b> <a href=#102>PRINT</a>


<a name=144>
<h1>Printing a Drawing</h1>
If you enter the <a href=#102>PRINT</a> command without a
terminating <tt>';'</tt>, or select <b>Print</b> from the
<a href=#14>context menu</a> of a drawing's icon in the
<a href=#13>Control Panel</a>, you will be presented a dialog
with the following options:
<h2>Paper</h2>
Selects which paper format to print on.
<h2>Orientation</h2>
Selects the paper orientation.
<h2>Preview</h2>
Turns the print preview on or off.
<h2>Mirror</h2>
Mirrors the output.
<h2>Rotate</h2>
Rotates the output by 90&deg;.
<h2>Upside down</h2>
Rotates the drawing by 180&deg;. Together with <b>Rotate</b> the drawing is rotated by a total of 270&deg;.
<h2>Black</h2>
Ignores the color settings of the layers and prints everything in black.
<h2>Solid</h2>
Ignores the fill style settings of the layers and prints everything in solid.
<h2>Scale factor</h2>
Scales the drawing by the given value.
<h2>Page limit</h2>
Defines the maximum number of pages you want the output to use.
In case the drawing does not fit on the given number of pages, the actual scale factor
will be reduced until it fits.
The default value of <tt>0</tt> means no limit.
<h2>All</h2>
All sheets of the schematic will be printed
(this is the default when selecting <b>Print</b> from the
<a href=#14>context menu</a> of a schematic drawing's icon).
<h2>From...to</h2>
Only the given range of sheets will be printed.
<h2>This</h2>
Only the sheet that is currently being edited will be printed
(this is the default when using the <a href=#102>PRINT</a> command
from a schematic editor window).
<h2>Hierarchy</h2>
The sheets of modules are printed for each use in a module instance
with the according part and net names.
<h2>Printer...</h2>
Invokes the system printer dialog, which enables you to choose which printer
to use and to set printer specific parameters.
<h2>PDF...</h2>
Creates a PDF (Portable Document Format) file with the given print settings.
<p>
The remaining options are used for the <a href=#146>page setup</a>.


<a name=145>
<h1>Printing a Text</h1>
If you select <b>Print</b> from the
<a href=#14>context menu</a> of a text file's icon in the
<a href=#13>Control Panel</a>, or from the <b>File</b>
menu of the <a href=#28>Text Editor</a>, you will be presented
a dialog with the following options:
<h2>Wrap long lines</h2>
Enables wrapping lines that are too long to fit on the page width.
<h2>Printer...</h2>
Invokes the system printer dialog, which enables you to choose which printer
to use and to set printer specific parameters.
<h2>PDF...</h2>
Creates a PDF (Portable Document Format) file with the given print settings.
<p>
The remaining options are used for the <a href=#146>page setup</a>.


<a name=146>
<h1>Printer Page Setup</h1>
The Print dialog provides several options that are used to define how a drawing or text
shall be placed on the paper.
<h2>Border</h2>
Defines the left, top, right and bottom borders. The values are either in
millimeters or inches, depending on which unit results in fewer decimals.
<p>
The default border values are taken from the printer driver, and define
the maximum drawing area your particular printer can handle. You can enter
smaller values here, but your printer hardware may or may not be able to
print arbitrarily close to the paper edges.
<p>
After changing the printer new hardware minimums may apply and your
border values may be automatically enlarged as necessary to comply with
the new printer. Note that the values will not be decreased automatically
if a new printer would allow smaller values. To get the smallest possible
border values you can enter <tt>0</tt> in each field, which will then be
limited to the hardware minimum.
<h2>Calibrate</h2>
If you want to use your printer to produce production layout drawings,
you may have to calibrate your printer to achieve an exact 1:1
reproduction of your layout.
<p>
The value in the <b>X</b> field is the calibration factor to use
in the print head direction, while the value in the <b>Y</b> field
is used to calibrate the paper feed direction.
<p>
<b>IMPORTANT NOTE: When producing production layout drawings with
your printer, always check the final print result for correct measurements!</b>
<p>
The default values of <tt>1</tt> assume that the printer produces exact
measurements in both directions.
<h2>Aligment</h2>
Defines the vertical and horizontal alignment of the drawing on the paper.
<h2>Caption</h2>
Activates the printing of a caption line, containing the time and date
of the print as well as the file name.
<p>
If the drawing is mirrored, the word "mirrored" will appear in the caption,
and if the scale factor is not <tt>1.0</tt> it will be added as <b>f=...</b>
(the scale factor is given with 4 decimal digits, so even if <b>f=1.0000</b>
appears in the caption the scale factor will not be <i>exactly</i> <tt>1.0</tt>).


<a name=147>
<h1>CAM Processor</h1>
The CAM Processor allows you to output any combination of layers
to a device or file.
<p>
The following help topics lead you through the necessary steps from
selecting a data file to configuring the output device:
<ul>
<li><a href=#148>Select the data file</a>
<li><a href=#150>Select the output device type</a>
<li><a href=#161>Select the output file</a>
<li><a href=#163>Select the plot layers</a>
<li><a href=#151>Adjust the device parameters</a>
<li><a href=#162>Adjust the flag options</a>
</ul>
The CAM Processor allows you to combine several sets of parameter settings
to form a <a href=#149>CAM Processor Job</a>, which can be used to
produce a complete set of output files with a single click of a button.
<p>
<b>See also</b> <a href=#143>printing to the system printer</a>


<a name=148>
<h1>Main CAM Menu</h1>
The <i>Main CAM Menu</i> is where you select which file to process,
edit drill rack and aperture wheel files, and load or save job files.
<h2>File</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Open           </td><td width=20><td>Board...  open a board file for processing</td></tr>
<tr><td>                          </td><td width=20><td>Drill rack...  open a drill rack file for editing</td></tr>
<tr><td>                          </td><td width=20><td>Wheel...  open an aperture wheel file for editing</td></tr>
<tr><td>                          </td><td width=20><td>Job...  switch to an other job (or create a new one)</td></tr>
<tr><td>Save job...    </td><td width=20><td>save the current job</td></tr>
<tr><td>Close          </td><td width=20><td>close the CAM Processor window</td></tr>
<tr><td>Exit           </td><td width=20><td>exit from the program</td></tr>
</table>
<h2>Layer</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Deselect all   </td><td width=20><td>deselect all layers</td></tr>
<tr><td>Show selected  </td><td width=20><td>show only the selected layers</td></tr>
<tr><td>Show all       </td><td width=20><td>show all layers</td></tr>
</table>
<h2>Window</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Control Panel         </td><td width=20><td>switch to the Control Panel</td></tr>
<tr><td>1 Schematic - ...     </td><td width=20><td>switch to window number 1</td></tr>
<tr><td>2 Board - ...         </td><td width=20><td>switch to window number 2</td></tr>
</table>
<h2>Help</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>General help   </td><td width=20><td>opens a general help page</td></tr>
<tr><td>Contents       </td><td width=20><td>opens the help table of contents</td></tr>
<tr><td>CAM Processor  </td><td width=20><td>displays help for the CAM Processor</td></tr>
<tr><td>Job help       </td><td width=20><td>displays help about the Job mechanism</td></tr>
<tr><td>Device help    </td><td width=20><td>displays help about output devices</td></tr>
</table>


<a name=149>
<h1>CAM Processor Job</h1>
A CAM Processor <i>Job</i> consists of several <i>Sections</i>,
each of which defines a complete set of CAM Processor parameters
and layer selections.
<p>
A typical CAM Processor job could for example have two sections, one
that produces photoplotter data for the Top layer, and another that
produces the data for the bottom layer.
<h2>Section</h2>
The <i>Section</i> selector shows the currently active job section.
By pressing the button you can select any of the sections you have defined
previously with the <i>Add</i> button.
<h2>Prompt</h2>
If you enter a text in this field, the CAM Processor will prompt you with
this message before processing that particular job section. For example you
might want to change the paper in your pen plotter for each plot, so the
message could be "Please change paper!". Each job section can have its own
prompt message, and if there is no message the section will be processed
immediately.
<h2>Add</h2>
Click on the <i>Add</i> button to add a new section to the job.
You will be asked for the name of that new job section. The new job section
will be created with all parameters set to the values currently shown
in the menu.<br>
Please note that if you want to create a new job section, you should
<b>first add</b> that new section and <b>then modify</b> the
parameters. Otherwise, if you first modify the parameters of the current
section and then add a new section, you will be prompted to confirm whether
the modifications to the current section shall be saved or not.
<h2>Del</h2>
Use the <i>Del</i> button to delete the current job section.
You will be prompted to confirm whether you really want to delete that
section.
<h2>Process Section</h2>
The <i>Process Section</i> button processes the current job section, as
indicated in the <i>Section</i> selector.
<h2>Process Job</h2>
The <i>Process Job</i> button processes the entire job by processing
each section in turn, starting with the first section. What happens is
the same as if you would select every single section with the
<i>Section</i> selector and press the <i>Process Section</i> button for
each section - just a lot more convenient!


<a name=150>
<h1>Output Device</h1>
The <i>Output Device</i> defines the kind of output the CAM Processor
is to produce. You can select from various device types, like photo plotters,
drill stations etc.
<h2>Device</h2>
Clicking on the button of the Device selector
opens a list of all available output devices.
<h2>Scale</h2>
On devices that can scale the output you can enter a scaling factor in
this field. Values larger than <tt>1</tt> will produce an enlarged output,
values smaller than <tt>1</tt> will shrink the output.
<p>
You can limit the size of the output to a given number of pages by entering
a negative number in the Scale field. In that case the default scale
factor will be 1.0 and will be decreased until the drawing just fits on the
given number of pages. For example, entering "-2" into this field will
produce a drawing that does not exceed two pages. Please note that for this
mechanism to work you will have to make sure that the page width and height
is set according to your output device. This setting can be adjusted in the
Width and Height fields or by editing the file eagle.def.
<h2>File</h2>
You can either enter the name of the
<a href=#161>output file</a>
directly into this field, or click on the
File button
to open a dialog for the definition of the output file.<br>
If you want to derive the output filename from the input data file, you
can enter a partial filename (at least an extension, e.g. <tt>.gbr</tt>),
in which case the rest of the filename will be taken from the input data
filename.
<h2>Wheel</h2>
You can either enter the name of the
<a href=#152>aperture wheel file</a>
directly into this field, or click on the Wheel button
to open a file dialog to select from.<br>
If you want to derive the output filename from the input data file, you
can enter a partial filename (at least an extension, e.g. <tt>.whl</tt>),
in which case the rest of the filename will be taken from the input data
filename.
<h2>Rack</h2>
You can either enter the name of the
<a href=#155>drill rack file</a>
directly into this field, or click on the Rack button
to open a file dialog to select from.<br>
If you want to derive the output filename from the input data file, you
can enter a partial filename (at least an extension, e.g. <tt>.drl</tt>),
in which case the rest of the filename will be taken from the input data
filename.
Some drill devices (like EXCELLON, for instance) can automatically generate the
necessary drill definitions, in which case this field is not present.


<a name=151>
<h1>Device Parameters</h1>
Depending on the type of <a href=#150>output device</a>
you have selected, there are several device specific parameters that
allow you to adjust the output to your needs:
<ul>
<li><a href=#152>Aperture Wheel File</a>
<li><a href=#153>Aperture Emulation</a>
<li><a href=#154>Aperture Tolerances</a>
<li><a href=#155>Drill Rack File</a>
<li><a href=#156>Drill Tolerances</a>
<li><a href=#157>Offset</a>
<li><a href=#158>Page Size</a>
<li><a href=#159>Pen Data</a>
</ul>


<a name=152>
<h1>Aperture Wheel File</h1>
A photoplotter usually needs to know which <i>apertures</i> are
assigned to the codes used in the output file. These assignments
are defined in an <i>Aperture Wheel File</i>.
<h2>Examples</h2>
<pre>
D010    round     0.004
D040    square    0.004
D100    rectangle 0.060 x 0.075
D104    oval      0.030 x 0.090
D110    draw      0.004
</pre>
Note that the file may contain several apertures that share the same D-code,
as long as all of these have a type from draw or round, and have
the same size.
This can be used to map apertures that effectively result in the
same drawing to a common D-code.


<a name=153>
<h1>Aperture Emulation</h1>
If the item "Apertures" is selected, apertures not available are
emulated with smaller apertures. If this item is not selected,
no aperture emulation will be done at all.
<p>
Please note that aperture emulation can cause very long plot times (costs!).


<a name=154>
<h1>Aperture Tolerances</h1>
If you enter tolerances for draw and/or flash apertures the CAM
Processor uses apertures within the tolerances, provided the aperture
with the exact value is not available.
<p>
Tolerances are entered in percent.
<p>
<b>Please be aware that your design rules might not be kept when allowing
tolerances!</b>


<a name=155>
<h1>Drill Rack File</h1>
If a drill station driver can't automatically generate the necessary drill
definitions, it needs to know which <i>drill diameters</i>
are assigned to the codes used in the output file. These assignments
are defined in a <i>Drill Rack File</i>.
<p>
This file can be generated with the help of a User Language Program called
drillcfg.ulp, that is stored in your EAGLE's ULP directory.
Use the <a href=#114>RUN</a> command to start it.
<h2>Example</h2>
<pre>
T01   0.010
T02   0.016
T03   0.032
T04   0.040
T05   0.050
T06   0.070
</pre>


<a name=156>
<h1>Drill Tolerances</h1>
If you enter tolerances for drills the CAM Processor uses drill
diameters within the tolerances, provided the drill with the exact
value is not available.
<p>
Tolerances are entered in percent.


<a name=157>
<h1>Offset</h1>
Offset in x and y direction (inch, decimal number).
<p>
Can be used to position the origin of plotters at the lower left corner.


<a name=158>
<h1>Printable Area</h1>
<h2>Height</h2>
Printable area in <tt>Y</tt> direction (inch).
<h2>Width</h2>
Printable area in <tt>X</tt> direction (inch).
<p>
Please note that the CAM Processor divides a drawing into several
parts if the rectangle which includes all objects of the file
(even the ones not printed) doesn't fit into the printable area.


<a name=159>
<h1>Pen Data</h1>
<h2>Diameter</h2>
Pen diameter in mm. Is used for the calculation of lines
when areas have to be filled.
<h2>Velocity</h2>
Pen velocity in cm/s for pen plotters which can be adjusted
to different speeds.
<p>
The plotter default speed is selected with the value 0.


<a name=160>
<h1>Defining Your Own Device Driver</h1>
The drivers for output devices are defined in the text file eagle.def.
There you find details on how to define your own driver. It is
advisable to copy the whole section of an existing driver of the same
device category and to edit the parameters which are different.
<p>
Please use a <a href=#28>text editor</a> which doesn't
place control characters into the file.


<a name=161>
<h1>Output File</h1>
The <i>Output File</i> contains the data produced by the CAM Processor.
<p>
The following file names are commonly used:
<pre>
-------------------------------------------------------
File   Layers               Meaning
-------------------------------------------------------
*.cmp  Top, Via, Pad        Component side
*.ly2  Route2, Via, Pad     Inner signal layer
*.ly3  Route3, Via, Pad     Inner signal layer
...                         ...
*.sol  Bot, Via, Pad        Solder side
*.plc  tPl, Dim, tName,     Silkscreen comp. side
*.pls  bPl, Dim, bName,     Silkscreen solder side
*.stc  tStop                Solder stop mask comp. side
*.sts  bStop                Solder stop mask sold. side
*.drd  Drills, Holes        Drill data for NC drill st.
-------------------------------------------------------
</pre>
<h2>Placeholders</h2>
The output file name can either be entered directly, or can be dynamically
composed using <i>placeholders</i>. A placeholder consists of a percentage
character (<tt>'%'</tt>) followed by a letter. The following
placeholders are defined:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>%D{xxx}</tt></td><td width=20><td>a string that is inserted only into the data file name</td></tr>
<tr><td><tt>%E</tt>     </td><td width=20><td>the loaded file's extension (without the <tt>'.'</tt>)</td></tr>
<tr><td><tt>%H</tt>     </td><td width=20><td>the user's <a href=#15>home directory</a></td></tr>
<tr><td><tt>%I{xxx}</tt></td><td width=20><td>a string that is inserted only into the info file name</td></tr>
<tr><td><tt>%L</tt>     </td><td width=20><td>the layer range for blind&amp;buried vias (see below)</td></tr>
<tr><td><tt>%N</tt>     </td><td width=20><td>the loaded file's name (without path and extension)</td></tr>
<tr><td><tt>%P</tt>     </td><td width=20><td>the loaded file's directory path (without file name)</td></tr>
<tr><td><tt>%%</tt>     </td><td width=20><td>the character <tt>'%'</tt></td></tr>
</table>
<p>
For example, the output file definition
<p>
<tt>%N.cmp%I{.info}</tt>
<p>
would create <tt><i>boardname</i>.cmp</tt> for the data file and <tt><i>boardname</i>.cmp.info</tt>
for the info file (in case the selected output device generates an info file).
<h2>Drill data with blind&amp;buried vias</h2>
If the board contains blind or buried vias, the CAM
Processor generates a separate drill file for each via length that is
actually used in the board. The file names are built by adding the number
of the start and end layer to the base file name, as in
<pre>
<i>boardname</i>.drl.0104
</pre>
which would be the drill file for the layer stack 1-4. If you want to have
the layer numbers at a different position, you can use the placeholder <tt>%L</tt>,
as in
<pre>
%N.%L.drl
</pre>
which would result in
<pre>
<i>boardname</i>.0104.drl
</pre>
The drill info file name is always generated without layer numbers, and
any '.' before the <tt>%L</tt> will be dropped.
Any previously existing files that would match the given drill file name
pattern, but would not result from the current job, will be deleted before
generating any new files. There will be one drill info file per job, which
contains (amoung other information) a list of all generated drill data files.


<a name=162>
<h1>Flag Options</h1>
<h2>Mirror</h2>
Mirror output. This option normally causes negative
coordinates, therefore it should be used only if "pos. Coord." is
selected, too.
<h2>Rotate</h2>
Rotate drawing by 90 degrees. This option normally causes
negative coordinates, therefore it should be used only if "pos.
Coord." is selected, too.
<h2>Upside down</h2>
Rotate the drawing by 180 degrees. Together with Rotate, the
drawing is rotated by a total of 270 degrees. This option normally causes
negative coordinates, therefore it should be used only if "pos.
Coord." is selected, too.
<h2>pos. Coord</h2>
Offsets the output so that negative coordinates are
eliminated and the drawing is referenced to the origin of the output device.
This is advisable for devices which generate error messages if
negative coordinates are detected.
<h2>Quickplot</h2>
Draft output which shows only the outlines of objects (subject to availability
on the selected output device).
<h2>Optimize</h2>
Activates the optimization of the drawing sequence for plotters.
<h2>Fill pads</h2>
Pads will be filled. This function can be properly executed only with
generic devices, like PostScript.<br>
If this option is not selected, the drill holes of pads will be visible
on the output.


<a name=163>
<h1>Layers and Colors</h1>
Select the layer combination by clicking the check boxes in the
<i>Layer</i> list.
<p>
If you have selected an
<a href=#150>output device</a>
that supports colors, you can enter the color number
in the <i>Color</i> field of each layer.
<p>
The following layers and
<a href=#161>output file names</a>
are commonly used to create the output:
<pre>
-------------------------------------------------------
File   Layers               Meaning
-------------------------------------------------------
*.cmp  Top, Via, Pad        Component side
*.ly2  Route2, Via, Pad     Inner signal layer
*.ly3  Route3, Via, Pad     Inner signal layer
...                         ...
*.sol  Bot, Via, Pad        Solder side
*.plc  tPl, Dim, tName,     Silkscreen comp. side
*.pls  bPl, Dim, bName,     Silkscreen solder side
*.stc  tStop                Solder stop mask comp. side
*.sts  bStop                Solder stop mask sold. side
*.drd  Drills, Holes        Drill data for NC drill st.
-------------------------------------------------------
</pre>


<a name=164>
<h1>Outlines data</h1>
EAGLE can produce outlines data which can be used for milling prototype boards.
<p>
The User Language Program <i>outlines.ulp</i> implements the entire process
necessary to do this. The following is a detailed description of what exactly has to
be done to produce outlines data with EAGLE.
<h2>Preparing the board</h2>
Outlines data is produced by defining a <a href=#98>POLYGON</a>
in the layer for which the outlines shall be calculated.
This polygon must have the following properties:
<ul>
<li>its name must be _OUTLINES_
<li>it must be the <b>only</b> object in the signal named _OUTLINES_
<li>its <i>Rank</i> must be <tt>'6'</tt>
<li>its <i>Width</i> must be the same as the diameter of the milling tool
<li>it must be large enough to cover the entire board area
</ul>
If a polygon with these properties is present in your board, the
<a href=#104>RATSNEST</a> command will calculate it in such
a way that its <i>contours</i> correspond to the lines that have to be drawn by
the milling tool to isolate the various signals from each other.
The <i>fillings</i> of the calculated polygon define what has to be milled out
if you want to completely remove all superfluous copper areas.
<h2>Extracting the data</h2>
The outlines data can be extracted from the board through a
<a href=#173>User Language Program</a>. The <i>outlines.ulp</i>
program that comes with EAGLE implements this entire process. If you want to
write your own ULP you can use <i>outlines.ulp</i> as a starting point.
See the help page for <a href=#239>UL_POLYGON</a> for details
about how to retrieve the outlines data from a polygon object.
<h2>Milling tool diameter</h2>
The diameter of the milling tool (and thus the <i>Width</i> of the polygon) must
be small enough to fit between any two different signals in order to be able to
isolate them from each other.<br>
<b>Make sure you run a <a href=#53>Design Rule Check</a> (DRC) with
all <i>Clearance</i> values for different signals set to at least the diameter
of your milling tool!</b>
<p>
Non-zero values for the Isolate parameter can be used when working sequentially
with different milling tool diameters in order to avoid areas that have already
been milled.
<h2>Cleaning up</h2>
Make sure that you always delete the _OUTLINES_ polygon after generating the
outlines data. Leaving this polygon in your drawing will cause short circuits
since this special polygon does not adhere to the <a href=#168>Design Rules</a>!


<a name=165>
<h1>Group Default ON</h1>
Eagle includes by default a new and more intuitive way to work.
<p>
With a schematic or board open, Under Options/Set/Misc, these new group-related features are
enabled by checking the box labeled "Group default on".
<p>
When Group default on is checked, the following features are enabled:
    <ul>
    <li>Group command is on by default when no other comand is active. (The default operation is always to make a selection) </li>
    <li>Clear Group: Press ESC key to clear the objects selected in the current group.</li>
    <li>Automatic MOVE: After seleting one or more objects, click and drag on any object in the group to MOVE the group.</li>
    <li>Incremental Selection: Press CTRL (CMD on mac) key to incrementally add or remove objects from the current group.</li>
    <li>Cycle selection: Press and hold ALT key and left-click mouse on dense area to switch between multiple objects. When the object desired to be selected is highlighted, move the mouse away from the area to save the selection. Alternatively you can still use legacy style right-click mouse to cycle to next available object. </li>
    <li>Group polygon selection: Left-click to define polygon selection points.  The first point must NOT be on an object.  </li>
    <li>Delete objects: Use the Backspace key (Delete on mac) to delete the currently selected objects (those in the current group)</li>
    </ul>
<p>
See also <a href=#62>GROUP</a>, <a href=#83>MOVE</a>, <a href=#49>DELETE</a>


<a name=166>
<h1>Autorouter</h1>
The integrated Autorouter can be started from a board window with the
<a href=#37>AUTO</a> command.
<p>
The Autorouter is also used as "Follow-me" router in the
<a href=#113>ROUTE</a> command.
<p>
Please check your <a href=#409>license</a>
to see whether you have access to the Autorouter module.


<a name=167>
<h1>Design Checks</h1>
There are two integrated commands that allow you to check your design:
<ul>
<li>Electrical Rule Check (<a href=#55>ERC</a>)
<li>Design Rule Check (<a href=#53>DRC</a>)
</ul>
The ERC is performed in a schematic window, and checks the design for
electrical consistency.
<p>
The DRC is performed in a board window, and checks the design for overlaps,
distance violations etc.


<a name=168>
<h1>Design Rules</h1>
<i>Design Rules</i> define all the parameters that the board layout has to follow.
<p>
The <a href=#53>Design Rule Check</a> checks the board against these rules
and reports any violations.
<p>
The Design Rules of a board can be modified through the Design Rules dialog, which
appears if the <a href=#53>DRC</a> command is selected without a terminating
<tt>';'</tt>.
<p>
Newly created boards take their design rules from the file 'default.dru',
which is searched for in the first directory listed in the "Options/Directories/Design rules" path.
If no such file is present, the program's builtin default values apply.
<p>
<b>Note</b> regarding the values for <b>Clearance</b> and <b>Distance</b>:
The accuracy is limited by the internal resolution of coordinates (1/320000mm).
<h2>File</h2>
The <i>File</i> tab shows a description of the current set of Design Rules and
allows you to <i>change</i> that description (this is strongly recommended if you define
your own Design Rules). There are also buttons to <i>load</i> a different set of Design
Rules from a disk file and to <i>save</i> the current Design Rules to disk.<br>
Note that the Design Rules are stored within the board file, so they will be in effect
if the board file is sent to a board house for production. The "Load..." and "Save as..."
buttons are merely for copying a board's Design Rules to and from disk.
<p>
If the Design Rules have been modified, the name in the dialog's title will have
trailing asterisk (<tt>'*'</tt>) to mark the Design Rules as modified. This mark
will be removed once the Design Rules are explicitly written to disk, or a new set
of Design Rules is loaded.
<h2>Layers</h2>
The <i>Layers</i> tab defines which signal layers the board actually uses, how thick
the copper and isolation layers are, and what kinds of vias can be placed
(note that this applies only to actual <i>vias</i>; so even if no via from layer 1 to
16 has been defined in the layer setup, <i>pads</i> will always be allowed).
<p>
The layer setup is defined by the string in the "Setup" field. This string consists of
a sequence of layer numbers, separated by one of the characters <tt>'*'</tt> or
<tt>'+'</tt>, where <tt>'*'</tt> stands for <i>core</i> material (also known as <i>FR4</i>
or something similar) and <tt>'+'</tt> stands for <i>prepreg</i> (or any other kind of
isolation material). The actual <i>core</i> and <i>prepreg</i> sequence has no meaning
to EAGLE other than varying the color in the layer display at the top left corner
of this tab (the actual multilayer setup always needs to be worked out with the
board manufacturer). The vias are defined by enclosing a sequence of layers with <tt>(...)</tt>.
So the setup string
<pre>
(1*16)
</pre>
would mean a two layer board, using layers 1 and 16 and vias going through the
entire board (this is also the default value).<br>
When building a multilayer board the setup could be something like
<pre>
((1*2)+(15*16))
</pre>
which is a four layer board with layer pairs 1/2 and 15/16 built on core material
and vias drilled through them, and finally the two layer pairs pressed together
with prepreg between them, and vias drilled all the way through the entire board.<br>
Besides vias that go trough an entire layer stack (which are commonly referred to
as <i>buried</i> vias in case they have no connection to the Top and Bottom layer)
there can also be vias that are not drilled all the way through a layer stack, but
rather end at a layer inside that stack. Such vias are known as <i>blind</i> vias
and are defined in the "Setup" string by enclosing a sequence of layers with
<tt>[t:...:b]</tt>, where <i>t</i> and <i>b</i> are the layers up to which that via
will go from the top or bottom side, respectively. A possible setup with <i>blind</i>
vias could be
<pre>
[2:1+((2*3)+(14*15))+16:15]
</pre>
which is basically the previous example, with two additional outer layers that are
connected to the next inner layers by <i>blind</i> vias. It is also
possible to have only one of the <i>t</i> or <i>b</i> parameters, so for instance
<pre>
[2:1+((2*3)+(15*16))]
</pre>
would also be a valid setup. Finally, <i>blind</i> vias are not limited to starting
at the Top or Bottom layer, but may also be used in inner layer stacks, as in
<pre>
[2:1+[3:2+(3*4)+5:4]+16:5]
</pre>
A <i>blind</i> via from layer <i>a</i> to layer <i>b</i> also implements all possible
<i>blind</i> vias from layer <i>a</i> to all layers between layers <i>a</i> and <i>b</i>, so
<pre>
[3:1+2+(3*16)]
</pre>
would allow <i>blind</i> vias from layer 1 to 2 as well as from 1 to 3.
<h2>Clearance</h2>
The <i>Clearance</i> tab defines the various minimum clearance values between objects
in signal layers. These are usually absolute minimum values that are defined by the
production process used and should be obtained from your board manufacturer.<br>
The actual minimum clearance between objects that belong to different signals will
also be influenced by the <a href=#44>net classes</a> the two signals belong to.
<p>
Note that a polygon in the special signal named _OUTLINES_ will be used to generate
<a href=#164>outlines data</a> and as such will <b>not</b> adhere to these
clearance values.
<h2>Distance</h2>
The <i>Distance</i> tab defines the minimum distance between objects in signal layers
and the board dimensions, as well as that between any two drill holes.
Note that only signals that are actually connected to at least one pad or
smd are checked against the board dimensions. This allows edge markers to be drawn
in the signal layer without generating DRC errors.
<p>
For compatibility with version 3.5x the following applies:
If the minimum distance between copper and dimension is set to <tt>0</tt>
objects in the Dimension layer will not be taken into account when calculating
polygons (except for Holes, which are always taken into account). This also disables
the distance check between copper and dimension objects.
<h2>Sizes</h2>
The <i>Sizes</i> tab defines the minimum width of any objects in signal layers and
the minimum drill diameter. These are usually absolute minimum values that are defined by the
production process used and should be obtained from your board manufacturer.<br>
The actual minimum width of signal wires and drill diameter of vias will
also be influenced by the Net Class the signal belongs to.
<h2>Restring</h2>
The <i>Restring</i> tab defines the width of the copper ring that has to remain after the
pad or via has been drilled. Values are defined in percent of the drill diameter and
there can be an absolute minimum and maximum limit. Restrings for pads can be different
for the top, bottom and inner layers, while for vias they can be different for the
outer and inner layers.<br>
If the actual diameter of a pad (as defined in the library) or a via would result in a
larger restring, that value will be used in the outer layers. Pads in library footprints
can have their diameter set to 0, so that the restring will be derived entirely
from the drill diameter.
<h2>Shapes</h2>
The <i>Shapes</i> tab defines the actual shapes for smds and pads.<br>
Smds are normally defined as rectangles in the library (with a "roundness" of 0),
but if your design requires rounded smds you can specify the roundness factor here.<br>
Pads are normally defined as octagons in the library (long octagons where this makes
sense), and you can use the combo boxes to specify whether you want to have
pads with the same shapes as defined in the library, or always square, round or
octagonal. This can be set independently for the top and bottom layer.<br>
If the "first" pad of a footprint has been marked as such in the library
it will get the shape as defined in the third combo box (either round, square or
octagonal, or no special shape).<br>
The Elongation parameters define the appearance of pads with shape Long or Offset.
<h2>Supply</h2>
The <i>Supply</i> tab defines the Thermal isolation between pads and signal
polygons.
<h2>Masks</h2>
The <i>Masks</i> tab defines the dimensions of solder stop and cream masks. They are
given in percent of the smaller dimension of smds, pads and vias and can have an
absolute minimum and maximum value.<br>
Solder stop masks are generated for smds, pads and those vias that have a drill diameter
that exceeds the given Limit parameter.<br>
Cream masks are generated for smds only.
<h2>Misc</h2>
The <i>Misc</i> tab allows you to turn on a stop mask check.
Beside that you can define whether checking for texts in signal layers not written in vectorfont
shall be made (default on). There's also an option for checking for copper in restricted areas
(layers tRestrict/bRestrict. Default is on).
<p>


<a name=169>
<h1>Cross-references</h1>
There are various methods that can be used to create cross-references
in EAGLE schematic drawings. The following sections describe each of them.
<ul>
<li><a href=#170>Cross-reference labels</a>
<li><a href=#171>Part cross-references</a>
<li><a href=#172>Contact cross-references</a>
</ul>


<a name=170>
<h1>Cross-reference labels</h1>
A plain label can be used to make the name of a net visible in a schematic.
If a label has the <i>xref</i> property activated, its behavior is changed
so that it becomes a <i>cross-reference label</i>.
<p>
Cross-reference labels are typically placed at the right or left border of
a schematic sheet, and indicate the next (or previous) sheet a particular net
is used on. See the <a href=#68>LABEL</a> command for a detailed
description of how this works.


<a name=171>
<h1>Part cross-references</h1>
Electrical schematics often use electro-mechanical relays, consisting of a
coil and one or more contact symbols. If the coil and contacts are distributed
over various schematic sheets, it is useful to have each contact indicate
which sheet its coil is on. This can be achieved by giving the coil gate in
the device set an add level of <i>Must</i> (see the <a href=#31>ADD</a>
command) and placing the text variable <tt>'&gt;XREF'</tt> somewhere in the
contacts' symbols (see the <a href=#131>TEXT</a> command).
<p>
When actually displayed, the <tt>'&gt;XREF'</tt> text variable will be replaced
with the sheet number, frame column and row (according to the
<a href=#116>part cross-reference format</a>) of the <i>Must</i>
gate of this device.
<p>
See <a href=#172>Contact cross-references</a> on how
to display the contact locations on the coil's sheet.


<a name=172>
<h1>Contact cross-references</h1>
On a multi-sheet electrical schematic with electro-mechanical relays that
have their coils and contacts distributed over various sheets, it is useful
to be able to see which sheets the individual contacts of a relay are on.
EAGLE can automatically display this <i>contact cross-reference</i> for each
relay coil if the following conditions are met.
<p>
The contact symbols need to contain the <tt>'&gt;XREF'</tt> text variable
in order to generate <a href=#171>part cross-references</a>.
<p>
The gate symbols shall be drawn in a way that the pins extend up and down,
and that the origin is at the center of the symbol.
<p>
The first contact gate in the device set drawing shall be placed at an x-coordinate
of 0, and its y-coordinate shall be high enough to make sure its lower pin is in the
positive area, typically at 100mil. The rest of the contact gates shall be placed
to the right of the first one, with their origins at the same y-coordinate as the
first one. The coil gate can be placed at an arbitrary location.
<p>
In the schematic drawing the contact cross-reference will be shown at the same
x-coordinate as the coil instance, and right below the y-coordinate defined
by the text variable <tt>'&gt;CONTACT_XREF'</tt>. This text variable can be
defined either in a drawing frame symbol or directly on the sheet. If it is
present in both, the one in the sheet is taken. The actual text will not be visible
in the schematic sheet.
<p>
The graphical representation of the contact cross-reference consists of all the
gates that have an <tt>'&gt;XREF'</tt> text variable (except for the first <i>Must</i>
gate, which is the coil and typically doesn't have this variable). The gates are
rotated by 90 degrees and are shown from top to bottom at the same offsets
as they have been drawn from left to right in the device set. Their sheet numbers and
frame locations are displayed to the right of each gate that is actually used.
Any other texts that have been defined in the symbol drawings will not be
displayed when using these symbols for generating the contact cross-reference.
<p>
Note that the contact cross-reference can't be selected with the mouse. If you
want to move it, move the coil instance and the contact cross-reference will
automatically follow it.
The contact cross-reference may get out of sync in case contact gates are
invoked, moved, deleted or swapped, or if the <tt>'&gt;CONTACT_XREF'</tt> text
variable is modified. This will automatically be updated at the next window refresh.


<a name=173>
<h1>User Language</h1>
The EAGLE User Language can be used to access the EAGLE data structures
and to create a wide variety of output files.
<p>
To use this feature you have to
<a href=#174>write a User Language Program (ULP)</a>,
and then <a href=#175>execute</a> it.
<p>
The following sections describe the EAGLE User Language in detail:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#176>Syntax</a>             </td><td width=20><td>lists the rules a ULP file has to follow</td></tr>
<tr><td><a href=#199>Data Types</a>         </td><td width=20><td>defines the basic data types</td></tr>
<tr><td><a href=#206>Object Types</a>       </td><td width=20><td>defines the EAGLE objects</td></tr>
<tr><td><a href=#254>Definitions</a>        </td><td width=20><td>shows how to write a definition</td></tr>
<tr><td><a href=#258>Operators</a>          </td><td width=20><td>lists the valid operators</td></tr>
<tr><td><a href=#265>Expressions</a>        </td><td width=20><td>shows how to write expressions</td></tr>
<tr><td><a href=#272>Statements</a>         </td><td width=20><td>defines the valid statements</td></tr>
<tr><td><a href=#284>Builtins</a> </td><td width=20><td>lists the builtin constants, functions etc.</td></tr>
<tr><td><a href=#365>Dialogs</a> </td><td width=20><td>shows how to implement a graphical frontent to a ULP</td></tr>
</table>


<a name=174>
<h1>Writing a ULP</h1>
A User Language Program is a plain text file which is written in a C-like
<a href=#176>syntax</a>.
User Language Programs use the extension <tt>.ulp</tt>.
You can create a ULP file with any text editor (provided it does
not insert any additional control characters into the file) or you can
use the <a href=#28>builtin text editor</a>.
<p>
A User Language Program consists of two major items,
<a href=#254>definitions</a> and
<a href=#272>statements</a>.
<p>
<a href=#254>Definitions</a> are used to define constants,
variables and functions to be used by <a href=#272>statements</a>.
<p>
A simple ULP could look like this:
<pre>
#usage "Add the characters in the word 'Hello'\n"
       "Usage: RUN sample.ulp"
// Definitions:
string hello = "Hello";
int count(string s)
{
  int c = 0;
  for (int i = 0; s[i]; ++i)
      c += s[i];
  return c;
}
// Statements:
output("sample") {
  printf("Count is: %d\n", count(hello));
  }
</pre>
If the <tt><a href=#182>#usage</a></tt> directive is present,
its value will be used in the <a href=#13>Control Panel</a> to display a description
of the program.
<p>
If the result of the ULP shall be a specific command that shall be executed in the
editor window, the <tt><a href=#306>exit()</a></tt> function can be
used to send that command to the editor window.


<a name=175>
<h1>Executing a ULP</h1>
User Language Programs are executed by the
<a href=#114>RUN</a> command from an editor window's command line.
<p>
A ULP can return information on whether it has run successfully or not.
You can use the <tt><a href=#306>exit()</a></tt> function to terminate
the program and set the return value.
<p>
A return value of <tt>0</tt> means the ULP has ended "normally" (i.e.
successfully), while any other value is considered as an abnormal
program termination.
<p>
The default return value of any ULP is <tt>0</tt>.
<p>
When the <a href=#114>RUN</a> command is executed as part of a
<a href=#115>script file</a>, the script is terminated if
the ULP has exited with a return value other than <tt>0</tt>.
<p>
A special variant of the <tt><a href=#306>exit()</a></tt> function can be
used to send a command to the editor window as a result of the ULP.


<a name=176>
<h1>Syntax</h1>
The basic building blocks of a User Language Program are
<ul>
<li><a href=#177>Whitespace</a>
<li><a href=#178>Comments</a>
<li><a href=#179>Directives</a>
<li><a href=#183>Keywords</a>
<li><a href=#184>Identifiers</a>
<li><a href=#185>Constants</a>
<li><a href=#191>Punctuators</a>
</ul>
All of these have to follow certain syntactical rules, which are
described in their respective sections.


<a name=177>
<h1>Whitespace</h1>
Before a User Language Program can be executed, it has to be read in from
a file. During this read in process, the file contents is <i>parsed</i>
into tokens and <i>whitespace</i>.
<p>
Any spaces (blanks), tabs, newline characters and
<a href=#178>comments</a> are considered <i>whitespace</i>
and are discarded.
<p>
The only place where ASCII characters representing <i>whitespace</i>
are not discarded is within <a href=#185>literal strings</a>,
like in
<pre>
string s = "Hello World";
</pre>
where the blank character between <tt>'o'</tt> and <tt>'W'</tt> remains part
of the string.
<p>
If the final newline character of a line is preceded by a backslash
(<tt>\</tt>), the backslash and newline character are both discarded,
and the two lines are treated as one line:
<pre>
"Hello \
World"
</pre>
is parsed as <tt>"Hello World"</tt>


<a name=178>
<h1>Comments</h1>
When writing a User Language Program it is good practice to add some
descriptive text, giving the reader an idea about what this particular
ULP does. You might also want to add your name (and, if available, your
email address) to the ULP file, so that other people who use your program
could contact you in case they have a problem or would like to suggest
an improvement.
<p>
There are two ways to define a comment. The first one uses the syntax
<pre>
/* some comment text */
</pre>
which marks any characters between (and including) the opening
<tt>/*</tt> and the closing <tt>*/</tt> as comment. Such comments may expand over
more than one lines, as in
<pre>
/* This is a
   multi line comment
*/
</pre>
but they do not nest. The first <tt>*/</tt> that follows any <tt>/*</tt>
will end the comment.
<p>
The second way to define a comment uses the syntax
<pre>
int i; // some comment text
</pre>
which marks any characters after (and including) the <tt>//</tt> and up
to (but not including) the newline character at the end of the line as
comment.


<a name=179>
<h1>Directives</h1>
The following <i>directives</i> are available:
<pre>
<a href=#180>#include</a>
<a href=#181>#require</a>
<a href=#182>#usage</a>
</pre>


<a name=180>
<h1>#include</h1>
A User Language Program can reuse code in other ULP files through the <tt>#include</tt>
directive. The syntax is
<pre>
#include "<i>filename</i>"
</pre>
The file <tt>filename</tt> is first looked for in the same directory as
the current source file (that is the file that contains the <tt>#include</tt>
directive). If it is not found there, it is searched for in
the directories contained in the ULP directory path.
<p>
The maximum include depth is 10.
<p>
Each <tt>#include</tt> directive is processed only <b>once</b>. This makes sure
that there are no multiple definitions of the same variables or functions, which
would cause errors.
<h2>Portability note</h2>
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
If <i>filename</i> contains a directory path, it is best to always use the
<b>forward slash</b> as directory separator (even under Windows!). Windows drive
letters should be avoided. This way a User Language Program will run on all
platforms.
</td></tr></table>


<a name=181>
<h1>#require</h1>
Over time it may happen that newer versions of EAGLE implement new or modified
User Language features, which can cause error messages when such a ULP is run
from an older version of EAGLE. In order to give the user a dedicated message
that this ULP requires at least a certain version of EAGLE, a ULP can contain
the <tt>#require</tt> directive. The syntax is
<pre>
#require <i>version</i>
</pre>
The <i>version</i> must be given as a <a href=#188>real constant</a>
of the form
<pre>
V.RRrr
</pre>
where <tt>V</tt> is the version number, <tt>RR</tt> is the release number
and <tt>rr</tt> is the (optional) revision number (both padded with leading
zeros if they are less than 10). For example, if a ULP
requires at least EAGLE version 4.11r06 (which is the beta version that first
implemented the <tt>#require</tt> directive), it could use
<pre>
#require 4.1106
</pre>
The proper directive for version 5.1.2 would be
<pre>
#require 5.0102
</pre>


<a name=182>
<h1>#usage</h1>
Every User Language Program should contain information about its function, how
to use it and maybe who wrote it.<br>
The directive
<pre>
#usage <i>text</i> [, <i>text</i>...]
</pre>
implements a standard way to make this information available.
<p>
If the <tt>#usage</tt> directive is present,
its <tt>text</tt> (which has to be a <a href=#189>string constant</a>)
will be used in the <a href=#13>Control Panel</a> to display a description
of the program.
<p>
In case the ULP needs to use this information in, for example, a
<a href=#369>dlgMessageBox()</a>, the <tt>text</tt> is available
to the program through the <a href=#285>builtin constant</a>
<tt>usage</tt>.
<p>
Only the <tt>#usage</tt> directive of the main program file (that is the one
started with the <a href=#114>RUN</a> command) will take effect.
Therefore pure <a href=#180>include</a> files can (and should!)
also have <tt>#usage</tt> directives of their own.
<p>
It is best to have the <tt>#usage</tt> directive at the beginning of the file,
so that the Control Panel doesn't have to parse all the rest of the text when
looking for the information to display.
<p>
If the usage information shall be made available in several langauges, the
texts of the individual languages have to be separated by commas.
Each of these texts has to start with the two letter code of the respective
language (as delivered by the <a href=#308>language()</a> function),
followed by a colon and any number of blanks. If no suitable text is found for
the language used on the actual system, the first given text will be used (this
one should generally be English in order to make the program accessible to the
largest number of users).
<h2>Example</h2>
<pre>
#usage "en: A sample ULP\n"
           "Implements an example that shows how to use the EAGLE User Language\n"
           "Usage: RUN sample.ulp\n"
           "Author: john@home.org",
       "de: Beispiel eines ULPs\n"
           "Implementiert ein Beispiel das zeigt, wie man die EAGLE User Language benutzt\n"
           "Aufruf: RUN sample.ulp\n"
           "Author: john@home.org"
</pre>


<a name=183>
<h1>Keywords</h1>
The following <i>keywords</i> are reserved for special purposes
and must not be used as normal identifier names:
<pre>
<a href=#276>break</a>
<a href=#282>case</a>
<a href=#200>char</a>
<a href=#277>continue</a>
<a href=#282>default</a>
<a href=#278>do</a>
<a href=#280>else</a>
<a href=#255>enum</a>
<a href=#279>for</a>
<a href=#280>if</a>
<a href=#201>int</a>
<a href=#256>numeric</a>
<a href=#202>real</a>
<a href=#281>return</a>
<a href=#203>string</a>
<a href=#282>switch</a>
<a href=#199>void</a>
<a href=#283>while</a>
</pre>
In addition, the names of
<a href=#284>builtins</a> and
<a href=#206>object types</a>
are also reserved and must not be used as identifier names.


<a name=184>
<h1>Identifiers</h1>
An <i>identifier</i> is a name that is used to introduce a user defined
<a href=#255>constant</a>,
<a href=#256>variable</a> or
<a href=#257>function</a>.
<p>
Identifiers consist of a sequence of letters (<tt>a b c</tt>..., <tt>A B C</tt>...),
digits (<tt>1 2 3</tt>...) and underscores (<tt>_</tt>). The first character
of an identifier <b>must</b> be a letter or an underscore.
<p>
Identifiers are case-sensitive, which means that
<pre>
int Number, number;
</pre>
would define two <b>different</b> integer variables.
<p>
The maximum length of an identifier is 100 characters, and all of these
are significant.


<a name=185>
<h1>Constants</h1>
Constants are literal data items written into a User Language Program.
According to the different <a href=#199>data types</a>,
there are also different types of constants.
<ul>
<li><a href=#186>Character constants</a>
<li><a href=#187>Integer constants</a>
<li><a href=#188>Real constants</a>
<li><a href=#189>String constants</a>
</ul>


<a name=186>
<h1>Character Constants</h1>
A <i>character constant</i> consists of a single character or
an <a href=#190>escape sequence</a> enclosed in
single quotes, like
<pre>
'a'
'='
'\n'
</pre>
The type of a character constant is
<tt><a href=#200>char</a></tt>.


<a name=187>
<h1>Integer Constants</h1>
Depending on the first (and possibly the second) character, an
<i>integer constant</i> is assumed to be expressed in different
base values:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>first</td>        <td width=20><td>second</td>       <td width=20><td>constant interpreted as</td></tr>
<tr><td><tt>0</tt></td>   <td width=20><td><tt>1-7</tt></td> <td width=20><td>octal (base 8)</td></tr>
<tr><td><tt>0</tt></td>   <td width=20><td><tt>x,X</tt></td> <td width=20><td>hexadecimal (base 16)</td></tr>
<tr><td><tt>1-9</tt></td> <td width=20><td>            </td> <td width=20><td>decimal (base 10)</td></tr>
</table>
<p>
The type of an integer constant is
<tt><a href=#201>int</a></tt>.
<h2>Examples</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>16</tt>      </td><td width=20><td>decimal</td></tr>
<tr><td><tt>020</tt>     </td><td width=20><td>octal</td></tr>
<tr><td><tt>0x10</tt>    </td><td width=20><td>hexadecimal</td></tr>
</table>


<a name=188>
<h1>Real Constants</h1>
A <i>real constant</i> follows the general pattern
<pre>
[-]<i>int</i>.<i>frac</i>[e|E[&plusmn;]<i>exp</i>]
</pre>
which stands for
<ul>
<li>optional sign
<li>decimal integer
<li>decimal point
<li>decimal fraction
<li><tt>e</tt> or <tt>E</tt> and a signed integer exponent
</ul>
You can omit either the decimal integer or the decimal fraction
(but not both). You can omit either the decimal point or the
letter <tt>e</tt> or <tt>E</tt> and the signed integer exponent
(but not both).
<p>
The type of an real constant is
<tt><a href=#202>real</a></tt>.
<h2>Examples</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Constant   </td><td width=20><td>Value</td></tr>
<tr><td><tt>23.45e6</tt>    </td><td width=20><td>23.45 x 10^6</td></tr>
<tr><td><tt>.0</tt>         </td><td width=20><td>0.0</td></tr>
<tr><td><tt>0.</tt>         </td><td width=20><td>0.0</td></tr>
<tr><td><tt>1.</tt>         </td><td width=20><td>1.0</td></tr>
<tr><td><tt>-1.23</tt>      </td><td width=20><td>-1.23</td></tr>
<tr><td><tt>2e-5</tt>       </td><td width=20><td>2.0 x 10^-5</td></tr>
<tr><td><tt>3E+10</tt>      </td><td width=20><td>3.0 x 10^10</td></tr>
<tr><td><tt>.09E34</tt>     </td><td width=20><td>0.09 x 10^34</td></tr>
</table>


<a name=189>
<h1>String Constants</h1>
A <i>string constant</i> consists of a sequence of characters or
<a href=#190>escape sequences</a> enclosed in
double quotes, like
<pre>
"Hello world\n"
</pre>
The type of a string constant is
<tt><a href=#203>string</a></tt>.
<p>
String constants can be of any length (provided there is enough free memory
available).
<p>
String constants can be concatenated by simply writing them next to each other
to form larger strings:
<pre>
string s = "Hello" " world\n";
</pre>
It is also possible to extend a string constant over more than one line
by escaping the newline character with a backslash (<tt>\</tt>):
<pre>
string s = "Hello \
world\n";
</pre>


<a name=190>
<h1>Escape Sequences</h1>
An <i>escape sequence</i> consists of a backslash (<tt>\</tt>), followed
by one or more special characters:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Sequence   </td><td width=20><td>Value</td></tr>
<tr><td><tt>\a</tt>  </td><td width=20><td>audible bell</td></tr>
<tr><td><tt>\b</tt>  </td><td width=20><td>backspace</td></tr>
<tr><td><tt>\f</tt>  </td><td width=20><td>form feed</td></tr>
<tr><td><tt>\n</tt>  </td><td width=20><td>new line</td></tr>
<tr><td><tt>\r</tt>  </td><td width=20><td>carriage return</td></tr>
<tr><td><tt>\t</tt>  </td><td width=20><td>horizontal tab</td></tr>
<tr><td><tt>\v</tt>  </td><td width=20><td>vertical tab</td></tr>
<tr><td><tt>\\</tt>  </td><td width=20><td>backslash</td></tr>
<tr><td><tt>\'</tt>  </td><td width=20><td>single quote</td></tr>
<tr><td><tt>\"</tt>  </td><td width=20><td>double quote</td></tr>
<tr><td><tt>\O</tt>  </td><td width=20><td><tt>O</tt> = up to 3 octal digits</td></tr>
<tr><td><tt>\xH</tt> </td><td width=20><td><tt>H</tt> = up to 2 hex digits</td></tr>
</table>
<p>
Any character following the initial backslash that is not mentioned in
this list will be treated as that character (without the backslash).
<p>
Escape sequences can be used in
<a href=#186>character constants</a> and
<a href=#189>string constants</a>.
<h2>Examples</h2>
<pre>
'\n'
"A tab\tinside a text\n"
"Ring the bell\a\n"
</pre>


<a name=191>
<h1>Punctuators</h1>
The <i>punctuators</i> used in a User Language Program are
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>[]</tt>  </td><td width=20><td><a href=#192>Brackets</a></td></tr>
<tr><td><tt>()</tt>  </td><td width=20><td><a href=#193>Parentheses</a></td></tr>
<tr><td><tt>{}</tt>  </td><td width=20><td><a href=#194>Braces</a></td></tr>
<tr><td><tt>,</tt>   </td><td width=20><td><a href=#195>Comma</a></td></tr>
<tr><td><tt>;</tt>   </td><td width=20><td><a href=#196>Semicolon</a></td></tr>
<tr><td><tt>:</tt>   </td><td width=20><td><a href=#197>Colon</a></td></tr>
<tr><td><tt>=</tt>   </td><td width=20><td><a href=#198>Equal sign</a></td></tr>
</table>
<p>
Other special characters are used as <a href=#258>operators</a>
in a ULP.


<a name=192>
<h1>Brackets</h1>
<i>Brackets</i> are used in array definitions
<pre>
int ai[];
</pre>
in array subscripts
<pre>
n = ai[2];
</pre>
and in string subscripts to access the individual characters of a string
<pre>
string s = "Hello world";
char c = s[2];
</pre>


<a name=193>
<h1>Parentheses</h1>
<i>Parentheses</i> group <a href=#265>expressions</a>
(possibly altering normal
<a href=#258>operator</a> precedence), isolate conditional
expressions, and indicate
<a href=#271>function calls</a> and function parameters:
<pre>
d = c * (a + b);
if (d == z) ++x;
func();
void func2(int n) { ... }
</pre>


<a name=194>
<h1>Braces</h1>
<i>Braces</i> indicate the start and end of a compound statement:
<pre>
if (d == z) {
   ++x;
   func();
   }
</pre>
and are also used to group the values of an array initializer:
<pre>
int ai[] = { 1, 2, 3 };
</pre>


<a name=195>
<h1>Comma</h1>
The <i>comma</i> separates the elements of a function argument list
or the parameters of a function call:
<pre>
int func(int n, real r, string s) { ... }
int i = func(1, 3.14, "abc");
</pre>
It also delimits the values of an array initializer:
<pre>
int ai[] = { 1, 2, 3 };
</pre>
and it separates the elements of a variable definition:
<pre>
int i, j, k;
</pre>


<a name=196>
<h1>Semicolon</h1>
The <i>semicolon</i> terminates a <a href=#272>statement</a>,
as in
<pre>
i = a + b;
</pre>
and it also delimits the init, test and increment expressions of a
<a href=#279>for</a> statement:
<pre>
for (int n = 0; n &lt; 3; ++n) {
    func(n);
    }
</pre>


<a name=197>
<h1>Colon</h1>
The <i>colon</i> indicates the end of a label in a
<a href=#282>switch</a> statement:
<pre>
switch (c) {
  case 'a': printf("It was an 'a'\n"); break;
  case 'b': printf("It was a  'b'\n"); break;
  default:  printf("none of them\n");
  }
</pre>


<a name=198>
<h1>Equal Sign</h1>
The <i>equal sign</i> separates variable definitions from initialization
lists:
<pre>
int i = 10;
char c[] = { 'a', 'b', 'c' };
</pre>
It is also used as an <a href=#263>assignment operator</a>.


<a name=199>
<h1>Data Types</h1>
A User Language Program can define variables of different types, representing
the different kinds of information available in the EAGLE data structures.
<p>
The four basic data types are
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt><a href=#200>char</a></tt>  </td><td width=20><td>for single characters</td></tr>
<tr><td><tt><a href=#201>int</a></tt>  </td><td width=20><td>for integral values</td></tr>
<tr><td><tt><a href=#202>real</a></tt>  </td><td width=20><td>for floating point values</td></tr>
<tr><td><tt><a href=#203>string</a></tt>  </td><td width=20><td>for textual information</td></tr>
</table>
<p>
Besides these basic data types there are also high level
<a href=#206>Object Types</a>, which
represent the data structures stored in the EAGLE data files.
<p>
The special data type <tt>void</tt> is used only as a return type of a
<a href=#257>function</a>, indicating that this
function does <b>not</b> return any value.


<a name=200>
<h1>char</h1>
The data type <tt>char</tt> is used to store single characters, like the
letters of the alphabet, or small unsigned numbers.
<p>
A variable of type <tt>char</tt> has a size of 8 bit (one byte), and can
store any value in the range <tt>0..255</tt>.
<p>
<b>See also</b> <a href=#258>Operators</a>,
<a href=#186>Character Constants</a>


<a name=201>
<h1>int</h1>
The data type <tt>int</tt> is used to store signed integral values, like the
coordinates of an object.
<p>
A variable of type <tt>int</tt> has a size of 32 bit (four byte), and can
store any value in the range <tt>-2147483648..2147483647</tt>.
<p>
<b>See also</b> <a href=#187>Integer Constants</a>


<a name=202>
<h1>real</h1>
The data type <tt>real</tt> is used to store signed floating point values, like
the grid distance.
<p>
A variable of type <tt>real</tt> has a size of 64 bit (eight byte), and can
store any value in the range <tt>&plusmn;2.2e-308..&plusmn;1.7e+308</tt> with a
precision of 15 digits.
<p>
<b>See also</b> <a href=#188>Real Constants</a>


<a name=203>
<h1>string</h1>
The data type <tt>string</tt> is used to store textual information,
like the name of a part or net.
<p>
A variable of type <tt>string</tt> is not limited in it's size (provided
there is enough memory available).
<p>
Variables of type <tt>string</tt> are defined without an explicit
<i>size</i>. They grow automatically as necessary during program
execution.
<p>
The elements of a <tt>string</tt> variable are of type
<tt><a href=#201>int</a></tt> and
can be accessed individually by using <tt>[index]</tt>.
The first character of a <tt>string</tt> has the index <tt>0</tt>:
<pre>
string s = "Layout";
printf("Third char is: %c\n", s[2]);
</pre>
This would print the character <tt>'y'</tt>. Note that <tt>s[2]</tt> returns
the <b>third</b> character of <tt>s</tt>!
<p>
A lossless conversion to <tt><a href=#200>char</a></tt> is possible
for standard ASCII strings:
<pre>
string s = "Layout";
char c = s[2];
</pre>
<p>
<b>See also</b> <a href=#258>Operators</a>,
<a href=#287>Builtin Functions</a>,
<a href=#189>String Constants</a>
<h2>Implementation details</h2>
The data type <tt>string</tt> is actually implemented like native C-type
zero terminated strings. Looking at the following variable definition
<pre>
string s = "abcde";
</pre>
<tt>s[4]</tt> is the character <tt>'e'</tt>, and <tt>s[5]</tt> is the character
<tt>'\0'</tt>, or the integer value <tt>0x00</tt>.
This fact may be used to determine the end of a string without using the
<tt><a href=#326>strlen()</a></tt> function, as in
<pre>
for (int i = 0; s[i]; ++i) {
    // do something with s[i]
    }
</pre>
It is also perfectly ok to "cut off" part of a string by "punching" a zero
character into it:
<pre>
string s = "abcde";
s[3] = 0;
</pre>
This will result in <tt>s</tt> having the value <tt>"abc"</tt>.
Note that everything following the zero character will actually be gone,
and it won't come back by restoring the original character. The same applies
to any other operation that sets a character to 0, for instance --s[3].


<a name=204>
<h1>Type Conversions</h1>
The result type of an arithmetic
<a href=#265>expression</a>, such as <tt>a + b</tt>,
where <tt>a</tt> and <tt>b</tt> are different arithmetic types,
is equal to the "larger" of the two operand types.
<p>
Arithmetic types are
<tt><a href=#200>char</a></tt>,
<tt><a href=#201>int</a></tt> and
<tt><a href=#202>real</a></tt>
(in that order). So if, e.g. <tt>a</tt> is of type
<tt><a href=#201>int</a></tt>
and <tt>b</tt> is of type
<tt><a href=#202>real</a></tt>,
the result of the expression <tt>a + b</tt> would be
<tt><a href=#202>real</a></tt>.
<p>
<b>See also</b> <a href=#205>Typecast</a>


<a name=205>
<h1>Typecast</h1>
The result type of an arithmetic <a href=#265>expression</a>
can be explicitly converted to a different arithmetic type by applying a
<i>typecast</i> to it.
<p>
The general syntax of a typecast is
<pre>
type(expression)
</pre>
where <tt>type</tt> is one of
<tt><a href=#200>char</a></tt>,
<tt><a href=#201>int</a></tt> or
<tt><a href=#202>real</a></tt>,
and <tt>expression</tt> is any arithmetic
<a href=#265>expression</a>.
<p>
When typecasting a <tt><a href=#202>real</a></tt> expression to
<tt><a href=#201>int</a></tt>, the fractional part of the value
is truncated!
<p>
<b>See also</b> <a href=#204>Type Conversions</a>


<a name=206>
<h1>Object Types</h1>
The EAGLE data structures are stored in XML files:
<ul>
<li>Library (*.lbr)
<li>Schematic (*.sch)
<li>Board (*.brd)
</ul>
These data files contain a hierarchy of objects.
In a User Language Program you can access these hierarchies through their
respective builtin access statements:
<pre>
<a href=#358>library</a>(L) { ... }
<a href=#362>schematic</a>(S) { ... }
<a href=#356>board</a>(B) { ... }
</pre>
These access statements set up a context within which you can access all of the
objects contained in the library, schematic or board.
<p>
The properties of these objects can be accessed through <i>members</i>.
<p>
There are two kinds of members:
<ul>
<li>Data members
<li>Loop members
</ul>
<b>Data members</b> immediately return the requested data from an object.
For example, in
<pre>
board(B) {
  printf("%s\n", B.name);
  }
</pre>
the data member <i>name</i> of the board object <i>B</i> returns
the board's name.<br>
Data members can also return other objects, as in
<pre>
board(B) {
  printf("%f\n", B.grid.size);
  }
</pre>
where the board's <i>grid</i> data member returns a grid object,
of which the <i>size</i> data member then returns the grid's size.
<p>
<b>Loop members</b> are used to access multiple objects of the same
kind, which are contained in a higher level object:
<pre>
board(B) {
  B.elements(E) {
    printf("%-8s %-8s\n", E.name, E.value);
    }
  }
</pre>
This example uses the board's <i>elements()</i> loop member function
to set up a loop through all of the board's elements. The block following
the <tt>B.elements(E)</tt> statement is executed in turn for each element,
and the current element can be referenced inside the block through the name
<tt>E</tt>.
<p>
Loop members process objects in alpha-numerical order, provided they
have a name.
<p>
A loop member function creates a variable of the type necessary to hold
the requested objects. You are free to use any valid name for such a
variable, so the above example might also be written as
<pre>
board(MyBoard) {
  MyBoard.elements(TheCurrentElement) {
    printf("%-8s %-8s\n", TheCurrentElement.name, TheCurrentElement.value);
    }
  }
</pre>
and would do the exact same thing. The scope of the variable created by a
loop member function is limited to the statement (or block) immediately
following the loop function call.
<p>
<h2>Object hierarchy of a Library:</h2>
<pre>
<a href=#229>LIBRARY</a>
  <a href=#223>GRID</a>
  <a href=#228>LAYER</a>
  <a href=#217>DEVICESET</a>
    <a href=#216>DEVICE</a>
    <a href=#222>GATE</a>
  <a href=#233>FOOTPRINT</a>
    <a href=#214>CONTACT</a>
      <a href=#235>PAD</a>
      <a href=#247>SMD</a>
    <a href=#212>CIRCLE</a>
    <a href=#224>HOLE</a>
    <a href=#242>RECTANGLE</a>
    <a href=#221>FRAME</a>
    <a href=#218>DIMENSION</a>
    <a href=#249>TEXT</a>
    <a href=#253>WIRE</a>
    <a href=#239>POLYGON</a>
      <a href=#253>WIRE</a>
  <a href=#234>PACKAGE3D</a>
  <a href=#248>SYMBOL</a>
    <a href=#237>PIN</a>
    <a href=#212>CIRCLE</a>
    <a href=#242>RECTANGLE</a>
    <a href=#221>FRAME</a>
    <a href=#218>DIMENSION</a>
    <a href=#249>TEXT</a>
    <a href=#253>WIRE</a>
    <a href=#239>POLYGON</a>
      <a href=#253>WIRE</a>
</pre>
<h2>Object hierarchy of a Schematic:</h2>
<pre>
<a href=#243>SCHEMATIC</a>
  <a href=#223>GRID</a>
  <a href=#228>LAYER</a>
  <a href=#229>LIBRARY</a>
  <a href=#209>ATTRIBUTE</a>
  <a href=#250>VARIANTDEF</a>
  <a href=#236>PART</a>
    <a href=#209>ATTRIBUTE</a>
    <a href=#251>VARIANT</a>
  <a href=#245>SHEET</a>
    <a href=#212>CIRCLE</a>
    <a href=#242>RECTANGLE</a>
    <a href=#221>FRAME</a>
    <a href=#218>DIMENSION</a>
    <a href=#249>TEXT</a>
    <a href=#253>WIRE</a>
    <a href=#239>POLYGON</a>
      <a href=#253>WIRE</a>
    <a href=#225>INSTANCE</a>
      <a href=#209>ATTRIBUTE</a>
    <a href=#231>MODULEINST</a>
    <a href=#211>BUS</a>
      <a href=#244>SEGMENT</a>
        <a href=#227>LABEL</a>
          <a href=#249>TEXT</a>
          <a href=#253>WIRE</a>
        <a href=#253>WIRE</a>
    <a href=#232>NET</a>
      <a href=#244>SEGMENT</a>
        <a href=#226>JUNCTION</a>
        <a href=#238>PINREF</a>
        <a href=#241>PORTREF</a>
        <a href=#249>TEXT</a>
        <a href=#253>WIRE</a>
  <a href=#230>MODULE</a>
    <a href=#236>PORT</a>
    <a href=#236>PART</a>
    <a href=#245>SHEET</a>
      (same as above)
</pre>
<h3>Change note from version 5 to version 6, compatibility</h3>
<ul>
<li>Since version 6 the instance is in the hierarchy no longer below the part but below the sheet.</li>
<li>The part is no longer below the sheet, but below the schematic.</li>
</ul>
For compatibility reasons the access by the according member functions is further supported,
but the behaviour of the <a href=#344>Object Functions</a> reflects the new hierarchy.
<h2>Object hierarchy of a Board:</h2>
<pre>
<a href=#210>BOARD</a>
  <a href=#223>GRID</a>
  <a href=#228>LAYER</a>
  <a href=#229>LIBRARY</a>
  <a href=#209>ATTRIBUTE</a>
  <a href=#250>VARIANTDEF</a>
  <a href=#212>CIRCLE</a>
  <a href=#224>HOLE</a>
  <a href=#242>RECTANGLE</a>
  <a href=#221>FRAME</a>
  <a href=#218>DIMENSION</a>
  <a href=#249>TEXT</a>
  <a href=#253>WIRE</a>
  <a href=#239>POLYGON</a>
    <a href=#253>WIRE</a>
  <a href=#219>ELEMENT</a>
    <a href=#209>ATTRIBUTE</a>
    <a href=#251>VARIANT</a>
  <a href=#246>SIGNAL</a>
    <a href=#215>CONTACTREF</a>
    <a href=#239>POLYGON</a>
      <a href=#253>WIRE</a>
    <a href=#252>VIA</a>
    <a href=#253>WIRE</a>
</pre>


<a name=207>
<h1>UL_ARC</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle1</tt>       </td><td width=20><td><a href=#202>real</a> (start angle, <tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>angle2</tt>       </td><td width=20><td><a href=#202>real</a> (end angle, <tt>0.0</tt>...<tt>719.9</tt>)</td></tr>
<tr><td><tt>cap</tt>          </td><td width=20><td><a href=#201>int</a> (<tt>CAP_...</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>radius</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#201>int</a> (starting point)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#201>int</a> (end point)</td></tr>
<tr><td><tt>xc, yc</tt>       </td><td width=20><td><a href=#201>int</a> (center point)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#253>UL_WIRE</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CAP_FLAT</tt>  </td><td width=20><td>flat arc ends</td></tr>
<tr><td><tt>CAP_ROUND</tt>   </td><td width=20><td>round arc ends</td></tr>
</table>
<h2>Note</h2>
Start and end angles are defined mathematically positive (i.e. counterclockwise),
with <tt>angle1</tt> &lt; <tt>angle2</tt>.
In order to assure this condition, the start and end point of an UL_ARC may be exchanged
with respect to the UL_WIRE the arc has been derived from.
<h2>Example</h2>
<pre>
board(B) {
  B.wires(W) {
    if (W.arc)
       printf("Arc: (%f %f), (%f %f), (%f %f)\n",
              u2mm(W.arc.x1), u2mm(W.arc.y1), u2mm(W.arc.x2), u2mm(W.arc.y2), u2mm(W.arc.xc), u2mm(W.arc.yc));
    }
  }
</pre>


<a name=208>
<h1>UL_AREA</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#201>int</a> (lower left corner)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#201>int</a> (upper right corner)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#216>UL_DEVICE</a>,
<a href=#233>UL_FOOTPRINT</a>,
<a href=#245>UL_SHEET</a>,
<a href=#248>UL_SYMBOL</a>
<p>
A UL_AREA is an abstract object which gives information about the area
covered by an object. For a UL_FOOTPRINT or UL_SYMBOL in a UL_ELEMENT or
UL_INSTANCE context, respectively, the area is given in absolute drawing
coordinates, including the offset of the element or instance and including
the area of moved texts after <a href=#122>REPOSITION</a>.
<h2>Example</h2>
<pre>
board(B) {
  printf("Area: (%f %f), (%f %f)\n",
          u2mm(B.area.x1), u2mm(B.area.y1), u2mm(B.area.x2), u2mm(B.area.y2));
  }
</pre>


<a name=209>
<h1>UL_ATTRIBUTE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>constant</tt>    </td><td width=20><td><a href=#201>int</a> (0=variable, i.e. allows overwriting, 1=constant - see note)</td></tr>
<tr><td><tt>defaultvalue</tt> </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>display</tt>      </td><td width=20><td><a href=#201>int</a> (<tt>ATTRIBUTE_DISPLAY_FLAG_...</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>text</tt>         </td><td width=20><td><a href=#249>UL_TEXT</a> (see note)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#203>string</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#216>UL_DEVICE</a>,
<a href=#236>UL_PART</a>,
<a href=#225>UL_INSTANCE</a>,
<a href=#219>UL_ELEMENT</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ATTRIBUTE_DISPLAY_FLAG_OFF</tt>   </td><td width=20><td>nothing is displayed</td></tr>
<tr><td><tt>ATTRIBUTE_DISPLAY_FLAG_VALUE</tt>   </td><td width=20><td>value is displayed</td></tr>
<tr><td><tt>ATTRIBUTE_DISPLAY_FLAG_NAME</tt>    </td><td width=20><td>name is displayed</td></tr>
</table>
<p>
A UL_ATTRIBUTE can be used to access the <i>attributes</i> that have been
defined in the library for a device, or assigned to a part in the schematic
or board.
<h2>Note</h2>
<tt>display</tt> contains a bitwise or'ed value consisting of <tt>ATTRIBUTE_DISPLAY_FLAG_...</tt>
and defines which parts of the attribute are actually drawn.
This value is only valid if <tt>display</tt> is used in a UL_INSTANCE or UL_ELEMENT
context.
<p>
In a UL_ELEMENT context <tt>constant</tt> only returns an actual value if
f/b annotation is active, otherwise it returns 0.
<p>
The <tt>defaultvalue</tt> member returns the value as defined in the library
(if different from the actual value, otherwise the same as <tt>value</tt>).
In a UL_ELEMENT context <tt>defaultvalue</tt> only returns an actual value if
f/b annotation is active, otherwise an empty string is returned.
<p>
The <tt>text</tt> member is only available in a UL_INSTANCE or UL_ELEMENT
context and returns a UL_TEXT object that contains all the text parameters.
The value of this text object is the string as it will be displayed according to
the UL_ATTRIBUTE's 'display' parameter. If called from a different context,
the data of the returned UL_TEXT object is undefined.
<p>
For global attributes only <tt>name</tt> and <tt>value</tt> are defined.
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.parts(P) {
    P.attributes(A) {
      printf("%s = %s\n", A.name, A.value);
      }
    }
  }
schematic(SCH) {
  SCH.attributes(A) { // global attributes
    printf("%s = %s\n", A.name, A.value);
    }
  }
</pre>


<a name=210>
<h1>UL_BOARD</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>alwaysvectorfont</tt></td><td width=20><td><a href=#201>int</a> (<tt>ALWAYS_VECTOR_FONT_..., see note</tt>)</td></tr>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#208>UL_AREA</a></td></tr>
<tr><td><tt>checked</tt>      </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>grid</tt>         </td><td width=20><td><a href=#223>UL_GRID</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>verticaltext</tt> </td><td width=20><td><a href=#201>int</a> (<tt>VERTICAL_TEXT_...</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#209>UL_ATTRIBUTE</a> (see note)</td></tr>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#212>UL_CIRCLE</a></td></tr>
<tr><td><tt>classes()</tt>    </td><td width=20><td><a href=#213>UL_CLASS</a></td></tr>
<tr><td><tt>dimensions()</tt> </td><td width=20><td><a href=#218>UL_DIMENSION</a></td></tr>
<tr><td><tt>elements()</tt>   </td><td width=20><td><a href=#219>UL_ELEMENT</a></td></tr>
<tr><td><tt>errors()</tt>     </td><td width=20><td><a href=#220>UL_ERROR</a></td></tr>
<tr><td><tt>frames()</tt>     </td><td width=20><td><a href=#221>UL_FRAME</a></td></tr>
<tr><td><tt>holes()</tt>      </td><td width=20><td><a href=#224>UL_HOLE</a></td></tr>
<tr><td><tt>layers()</tt>     </td><td width=20><td><a href=#228>UL_LAYER</a></td></tr>
<tr><td><tt>libraries()</tt>  </td><td width=20><td><a href=#229>UL_LIBRARY</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#239>UL_POLYGON</a></td></tr>
<tr><td><tt>rectangles()</tt> </td><td width=20><td><a href=#242>UL_RECTANGLE</a></td></tr>
<tr><td><tt>signals()</tt>    </td><td width=20><td><a href=#246>UL_SIGNAL</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a></td></tr>
<tr><td><tt>variantdefs()</tt></td><td width=20><td><a href=#250>UL_VARIANTDEF</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#229>UL_LIBRARY</a>,
<a href=#243>UL_SCHEMATIC</a>,
<a href=#349>variant()</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ALWAYS_VECTOR_FONT_GUI</tt></td><td width=20><td>alwaysvectorfont is set in the
<a href=#17>user interface dialog</a></td></tr>
<tr><td><tt>ALWAYS_VECTOR_FONT_PERSISTENT</tt></td><td width=20><td>alwaysvectorfont is set persistent in this board</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>VERTICAL_TEXT_UP</tt></td><td width=20><td>reading direction for vertical texts: up</td></tr>
<tr><td><tt>VERTICAL_TEXT_DOWN</tt></td><td width=20><td>reading direction for vertical texts: down</td></tr>
</table>
<h2>Note</h2>
The value returned by <tt>alwaysvectorfont</tt> can be used in boolean context
or can be masked with the <tt>ALWAYS_VECTOR_FONT_...</tt> constants to determine
the source of this setting, as in
<pre>
if (B.alwaysvectorfont) {
   // alwaysvectorfont is set in general
   }
if (B.alwaysvectorfont &amp; ALWAYS_VECTOR_FONT_GUI) {
   // alwaysvectorfont is set in the user interface
   }
</pre>
The value returned by <tt>checked</tt> can be used in boolean context and is
set only after a recent 'Design Rule Check' (<a href=#53>DRC</a>).
<p>
The <tt>name</tt> member returns the full file name, including the directory.
<p>
The <tt>attributes()</tt> loop member loops through the <i>global</i> attributes.
<h2>Example</h2>
<pre>
board(B) {
  B.elements(E) printf("Element: %s\n", E.name);
  B.signals(S)  printf("Signal: %s\n", S.name);
  }
</pre>


<a name=211>
<h1>UL_BUS</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>BUS_NAME_LENGTH</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>segments()</tt>   </td><td width=20><td><a href=#244>UL_SEGMENT</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#245>UL_SHEET</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>BUS_NAME_LENGTH</tt>   </td><td width=20><td>max. length of a bus name (obsolete - as from version 4 bus names can have any length)</td></tr>
</table>
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    SH.busses(B) printf("Bus: %s\n", B.name);
    }
  }
</pre>


<a name=212>
<h1>UL_CIRCLE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>radius</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (center point)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#233>UL_FOOTPRINT</a>,
<a href=#245>UL_SHEET</a>,
<a href=#248>UL_SYMBOL</a>
<h2>Example</h2>
<pre>
board(B) {
  B.circles(C) {
    printf("Circle: (%f %f), r=%d, w=%d\n",
           u2mm(C.x), u2mm(C.y), u2mm(C.radius), u2mm(C.width));
    }
  }
</pre>


<a name=213>
<h1>UL_CLASS</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>clearance[number]</tt></td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>drill</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>name</tt>        </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>number</tt>      </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>width</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#168>Design Rules</a>,
<a href=#232>UL_NET</a>,
<a href=#246>UL_SIGNAL</a>,
<a href=#243>UL_SCHEMATIC</a>,
<a href=#210>UL_BOARD</a>
<h2>Note</h2>
The <tt>clearance</tt> member returns the clearance value between this net class
and the net class with the given number. If the number (and the square brackets) is
ommitted, the net class's own clearance value is returned. If a number is given,
it must be between 0 and the number of this net class.
<p>
If the <tt>name</tt> member returns an empty string, the net class is not defined
and therefore not in use by any signal or net.
<h2>Example</h2>
<pre>
board(B) {
  B.signals(S) {
    printf("%-10s %d %s\n", S.name, S.class.number, S.class.name);
    }
  }
</pre>


<a name=214>
<h1>UL_CONTACT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>CONTACT_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>pad</tt>          </td><td width=20><td><a href=#235>UL_PAD</a></td></tr>
<tr><td><tt>signal</tt>       </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>smd</tt>          </td><td width=20><td><a href=#247>UL_SMD</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (center point, see note)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#239>UL_POLYGON</a> (of arbitrary pad shapes)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a> (of arbitrary pad shapes)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#233>UL_FOOTPRINT</a>,
<a href=#235>UL_PAD</a>,
<a href=#247>UL_SMD</a>,
<a href=#215>UL_CONTACTREF</a>,
<a href=#238>UL_PINREF</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CONTACT_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a contact name (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
The <tt>signal</tt> data member returns the signal this contact is connected to
(only available in a board context).
<p>
The coordinates (<tt>x, y</tt>) of the contact depend on the context in which it is called:
<ul>
<li>if the contact is derived from a UL_LIBRARY context, the coordinates of the contact will be the same as
defined in the package drawing
<li>in all other cases, they will have the actual values from the board
</ul>
<h2>Example</h2>
<pre>
library(L) {
  L.footprints(FPT) {
    FPT.contacts(C) {
      printf("Contact: '%s', (%f %f)\n",
             C.name, u2mm(C.x), u2mm(C.y));
      }
    }
  }
</pre>


<a name=215>
<h1>UL_CONTACTREF</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>contact</tt>      </td><td width=20><td><a href=#214>UL_CONTACT</a></td></tr>
<tr><td><tt>element</tt>      </td><td width=20><td><a href=#219>UL_ELEMENT</a></td></tr>
<tr><td><tt>route</tt>        </td><td width=20><td><a href=#201>int</a> (<tt>CONTACT_ROUTE_...</tt>)</td></tr>
<tr><td><tt>routetag</tt>     </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#246>UL_SIGNAL</a>,
<a href=#238>UL_PINREF</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CONTACT_ROUTE_ALL</tt>   </td><td width=20><td>must explicitly route to all contacts</td></tr>
<tr><td><tt>CONTACT_ROUTE_ANY</tt>   </td><td width=20><td>may route to any contact</td></tr>
</table>
<h2>Note</h2>
If <tt>route</tt> has the value <tt>CONTACT_ROUTE_ANY</tt>, the <tt>routetag</tt>
data member returns an additional tag which describes a group of <tt>contactref</tt>s
belonging to the same pin.
<h2>Example</h2>
<pre>
board(B) {
  B.signals(S) {
    printf("Signal '%s'\n", S.name);
    S.contactrefs(C) {
      printf("\t%s, %s\n", C.element.name, C.contact.name);
      }
    }
  }
</pre>


<a name=216>
<h1>UL_DEVICE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>activetechnology</tt> </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>area</tt>             </td><td width=20><td><a href=#208>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>      </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>headline</tt>         </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>library</tt>          </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>libraryurn</tt>       </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>libraryversion</tt>   </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>name</tt>             </td><td width=20><td><a href=#203>string</a> (<tt>DEVICE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>footprint</tt>        </td><td width=20><td><a href=#233>UL_FOOTPRINT</a> (new as of EAGLE 9.1, see note)</td></tr>
<tr><td><tt>prefix</tt>           </td><td width=20><td><a href=#203>string</a> (<tt>DEVICE_PREFIX_LENGTH</tt>)</td></tr>
<tr><td><tt>technologies</tt>     </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>value</tt>            </td><td width=20><td><a href=#203>string</a> ("On" or "Off")</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#209>UL_ATTRIBUTE</a> (see note)</td></tr>
<tr><td><tt>gates()</tt>      </td><td width=20><td><a href=#222>UL_GATE</a></td></tr>
<tr><td><tt>packages3d()</tt>      </td><td width=20><td><a href=#234>UL_PACKAGE3D</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#217>UL_DEVICESET</a>,
<a href=#229>UL_LIBRARY</a>,
<a href=#236>UL_PART</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>DEVICE_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a device name (used in formatted output only)</td></tr>
<tr><td><tt>DEVICE_PREFIX_LENGTH</tt> </td><td width=20><td>max. recommended length of a device prefix (used in formatted output only)</td></tr>
</table>
<p>
All members of UL_DEVICE, except for <tt>name</tt> and <tt>technologies</tt>, return the
same values as the respective members of the UL_DEVICESET in which the UL_DEVICE has been
defined.
The <tt>name</tt> member returns the name of the package variant this device
has been created for using the <a href=#88>PACKAGE</a> command.
When using the <tt>description</tt> text keep in mind that it may contain newline characters (<tt>'\n'</tt>).
<h2>Note</h2>
The value returned by the <tt>activetechnology</tt> member depends on the context in which it is called:
<ul>
<li>if the device is derived from the deviceset that is currently edited in the library editor window,
the active technology, set by the <a href=#130>TECHNOLOGY</a> command, will be returned
<li>if the device is derived from a UL_PART, the actual technology used by the part will be returned
<li>otherwise an empty string will be returned.
</ul>
<p>
The <tt>footprint</tt> data member returns the <a href=#233>footprint</a>
that has been assigned to the device through a <a href=#88>PACKAGE</a>
command. It can be used as a boolean function to check whether a footprint has been
assigned to a device (see example below). (Note that the <tt>footprint</tt> data memmber
is new as of EAGLE 9.1. For backwards compatibility with previous EAGLE versions,
<tt>package</tt> is also supported.)
<p>
The value returned by the <tt>technologies</tt> member depends on the context in which it is called:
<ul>
<li>if the device is derived from a UL_DEVICESET, <tt>technologies</tt> will return a
string containing all of the device's technologies, separated by blanks
<li>if the device is derived from a UL_PART, only the actual technology used by the part
will be returned.
</ul>
<p>
The <tt>attributes()</tt> loop member takes an additional parameter that specifies
for which technology the attributes shall be delivered (see the second example below).
<p>
The <tt>libraryurn</tt> and <tt>libraryversion</tt> are only applicable if this UL_DEVICE comes from
a managed library. If not, <tt>libraryurn</tt> will be the empty string and <tt>libraryversion</tt> will
be -1.
<h2>Examples</h2>
<pre>
library(L) {
  L.devicesets(S) {
    S.devices(D) {
      if (D.footprint)
         printf("Device: %s, Footprint: %s\n", D.name, D.footprint.name);
      D.gates(G) {
        printf("\t%s\n", G.name);
        }
      }
    }
  }
</pre>
<pre>
library(L) {
  L.devicesets(DS) {
    DS.devices(D) {
      string t[];
      int n = strsplit(t, D.technologies, ' ');
      for (int i = 0; i &lt; n; i++) {
          D.attributes(A, t[i]) {
            printf("%s = %s\n", A.name, A.value);
            }
          }
      }
    }
  }
</pre>


<a name=217>
<h1>UL_DEVICESET</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>activedevice</tt>   </td><td width=20><td><a href=#216>UL_DEVICE</a> (see note)</td></tr>
<tr><td><tt>area</tt>           </td><td width=20><td><a href=#208>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>    </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>headline</tt>       </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>library</tt>        </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>libraryurn</tt>     </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>libraryversion</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>locallymodified</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>librarylocallymodified</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>name</tt>           </td><td width=20><td><a href=#203>string</a> (<tt>DEVICE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>prefix</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>DEVICE_PREFIX_LENGTH</tt>)</td></tr>
<tr><td><tt>urn</tt>            </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>value</tt>          </td><td width=20><td><a href=#203>string</a> ("On" or "Off")</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>devices()</tt>    </td><td width=20><td><a href=#216>UL_DEVICE</a></td></tr>
<tr><td><tt>gates()</tt>      </td><td width=20><td><a href=#222>UL_GATE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#216>UL_DEVICE</a>,
<a href=#229>UL_LIBRARY</a>,
<a href=#236>UL_PART</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>DEVICE_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a device name (used in formatted output only)</td></tr>
<tr><td><tt>DEVICE_PREFIX_LENGTH</tt> </td><td width=20><td>max. recommended length of a device prefix (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
If a deviceset is currently edited in a library editor window,
the <tt>activedevice</tt> member returns the active device, selected by a <a href=#88>PACKAGE</a>
command. It can be used as a boolean function to check the availability of such an <tt>activedevice</tt>
(see example below).
<p>
The <tt>description</tt> member returns the complete descriptive text as defined with
the <a href=#50>DESCRIPTION</a> command, while the <tt>headline</tt>
member returns only the first line of the description, without any <a href=#403>HTML</a> tags.
When using the <tt>description</tt> text keep in mind that it may contain newline characters (<tt>'\n'</tt>).
<p>
The <tt>urn</tt> contains a unique identifier for this deviceset, of the form <tt>urn:adsk.eagle:component:123/4</tt>,
where the portion after the <tt>/</tt> is the version of the deviceset. To get the base URN (without version), use
<a href=#338>urnbase()</a>; to get the version, use <a href=#339>urnversion()</a>.
<p>
The <tt>libraryurn</tt> and <tt>libraryversion</tt> are only applicable if this UL_DEVICESET comes from
a managed library. If not, <tt>libraryurn</tt> will be the empty string and <tt>libraryversion</tt> will
be -1.
<p>
The <tt>locallymodified</tt> member will be 0, if this UL_DEVICESET doesn't have local modifications, or 1, if this UL_DEVICESET has local modifications.
<br>The <tt>librarylocallymodified</tt> member will be 0 (if this UL_DEVICESET doesn't come from a locally-modified library) or 1 (if this UL_DEVICESET comes from a locally-modified library).
<h2>Example</h2>
<pre>
library(L) {
  L.devicesets(D) {
    printf("Device set: %s, Description: %s\n", D.name, D.description);
    D.gates(G) {
      printf("\t%s\n", G.name);
      }
    }
  }
</pre>
<pre>
if (deviceset)
   deviceset(DS) {
     if (DS.activedevice)
        printf("Active Device: %s\n", DS.activedevice.name);
     }
</pre>


<a name=218>
<h1>UL_DIMENSION</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>dtype</tt>        </td><td width=20><td><a href=#201>int</a> (<tt>DIMENSION_...</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>extlength</tt>    </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>extoffset</tt>    </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>extwidth</tt>     </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>precision</tt>    </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>ratio</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>size</tt>         </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>unit</tt>         </td><td width=20><td><a href=#201>int</a> (<tt>GRID_UNIT_...</tt>)</td></tr>
<tr><td><tt>visible</tt>      </td><td width=20><td><a href=#201>int</a> (<tt>unit</tt>, 0=off, 1=on)</td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#201>int</a> (first reference point)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#201>int</a> (second reference point)</td></tr>
<tr><td><tt>x3, y3</tt>       </td><td width=20><td><a href=#201>int</a> (alignment reference point)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#223>UL_GRID</a>,
<a href=#233>UL_FOOTPRINT</a>,
<a href=#245>UL_SHEET</a>,
<a href=#248>UL_SYMBOL</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>DIMENSION_PARALLEL</tt>    </td><td width=20><td>linear dimension with parallel measurement line</td></tr>
<tr><td><tt>DIMENSION_HORIZONTAL</tt>  </td><td width=20><td>linear dimension with horizontal measurement line</td></tr>
<tr><td><tt>DIMENSION_VERTICAL</tt>    </td><td width=20><td>linear dimension with vertical measurement line</td></tr>
<tr><td><tt>DIMENSION_RADIUS</tt>      </td><td width=20><td>radial dimension</td></tr>
<tr><td><tt>DIMENSION_DIAMETER</tt>    </td><td width=20><td>diameter dimension</td></tr>
<tr><td><tt>DIMENSION_ANGLE</tt>       </td><td width=20><td>angle dimension</td></tr>
<tr><td><tt>DIMENSION_LEADER</tt>      </td><td width=20><td>an arbitrary pointer</td></tr>
</table>
<h2>Note</h2>
The <tt>texts()</tt> and <tt>wires()</tt> loop members loop through all the
texts and wires the dimension consists of.
<h2>Example</h2>
<pre>
board(B) {
  B.dimensions(D) {
    printf("Dimension: (%f %f), (%f %f), (%f %f)\n",
           u2mm(D.x1), u2mm(D.y1), u2mm(D.x2), u2mm(D.y2), u2mm(D.x3), u2mm(D.y3));
    }
  }
</pre>


<a name=219>
<h1>UL_ELEMENT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#202>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>attribute[]</tt>  </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>column</tt>       </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>locked</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>ELEMENT_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>footprint</tt>    </td><td width=20><td><a href=#233>UL_FOOTPRINT</a> (new as of EAGLE 9.1, see note)</td></tr>
<tr><td><tt>package3d</tt>    </td><td width=20><td><a href=#234>UL_PACKAGE3D</a> (see note)</td></tr>
<tr><td><tt>populate</tt>     </td><td width=20><td><a href=#201>int</a> (0=do not populate, 1=populate)</td></tr>
<tr><td><tt>row</tt>          </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>smashed</tt>      </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>spin</tt>         </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#203>string</a>  (<tt>ELEMENT_VALUE_LENGTH</tt>)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (origin point)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#209>UL_ATTRIBUTE</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#215>UL_CONTACTREF</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ELEMENT_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of an element name (used in formatted output only)</td></tr>
<tr><td><tt>ELEMENT_VALUE_LENGTH</tt>  </td><td width=20><td>max. recommended length of an element value (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
The <tt>attribute[]</tt> member can be used to query a UL_ELEMENT for the value of a given
attribute (see the second example below). The returned string is empty if there is no
attribute by the given name, or if this attribute is explicitly empty.
<p>
The <tt>texts()</tt> member only loops through those texts of the element that have been
detached using <a href=#122><b>REPOSITION</b></a>,
and through the visible texts of any attributes assigned to this element.
To process all texts of an element (e.g. when drawing it), you have to loop through the element's
own <tt>texts()</tt> member as well as the <tt>texts()</tt> member of the
element's <a href=#233>footprint</a>.
<p>
Note that the <tt>footprint</tt> member is new as of EAGLE 9.1. For backwards compatibility
with older versions, <tt>package</tt> is available as an alias.
<p>
Not all UL_ELEMENT's have 3D packages. The <tt>package3d</tt> member can be used as a boolean
to test whether or not a 3D package is present, e.g. <tt>if (E.package3d)</tt>.
<p>
<tt>angle</tt> defines how many degrees the element is rotated counterclockwise
around its origin.
<p>
The <tt>column</tt> and <tt>row</tt> members return the column and row location within
the <a href=#221>frame</a> in the board drawing.
If there is no frame in the drawing, or the element is placed outside the frame, a <tt>'?'</tt>
(question mark) is returned.
<p>
The <tt>smashed</tt> member tells whether the element is smashed. This function can also
be used to find out whether there is a detached text parameter by giving the name of
that parameter in square brackets, as in <tt>smashed["VALUE"]</tt>. This is useful
in case you want to select such a text with the <a href=#83>MOVE</a> command
by doing <tt>MOVE R5&gt;VALUE</tt>. Valid parameter names are "NAME" and "VALUE", as
well as the names of any user defined <a href=#209>attributes</a>.
They are treated case insensitive, and they may be preceded by a <tt>'&gt;'</tt>
character.
<h2>Examples</h2>
<pre>
board(B) {
  B.elements(E) {
    printf("Element: %s, (%f %f), Footprint=%s\n",
           E.name, u2mm(E.x), u2mm(E.y), E.footprint.name);
    }
  }
</pre>
<pre>
board(B) {
  B.elements(E) {
    if (E.attribute["REMARK"])
       printf("%s: %s\n", E.name, E.attribute["REMARK"]);
    }
  }
</pre>


<a name=220>
<h1>UL_ERROR</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#208>UL_AREA</a></td></tr>
<tr><td><tt>area2</tt>        </td><td width=20><td><a href=#208>UL_AREA</a> (see note)</td></tr>
<tr><td><tt>code</tt>         </td><td width=20><td><a href=#201>int</a> (identification number)</td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>modulename</tt>   </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>s1</tt>           </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>s2</tt>           </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>s3</tt>           </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>s4</tt>           </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>s5</tt>           </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>s6</tt>           </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>sheet</tt>        </td><td width=20><td><a href=#201>int</a> (sheet number)</td></tr>
<tr><td><tt>signature</tt>    </td><td width=20><td><a href=#203>string</a> (signature string)</td></tr>
<tr><td><tt>state</tt>        </td><td width=20><td><a href=#201>int</a> (<tt>ERROR_STATE_...</tt>)</td></tr>
<tr><td><tt>type</tt>         </td><td width=20><td><a href=#201>int</a> (<tt>ERROR_TYPE_...</tt>)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (center point)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>contours()</tt>   </td><td width=20><td><a href=#253>UL_WIRE</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#243>UL_SCHEMATIC</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ERROR_STATE_ACTIVE</tt>     </td><td width=20><td>error has not yet been approved or processed</td></tr>
<tr><td><tt>ERROR_STATE_APPROVED</tt>   </td><td width=20><td>error has been approved</td></tr>
<tr><td><tt>ERROR_STATE_PROCESSED</tt>  </td><td width=20><td>error has been processed</td></tr>
<tr><td><tt>ERROR_TYPE_NONE</tt>        </td><td width=20><td>no error</td></tr>
<tr><td><tt>ERROR_TYPE_WARNING</tt>     </td><td width=20><td>warning</td></tr>
<tr><td><tt>ERROR_TYPE_ERROR</tt>       </td><td width=20><td>error</td></tr>
<tr><td><tt>ERROR_TYPE_CONSISTENCY</tt> </td><td width=20><td>consistency error</td></tr>
</table>
<h2>Note</h2>
A UL_ERROR is an abstract object which gives informations about ERC/DRC errors.
<p>
The members <tt>layer</tt> and <tt>contours()</tt> are only available in UL_BOARD context
and the members <tt>area2</tt>, <tt>modulename</tt>, <tt>s1..s6</tt> and <tt>sheet</tt>
are only available in UL_SCHEMATIC context.
<p>
The member <tt>area2</tt> is a second area, only available on some ERC errors and refers
to the corresponding area in the board.
The members <tt>s1..s6</tt> are string values, which contain for ERC errors
specific informations like names.
<p>
The <tt>contours()</tt> loop member loops through the contour wires of the
DRC error polygon.
<h2>Example</h2>
<pre>
string s1;
string ErrLst[];
int ErrCnt = 0;
string ErrLstHeader;
if (board) board(B) {
   ErrLstHeader = "Code\tState\tDescription\tLayer\tSignature";
   if (B.checked) {
      B.errors(ER) {
         if (ER.state == ERROR_STATE_ACTIVE) {
            sprintf(s1, "%d\t%d\t%s\t%d\t%s", ER.code, ER.state, ER.description, ER.layer, ER.signature);
            ErrLst[ErrCnt++] = s1;
         }
      }
   }
}
if (schematic) schematic(SCH) {
   ErrLstHeader = "Code\tState\tDescription\tSheet\tModule\ts1\ts2\ts3\ts4\ts5\ts6";
   if (SCH.checked) {
      SCH.errors(ER) {
         if (ER.state == ERROR_STATE_ACTIVE) {
            sprintf(s1, "%d\t%d\t%s\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s", ER.code, ER.state, ER.description, ER.sheet, ER.modulename, ER.s1, ER.s2, ER.s3, ER.s4, ER.s5, ER.s6);
            ErrLst[ErrCnt++] = s1;
         }
      }
   }
}
dlgDialog("Errors") {
   int sel = -1;
   dlgListView(ErrLstHeader, ErrLst, sel);
   dlgPushButton("+OK") dlgAccept();
};
</pre>


<a name=221>
<h1>UL_FRAME</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>columns</tt>      </td><td width=20><td><a href=#201>int</a> (<tt>-127</tt>...<tt>127</tt>)</td></tr>
<tr><td><tt>rows</tt>         </td><td width=20><td><a href=#201>int</a> (<tt>-26</tt>...<tt>26</tt>)</td></tr>
<tr><td><tt>border</tt>       </td><td width=20><td><a href=#201>int</a> (<tt>FRAME_BORDER_...</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#201>int</a> (lower left corner)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#201>int</a> (upper right corner)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#233>UL_FOOTPRINT</a>,
<a href=#245>UL_SHEET</a>,
<a href=#248>UL_SYMBOL</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>FRAME_BORDER_BOTTOM</tt>    </td><td width=20><td>bottom border is drawn</td></tr>
<tr><td><tt>FRAME_BORDER_RIGHT</tt>     </td><td width=20><td>right border is drawn</td></tr>
<tr><td><tt>FRAME_BORDER_TOP</tt>       </td><td width=20><td>top border is drawn</td></tr>
<tr><td><tt>FRAME_BORDER_LEFT</tt>      </td><td width=20><td>left border is drawn</td></tr>
</table>
<h2>Note</h2>
<tt>border</tt> contains a bitwise or'ed value consisting of <tt>FRAME_BORDER_...</tt>
and defines which of the four borders are actually drawn.
<p>
The <tt>texts()</tt> and <tt>wires()</tt> loop members loop through all the
texts and wires the frame consists of.
<h2>Example</h2>
<pre>
board(B) {
  B.frames(F) {
    printf("Frame: (%f %f), (%f %f)\n",
           u2mm(F.x1), u2mm(F.y1), u2mm(F.x2), u2mm(F.y2));
    }
  }
</pre>


<a name=222>
<h1>UL_GATE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>addlevel</tt>     </td><td width=20><td><a href=#201>int</a> (<tt>GATE_ADDLEVEL_...</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>GATE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>swaplevel</tt>    </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>symbol</tt>       </td><td width=20><td><a href=#248>UL_SYMBOL</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (origin point, see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#216>UL_DEVICE</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>GATE_ADDLEVEL_MUST</tt>    </td><td width=20><td>must</td></tr>
<tr><td><tt>GATE_ADDLEVEL_CAN</tt>     </td><td width=20><td>can</td></tr>
<tr><td><tt>GATE_ADDLEVEL_NEXT</tt>    </td><td width=20><td>next</td></tr>
<tr><td><tt>GATE_ADDLEVEL_REQUEST</tt> </td><td width=20><td>request</td></tr>
<tr><td><tt>GATE_ADDLEVEL_ALWAYS</tt>  </td><td width=20><td>always</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>GATE_NAME_LENGTH</tt>      </td><td width=20><td>max. recommended length of a gate name (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
The coordinates of the origin point (x, y) are always those of the gate's position within
the device, even if the UL_GATE has been derived from a <a href=#225>UL_INSTANCE</a>.
<h2>Example</h2>
<pre>
library(L) {
  L.devices(D) {
    printf("Device: %s, Footprint: %s\n", D.name, D.footprint.name);
    D.gates(G) {
      printf("\t%s, swaplevel=%d, symbol=%s\n",
             G.name, G.swaplevel, G.symbol.name);
      }
    }
  }
</pre>


<a name=223>
<h1>UL_GRID</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>distance</tt>     </td><td width=20><td><a href=#202>real</a></td></tr>
<tr><td><tt>dots</tt>         </td><td width=20><td><a href=#201>int</a> (0=lines, 1=dots)</td></tr>
<tr><td><tt>multiple</tt>     </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>on</tt>           </td><td width=20><td><a href=#201>int</a> (0=off, 1=on)</td></tr>
<tr><td><tt>unit</tt>         </td><td width=20><td><a href=#201>int</a> (<tt>GRID_UNIT_...</tt>)</td></tr>
<tr><td><tt>unitdist</tt>     </td><td width=20><td><a href=#201>int</a> (<tt>GRID_UNIT_...</tt>)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#229>UL_LIBRARY</a>,
<a href=#243>UL_SCHEMATIC</a>,
<a href=#315>Unit Conversions</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>GRID_UNIT_MIC</tt>   </td><td width=20><td>microns</td></tr>
<tr><td><tt>GRID_UNIT_MM</tt>    </td><td width=20><td>millimeter</td></tr>
<tr><td><tt>GRID_UNIT_MIL</tt>   </td><td width=20><td>mil</td></tr>
<tr><td><tt>GRID_UNIT_INCH</tt>  </td><td width=20><td>inch</td></tr>
</table>
<h2>Note</h2>
<tt>unitdist</tt> returns the grid unit that was set to define the actual grid size
(returned by <tt>distance</tt>), while <tt>unit</tt> returns the grid unit that is
used to display values or interpret user input.
<h2>Example</h2>
<pre>
board(B) {
  printf("Gridsize=%f\n", B.grid.distance);
  }
</pre>


<a name=224>
<h1>UL_HOLE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>diameter[layer]</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>drill</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>drillsymbol</tt>  </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (center point)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#233>UL_FOOTPRINT</a>
<h2>Note</h2>
<tt>diameter[]</tt> is only defined vor layers <tt>LAYER_TSTOP</tt> and <tt>LAYER_BSTOP</tt>
and returns the diameter of the solder stop mask in the given layer.
<p>
<tt>drillsymbol</tt> returns the number of the drill symbol that has been assigned
to this drill diameter (see the manual for a list of defined drill symbols).
A value of <tt>0</tt> means that no symbol has been assigned to this drill diameter.
<h2>Example</h2>
<pre>
board(B) {
  B.holes(H) {
    printf("Hole: (%f %f), drill=%f\n",
           u2mm(H.x), u2mm(H.y), u2mm(H.drill));
    }
  }
</pre>


<a name=225>
<h1>UL_INSTANCE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#202>real</a> (<tt>0</tt>, <tt>90</tt>, <tt>180</tt> and <tt>270</tt>)</td></tr>
<tr><td><tt>column</tt>       </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>gate</tt>         </td><td width=20><td><a href=#222>UL_GATE</a></td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>INSTANCE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>part</tt>         </td><td width=20><td><a href=#236>UL_PART</a></td></tr>
<tr><td><tt>row</tt>          </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>sheet</tt>        </td><td width=20><td><a href=#201>int</a> (0=unused, &gt;0=sheet number)</td></tr>
<tr><td><tt>smashed</tt>      </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#203>string</a> (<tt>PART_VALUE_LENGTH</tt>)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (origin point)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#209>UL_ATTRIBUTE</a> (see note)</td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a> (see note)</td></tr>
<tr><td><tt>xrefs()</tt>      </td><td width=20><td><a href=#222>UL_GATE</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#238>UL_PINREF</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>INSTANCE_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of an instance name (used in formatted output only)</td></tr>
<tr><td><tt>PART_VALUE_LENGTH</tt>      </td><td width=20><td>max. recommended length of a part value (instances do not have a value of their own!)</td></tr>
</table>
<h2>Note</h2>
The <tt>attributes()</tt> member only loops through those attributes that have been
explicitly assigned to this instance (including <i>smashed</i> attributes).
<p>
The <tt>texts()</tt> member only loops through those texts of the instance that have been
detached using <a href=#122><b>REPOSITION</b></a>,
and through the visible texts of any attributes assigned to this instance.
To process all texts of an instance, you have to loop through the instance's
own <tt>texts()</tt> member as well as the <tt>texts()</tt> member of the
instance's gate's <a href=#248>symbol</a>.
If attributes have been assigned to an instance, <tt>texts()</tt> delivers their texts
in the form as they are currently visible.
<p>
The <tt>column</tt> and <tt>row</tt> members return the column and row location within
the <a href=#221>frame</a> on the sheet on which this instance is invoked.
If there is no frame on that sheet, or the instance is placed outside the frame, a <tt>'?'</tt>
(question mark) is returned.
These members can only be used in a sheet context.
<p>
The <tt>smashed</tt> member tells whether the instance is smashed. This function can also
be used to find out whether there is a detached text parameter by giving the name of
that parameter in square brackets, as in <tt>smashed["VALUE"]</tt>. This is useful
in case you want to select such a text with the <a href=#83>MOVE</a> command
by doing <tt>MOVE R5&gt;VALUE</tt>. Valid parameter names are "NAME", "VALUE",
"PART" and "GATE", as well as the names of any user defined <a href=#209>attributes</a>.
They are treated case insensitive, and they may be preceded by a <tt>'&gt;'</tt>
character.
<p>
The <tt>xrefs()</tt> member loops through the <a href=#172>contact cross-reference</a>
gates of this instance. These are only of importance if the ULP is going to create
a drawing of some sort (for instance a DXF file).
<h2>Example</h2>
<pre>
schematic(S) {
  S.parts(P) {
    printf("Part: %s\n", P.name);
    P.instances(I) {
      if (I.sheet != 0)
         printf("\t%s used on sheet %d\n", I.name, I.sheet);
      }
    }
  }
</pre>


<a name=226>
<h1>UL_JUNCTION</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>diameter</tt>     </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (center point)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#244>UL_SEGMENT</a>
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    SH.nets(N) {
      N.segments(SEG) {
        SEG.junctions(J) {
          printf("Junction: (%f %f)\n", u2mm(J.x), u2mm(J.y));
          }
        }
      }
    }
  }
</pre>


<a name=227>
<h1>UL_LABEL</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#202>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>spin</tt>         </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>text</tt>         </td><td width=20><td><a href=#249>UL_TEXT</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (origin point)</td></tr>
<tr><td><tt>xref</tt>         </td><td width=20><td><a href=#201>int</a> (0=plain, 1=cross-reference)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#244>UL_SEGMENT</a>
<h2>Note</h2>
If <tt>xref</tt> returns a non-zero value, the <tt>wires()</tt> loop member loops through
the wires that form the flag of a cross-reference label. Otherwise it is an empty loop.
<p>
The <tt>angle</tt>, <tt>layer</tt>, <tt>mirror</tt> and <tt>spin</tt> members always
return the same values as those of the UL_TEXT object returned by the <tt>text</tt>
member. The <tt>x</tt> and <tt>y</tt> members of the text return slightly offset values for
cross-reference labels (non-zero <tt>xref</tt>), otherwise they also return the same values
as the UL_LABEL.
<p>
<tt>xref</tt> is only meaningful for net labels. For bus labels it always returns 0.
<h2>Example</h2>
<pre>
sheet(SH) {
  SH.nets(N) {
    N.segments(S) {
      S.labels(L) {
        printf("Label: (%f %f) '%s'", u2mm(L.x), u2mm(L.y), L.text.value);
        }
      }
    }
  }
</pre>


<a name=228>
<h1>UL_LAYER</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>color</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>fill</tt>         </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>LAYER_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>number</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>used</tt>         </td><td width=20><td><a href=#201>int</a> (0=unused, 1=used)</td></tr>
<tr><td><tt>visible</tt>      </td><td width=20><td><a href=#201>int</a> (0=off, 1=on)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#229>UL_LIBRARY</a>,
<a href=#243>UL_SCHEMATIC</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>LAYER_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a layer name (used in formatted output only)</td></tr>
<tr><td><tt>LAYER_TOP</tt>  </td><td width=20><td>layer numbers</td></tr>
<tr><td><tt>LAYER_BOTTOM</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_PADS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_VIAS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_UNROUTED</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_DIMENSION</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TPLACE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BPLACE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TORIGINS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BORIGINS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TNAMES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BNAMES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TVALUES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BVALUES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TSTOP</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BSTOP</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TCREAM</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BCREAM</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TFINISH</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BFINISH</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TGLUE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BGLUE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TTEST</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BTEST</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TKEEPOUT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BKEEPOUT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TRESTRICT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BRESTRICT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_VRESTRICT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_DRILLS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_HOLES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_MILLING</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_MEASURES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_DOCUMENT</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_REFERENCE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_TDOCU</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BDOCU</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_NETS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_BUSSES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_PINS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_SYMBOLS</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_NAMES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_VALUES</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_INFO</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_GUIDE</tt>  </td><td width=20><td></td></tr>
<tr><td><tt>LAYER_USER</tt>  </td><td width=20><td>lowest number for user defined layers (100)</td></tr>
</table>
<h2>Example</h2>
<pre>
board(B) {
  B.layers(L) printf("Layer %3d %s\n", L.number, L.name);
  }
</pre>


<a name=229>
<h1>UL_LIBRARY</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>editable</tt>     </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>grid</tt>         </td><td width=20><td><a href=#223>UL_GRID</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>id</tt>           </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>LIBRARY_NAME_LENGTH</tt>, see note)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>devices()</tt>    </td><td width=20><td><a href=#216>UL_DEVICE</a></td></tr>
<tr><td><tt>devicesets()</tt> </td><td width=20><td><a href=#217>UL_DEVICESET</a></td></tr>
<tr><td><tt>layers()</tt>     </td><td width=20><td><a href=#228>UL_LAYER</a></td></tr>
<tr><td><tt>footprints()</tt> </td><td width=20><td><a href=#233>UL_FOOTPRINT</a> (new as of EAGLE 9.1, see note)</td></tr>
<tr><td><tt>packages3d()</tt> </td><td width=20><td><a href=#234>UL_PACKAGE3D</a></td></tr>
<tr><td><tt>symbols()</tt>    </td><td width=20><td><a href=#248>UL_SYMBOL</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#243>UL_SCHEMATIC</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>LIBRARY_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a library name (used in formatted output only)</td></tr>
</table>
<p>
The <tt>devices()</tt> member loops through all the package variants and technologies
of all UL_DEVICESETs in the library, thus resulting in all the actual device variations
available. The <tt>devicesets()</tt> member only loops through the UL_DEVICESETs,
which in turn can be queried for their UL_DEVICE members.
<h2>Note</h2>
The <tt>footprints()<tt> member is new as of EAGLE 9.1. For backwards compatibility with
previous EAGLE versions, <tt>packages()</tt> is available as an alias.
<p>
The <tt>description</tt> member returns the complete descriptive text as defined with
the <a href=#50>DESCRIPTION</a> command, while the <tt>headline</tt>
member returns only the first line of the description, without any <a href=#403>HTML</a> tags.
When using the <tt>description</tt> text keep in mind that it may contain newline characters (<tt>'\n'</tt>).
The <tt>description</tt> and <tt>headline</tt> information is only available within a
library drawing, not if the library is derived form a UL_BOARD or UL_SCHEMATIC context.
<p>
If the library is derived form a UL_BOARD or UL_SCHEMATIC context, <tt>name</tt> returns
the pure library name (without path or extension). Otherwise it returns the full library file name.
<p>
The <tt>id</tt> member is only applicable if this UL_LIBRARY refers to a managed library.
If not, <tt>id</tt> will be the empty string.
<p>
The <tt>editable</tt> member returns the value 1, if the library is editable by the user (the user owns the library). Otherwise it returns 0.
<h2>Example</h2>
<pre>
library(L) {
  L.devices(D)     printf("Dev: %s\n", D.name);
  L.devicesets(D)  printf("Dev: %s\n", D.name);
  L.footprints(F)  printf("Fpt: %s\n", F.name);
  L.packages3d(P)  printf("3dp: %s\n", P.name);
  L.symbols(S)     printf("Sym: %s\n", S.name);
  }
schematic(S) {
  S.libraries(L) printf("Library: %s\n", L.name);
  }
</pre>


<a name=230>
<h1>UL_MODULE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>dx, dy</tt>       </td><td width=20><td><a href=#201>int</a> (size)</td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>prefix</tt>       </td><td width=20><td><a href=#203>string</a></td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>parts()</tt>      </td><td width=20><td><a href=#236>UL_PART</a></td></tr>
<tr><td><tt>ports()</tt>      </td><td width=20><td><a href=#240>UL_PORT</a></td></tr>
<tr><td><tt>sheets()</tt>     </td><td width=20><td><a href=#245>UL_SHEET</a></td></tr>
<tr><td><tt>variantdefs()</tt></td><td width=20><td><a href=#250>UL_VARIANTDEF</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#240>UL_PORT</a>,
<a href=#243>UL_SCHEMATIC</a>
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.modules(M) {
    M.parts(P) printf("Part: %s\n", P.name);
    }
  }
</pre>


<a name=231>
<h1>UL_MODULEINST</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#202>real</a> (<tt>0</tt>, <tt>90</tt>, <tt>180</tt> and <tt>270</tt>)</td></tr>
<tr><td><tt>column</tt>       </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>module</tt>       </td><td width=20><td><a href=#230>UL_MODULE</a></td></tr>
<tr><td><tt>modulevariant</tt></td><td width=20><td><a href=#203>string</a> (selected variantdef of module)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>INSTANCE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>offset</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>row</tt>          </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>sheet</tt>        </td><td width=20><td><a href=#201>int</a> (sheet number)</td></tr>
<tr><td><tt>smashed</tt>      </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (origin point)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a> (see note)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#241>UL_PORTREF</a>,
<a href=#250>UL_VARIANTDEF</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>INSTANCE_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of an instance name (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
The <tt>texts()</tt> member loops through all texts of the module instance, no matter if
<tt>smashed</tt> or not.
<p>
The <tt>column</tt> and <tt>row</tt> members return the column and row location within
the <a href=#221>frame</a> on the sheet on which this instance is invoked.
If there is no frame on that sheet, or the instance is placed outside the frame, a <tt>'?'</tt>
(question mark) is returned.
These members can only be used in a sheet context.
<p>
The <tt>smashed</tt> member tells whether the instance is smashed. This function can also
be used to find out whether there is a detached text parameter by giving the name of
that parameter in square brackets, as in <tt>smashed["NAME"]</tt>. This is useful
in case you want to select such a text with the <a href=#83>MOVE</a> command
by doing <tt>MOVE MOD1&gt;NAME</tt>.
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    SH.moduleinsts(MI) {
      printf("Module instance %s is located on sheet %d\n", MI.name, MI.sheet);
      }
    }
  }
</pre>


<a name=232>
<h1>UL_NET</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>class</tt>        </td><td width=20><td><a href=#213>UL_CLASS</a></td></tr>
<tr><td><tt>column</tt>       </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>NET_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>row</tt>          </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>portrefs()</tt>   </td><td width=20><td><a href=#241>UL_PORTREF</a></td></tr>
<tr><td><tt>pinrefs()</tt>    </td><td width=20><td><a href=#238>UL_PINREF</a> (see note)</td></tr>
<tr><td><tt>segments()</tt>   </td><td width=20><td><a href=#244>UL_SEGMENT</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#245>UL_SHEET</a>,
<a href=#243>UL_SCHEMATIC</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>NET_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a net name (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
The <tt>pinrefs()</tt> loop member can only be used if the net is in a
schematic context.<br>
The <tt>segments()</tt> loop member can only be used if the net is in a
sheet context.
<p>
The <tt>column</tt> and <tt>row</tt> members return the column and row locations within
the <a href=#221>frame</a> on the sheet on which this net is drawn. Since a net
can extend over a certain area, each of these functions returns two values, separated by
a blank. In case of <tt>column</tt> these are the left- and rightmost columns touched
by the net, and in case of <tt>row</tt> it's the top- and bottommost row.
<p>
When determining the column and row of a net on a sheet, first the column and then
the row within that column is taken into account. Here XREF labels take precedence
over normal labels, which again take precedence over net wires.
<p>
If there is no frame on that sheet, <tt>"? ?"</tt> (two question marks) is returned.
If any part of the net is placed outside the frame, either of the values may be <tt>'?'</tt> (question mark).
These members can only be used in a sheet context.
<p>
If the net is retrieved with <tt>UL_SCHEMATIC.allnets()</tt> the valid members are:
<tt>name</tt>, <tt>class</tt> and <tt>pinrefs()</tt>.
The <tt>pinrefs()</tt> loop member loops also through the virtual pinrefs generated by
module instances.
<h2>Example</h2>
<pre>
schematic(S) {
  S.nets(N) {
    printf("Net: %s\n", N.name);
    // N.segments(SEG) will NOT work here!
    }
  // or with virt. nets:
  S.allnets(N) {
    printf("Net: %s\n", N.name);
    }
  }
schematic(S) {
  S.sheets(SH) {
    SH.nets(N) {
      printf("Net: %s\n", N.name);
      N.segments(SEG) {
        SEG.wires(W) {
          printf("\tWire: (%f %f) (%f %f)\n",
                 u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2));
          }
        }
      }
    }
  }
</pre>


<a name=233>
<h1>UL_FOOTPRINT (new as of EAGLE 9.1)</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>area</tt>           </td><td width=20><td><a href=#208>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>    </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>headline</tt>       </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>library</tt>        </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>libraryurn</tt>     </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>libraryversion</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>locallymodified</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>librarylocallymodified</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>name</tt>           </td><td width=20><td><a href=#203>string</a> (<tt>PACKAGE_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>urn</tt>            </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#212>UL_CIRCLE</a></td></tr>
<tr><td><tt>contacts()</tt>   </td><td width=20><td><a href=#214>UL_CONTACT</a></td></tr>
<tr><td><tt>dimensions()</tt> </td><td width=20><td><a href=#218>UL_DIMENSION</a></td></tr>
<tr><td><tt>frames()</tt>     </td><td width=20><td><a href=#221>UL_FRAME</a></td></tr>
<tr><td><tt>holes()</tt>      </td><td width=20><td><a href=#224>UL_HOLE</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#239>UL_POLYGON</a> (see note)</td></tr>
<tr><td><tt>rectangles()</tt> </td><td width=20><td><a href=#242>UL_RECTANGLE</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a> (see note)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#216>UL_DEVICE</a>,
<a href=#219>UL_ELEMENT</a>,
<a href=#229>UL_LIBRARY</a>,
<a href=#234>UL_PACKAGE3D</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PACKAGE_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a package name (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
The <tt>UL_FOOTPRINT</tt> object is new as of EAGLE 9.1. For backwards compatibility with
previous EAGLE versions, <tt>UL_PACKAGE</tt> is available as an alias.
<p>
The <tt>description</tt> member returns the complete descriptive text as defined with
the <a href=#50>DESCRIPTION</a> command, while the <tt>headline</tt>
member returns only the first line of the description, without any <a href=#403>HTML</a> tags.
When using the <tt>description</tt> text keep in mind that it may contain newline characters (<tt>'\n'</tt>).
<p>
If the UL_FOOTPRINT is derived from a UL_ELEMENT, the <tt>texts()</tt> member only loops through the
non-detached texts of that element.
<p>
If the UL_FOOTPRINT is derived from a UL_ELEMENT, polygons and wires belonging to contacts with arbitrary
pad shapes are available through the loop members <tt>polygons()</tt> and <tt>wires()</tt> of this contact.
<p>
The <tt>urn</tt> contains a unique identifier for this footprint, of the form <tt>urn:adsk.eagle:footprint:123/4</tt>,
where the portion after the <tt>/</tt> is the version of the footprint. To get the base URN (without version), use
<a href=#338>urnbase()</a>; to get the version, use <a href=#339>urnversion()</a>.
<p>
The <tt>libraryurn</tt> and <tt>libraryversion</tt> are only applicable if this UL_FOOTPRINT comes from
a managed library. If not, <tt>libraryurn</tt> will be the empty string and <tt>libraryversion</tt> will
be -1.
<p>
The <tt>locallymodified</tt> member will be 0, if this UL_FOOTPRINT doesn't have local modifications, or 1, if this UL_FOOTPRINT has local modifications.
<br>The <tt>librarylocallymodified</tt> member will be 0 (if this UL_FOOTPRINT doesn't come from a locally-modified library) or 1 (if this UL_FOOTPRINT comes from a locally-modified library).
<h2>Example</h2>
<pre>
library(L) {
  L.footprints(FPT) {
    printf("Footprint: %s\n", FPT.name);
    FPT.contacts(C) {
      if (C.pad)
         printf("\tPad: %s, (%f %f)\n",
                 C.name, u2mm(C.pad.x), u2mm(C.pad.y));
      else if (C.smd)
         printf("\tSmd: %s, (%f %f)\n",
                 C.name, u2mm(C.smd.x), u2mm(C.smd.y));
      }
    }
  }
board(B) {
  B.elements(E) {
    printf("Element: %s, Footprint: %s\n", E.name, E.footprint.name);
    }
  }
</pre>


<a name=234>
<h1>UL_PACKAGE3D</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>description</tt>    </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>headline</tt>       </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>library</tt>        </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>libraryurn</tt>     </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>libraryversion</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>name</tt>           </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>urn</tt>            </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#216>UL_DEVICE</a>,
<a href=#219>UL_ELEMENT</a>,
<a href=#229>UL_LIBRARY</a>,
<a href=#233>UL_FOOTPRINT</a>
<h2>Note</h2>
The <tt>description</tt> member returns the complete descriptive text, while the <tt>headline</tt>
member returns only the first line of the description, without any <a href=#403>HTML</a> tags.
When using the <tt>description</tt> text keep in mind that it may contain newline characters (<tt>'\n'</tt>).
<p>
The <tt>urn</tt> contains a unique identifier for this 3D package, of the form <tt>urn:adsk.eagle:package:123/4</tt>,
where the portion after the <tt>/</tt> is the version of the 3D package. To get the base URN (without version), use
<a href=#338>urnbase()</a>; to get the version, use <a href=#339>urnversion()</a>.
<p>
The <tt>libraryurn</tt> and <tt>libraryversion</tt> are only applicable if this UL_PACKAGE3D comes from
a managed library. If not, <tt>libraryurn</tt> will be the empty string and <tt>libraryversion</tt> will
be -1.
<h2>Example</h2>
<pre>
library(L) {
  L.packages3d(P3D) {
    printf("3D Package: %s (%s, Version %d)\n", P3D.name, urnbase(P3D.urn), urnversion(P3D.urn));
    }
  }
board(B) {
  B.elements(E) {
    printf("Element: %s", E.name);
    if (E.package3d) printf(", 3D Package: %s (%s, Version %d)\n", E.package3d.name, urnbase(E.package3d.urn), urnversion(E.package3d.urn));
    else printf("\n");
    }
  }
</pre>


<a name=235>
<h1>UL_PAD</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#202>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>diameter[layer]</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>drill</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>drillsymbol</tt>  </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>elongation</tt>   </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>flags</tt>        </td><td width=20><td><a href=#201>int</a> (<tt>PAD_FLAG_...</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>PAD_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>shape[layer]</tt> </td><td width=20><td><a href=#201>int</a> (<tt>PAD_SHAPE_...</tt>)</td></tr>
<tr><td><tt>signal</tt>       </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (center point, see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#233>UL_FOOTPRINT</a>,
<a href=#214>UL_CONTACT</a>,
<a href=#247>UL_SMD</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PAD_FLAG_STOP</tt>   </td><td width=20><td>generate stop mask</td></tr>
<tr><td><tt>PAD_FLAG_THERMALS</tt>         </td><td width=20><td>generate thermals</td></tr>
<tr><td><tt>PAD_FLAG_FIRST</tt>            </td><td width=20><td>use special "first pad" shape</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PAD_SHAPE_SQUARE</tt>   </td><td width=20><td>square</td></tr>
<tr><td><tt>PAD_SHAPE_ROUND</tt>    </td><td width=20><td>round</td></tr>
<tr><td><tt>PAD_SHAPE_OCTAGON</tt>  </td><td width=20><td>octagon</td></tr>
<tr><td><tt>PAD_SHAPE_LONG</tt>     </td><td width=20><td>long</td></tr>
<tr><td><tt>PAD_SHAPE_OFFSET</tt>   </td><td width=20><td>offset</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PAD_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a pad name (same as <tt>CONTACT_NAME_LENGTH</tt>)</td></tr>
</table>
<h2>Note</h2>
The parameters of the pad depend on the context in which it is accessed:
<ul>
<li>if the pad is derived from a UL_LIBRARY context, the coordinates (<tt>x, y</tt>) and <tt>angle</tt> will be the same as
defined in the footprint drawing
<li>in all other cases, they will have the actual values from the board
</ul>
<p>
The diameter and shape of the pad depend on the layer for which they shall be retrieved,
because they may be different in each layer depending on the <a href=#168>Design Rules</a>.
If one of the <a href=#228>layers</a> LAYER_TOP...LAYER_BOTTOM, LAYER_TSTOP or LAYER_BSTOP
is given as the index to the diameter or shape data member, the resulting value will be calculated
according to the Design Rules. If LAYER_PADS is given, the raw value as defined in the library will
be returned.
<p>
<tt>drillsymbol</tt> returns the number of the drill symbol that has been assigned
to this drill diameter (see the manual for a list of defined drill symbols).
A value of <tt>0</tt> means that no symbol has been assigned to this drill diameter.
<p>
<tt>angle</tt> defines how many degrees the pad is rotated counterclockwise
around its center.
<p>
<tt>elongation</tt> is only valid for shapes PAD_SHAPE_LONG and PAD_SHAPE_OFFSET and
defines how many percent the long side of such a pad is longer than its small side.
This member returns 0 for any other pad shapes.
<p>
The value returned by <tt>flags</tt> must be masked with the <tt>PAD_FLAG_...</tt>
constants to determine the individual flag settings, as in
<pre>
if (pad.flags &amp; PAD_FLAG_STOP) {
   ...
   }
</pre>
Note that if your ULP just wants to draw the objects, you don't need to check these
flags explicitly. The <tt>diameter[]</tt> and <tt>shape[]</tt> members will return
the proper data; for instance, if <tt>PAD_FLAG_STOP</tt> is set, <tt>diameter[LAYER_TSTOP]</tt>
will return <tt>0</tt>, which should result in nothing being drawn in that layer.
The <tt>flags</tt> member is mainly for ULPs that want to create script files that
create library objects.
<h2>Example</h2>
<pre>
library(L) {
  L.footprints(FPT) {
    FPT.contacts(C) {
      if (C.pad)
         printf("Pad: '%s', (%f %f), d=%f\n",
                 C.name, u2mm(C.pad.x), u2mm(C.pad.y), u2mm(C.pad.diameter[LAYER_BOTTOM]));
      }
    }
  }
</pre>


<a name=236>
<h1>UL_PART</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attribute[]</tt>  </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>device</tt>       </td><td width=20><td><a href=#216>UL_DEVICE</a></td></tr>
<tr><td><tt>deviceset</tt>    </td><td width=20><td><a href=#217>UL_DEVICESET</a></td></tr>
<tr><td><tt>module</tt>       </td><td width=20><td><a href=#230>UL_MODULE</a> (see note)</td></tr>
<tr><td><tt>modulepart</tt>   </td><td width=20><td>UL_PART (see note)</td></tr>
<tr><td><tt>modulepath</tt>   </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>PART_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>package3d</tt>    </td><td width=20><td><a href=#234>UL_PACKAGE3D</a></td></tr>
<tr><td><tt>populate</tt>     </td><td width=20><td><a href=#201>int</a> (0=do not populate, 1=populate)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#203>string</a> (<tt>PART_VALUE_LENGTH</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#209>UL_ATTRIBUTE</a> (see note)</td></tr>
<tr><td><tt>instances()</tt>  </td><td width=20><td><a href=#225>UL_INSTANCE</a> (see note)</td></tr>
<tr><td><tt>variants()</tt>   </td><td width=20><td><a href=#251>UL_VARIANT</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#243>UL_SCHEMATIC</a>,
<a href=#245>UL_SHEET</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PART_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a part name (used in formatted output only)</td></tr>
<tr><td><tt>PART_VALUE_LENGTH</tt>  </td><td width=20><td>max. recommended length of a part value (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
The <tt>attribute[]</tt> member can be used to query a UL_PART for the value of a given
attribute (see the second example below). The returned string is empty if there is no
attribute by the given name, or if this attribute is explicitly empty.
<p>
When looping through the <tt>attributes()</tt> of a UL_PART, only the <tt>name</tt>,
<tt>value</tt>, <tt>defaultvalue</tt> and <tt>constant</tt> members of the resulting
UL_ATTRIBUTE objects are valid.
<p>
When looping through the assembly <tt>variants()</tt> of a UL_PART, only actual variants
are available. The default assembly variant is not available here. Therefore this loop
is not active on parts without assembly variants.
<p>
If the part is in a sheet context, the <tt>instances()</tt> loop member
loops only through those instances that are actually used on that sheet.
If the part is in a schematic or module context, all instances are looped through.
<p>
If the part is a <i>virtual part</i> (virtual parts can be retrieved with <tt>UL_SCHEMATIC.allparts()</tt>,
see <a href=#243>UL_SCHEMATIC</a>) the <tt>instances()</tt> loop is empty.
<p>
If the part is from a module or is a virtual part, <tt>module</tt> refers to this.
If not (part in main schematic), <tt>module</tt> is null.
<p>
If the part is virtual, <tt>modulepart</tt> is the (real) part from the source module <tt>module</tt>.
If it's a part in main schematic or if it's a module part itself <tt>modulepart</tt> is null.
<p>
If the part is virtual, <tt>modulepath</tt> is a string with the sequence of names of the module instances
that point to the module containing the part being used. These names are separated by ':'.
In other cases this string is empty.<br>
For example, a virtual part with name 'MI1:R1' has <tt>modulepath</tt> 'MI1'.<br>
'R101' coming from a module instance 'MX' with offset notation, delivers <tt>modulepath</tt> 'MX'.<br>
'MAIN:SUB1:SUBSUB1:C5' has <tt>modulepath</tt> 'MAIN:SUB1:SUBSUB1'.
<p>
Not all UL_PART's have 3D packages. The <tt>package3d</tt> member can be used as a boolean
to test whether or not a 3D package is present, e.g. <tt>if (P.package3d)</tt>.
<h2>Examples</h2>
<pre>
schematic(S) {
  S.parts(P) printf("Part: %s\n", P.name);
}
</pre>
<pre>
schematic(S) {
  S.allparts(P) {
    if (P.attribute["REMARK"])
       printf("%s: %s\n", P.name, P.attribute["REMARK"]);
    if (P.modulepart) {
       P.modulepart.instances(I)
         printf("%s is a virtual part from %s in module %s with part instance on sheet %d\n",
                P.name, P.modulepart.name, P.module.name, I.sheet);
    }
    else {
       P.instances(I)
         printf("%s is a part on main schematic with instance on sheet %d\n",
                P.name, I.sheet);
    }
  }
}
</pre>
<pre>
schematic(S) {
  S.allparts(P) {
    if (P.modulepart) {
       string miNames[];
       int nr = strsplit(miNames, P.modulepath, ':');
       if (nr == 1)
          printf("%s is a virtual part created by module instance %s in main schematic.\n",
                 P.name, miNames[0]);
       else {
          printf("%s is a virtual part in a multiple hierarchy created by this path of module instances:\n", P.name);
          for (int i = 0; i &lt; nr; ++i)
              printf("%s\n", miNames[i]);
       }
    }
  }
}
</pre>


<a name=237>
<h1>UL_PIN</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#202>real</a> (<tt>0</tt>, <tt>90</tt>, <tt>180</tt> and <tt>270</tt>)</td></tr>
<tr><td><tt>contact</tt>      </td><td width=20><td><a href=#214>UL_CONTACT</a> (deprecated, see note)</td></tr>
<tr><td><tt>direction</tt>    </td><td width=20><td><a href=#201>int</a> (<tt>PIN_DIRECTION_...</tt>)</td></tr>
<tr><td><tt>function</tt>     </td><td width=20><td><a href=#201>int</a> (<tt>PIN_FUNCTION_FLAG_...</tt>)</td></tr>
<tr><td><tt>length</tt>       </td><td width=20><td><a href=#201>int</a> (<tt>PIN_LENGTH_...</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>PIN_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>net</tt>          </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>route</tt>        </td><td width=20><td><a href=#201>int</a> (<tt>CONTACT_ROUTE_...</tt>)</td></tr>
<tr><td><tt>swaplevel</tt>    </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>visible</tt>      </td><td width=20><td><a href=#201>int</a> (<tt>PIN_VISIBLE_FLAG_...</tt>)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (connection point)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#212>UL_CIRCLE</a></td></tr>
<tr><td><tt>contacts()</tt>   </td><td width=20><td><a href=#214>UL_CONTACT</a> (see note)</td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#248>UL_SYMBOL</a>,
<a href=#238>UL_PINREF</a>,
<a href=#215>UL_CONTACTREF</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_DIRECTION_NC</tt>  </td><td width=20><td>not connected</td></tr>
<tr><td><tt>PIN_DIRECTION_IN</tt>  </td><td width=20><td>input</td></tr>
<tr><td><tt>PIN_DIRECTION_OUT</tt> </td><td width=20><td>output (totem-pole)</td></tr>
<tr><td><tt>PIN_DIRECTION_IO</tt>  </td><td width=20><td>in/output (bidirectional)</td></tr>
<tr><td><tt>PIN_DIRECTION_OC</tt>  </td><td width=20><td>open collector</td></tr>
<tr><td><tt>PIN_DIRECTION_PWR</tt> </td><td width=20><td>power input pin</td></tr>
<tr><td><tt>PIN_DIRECTION_PAS</tt> </td><td width=20><td>passive</td></tr>
<tr><td><tt>PIN_DIRECTION_HIZ</tt> </td><td width=20><td>high impedance output</td></tr>
<tr><td><tt>PIN_DIRECTION_SUP</tt> </td><td width=20><td>supply pin</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_FUNCTION_FLAG_NONE</tt>  </td><td width=20><td>no symbol</td></tr>
<tr><td><tt>PIN_FUNCTION_FLAG_DOT</tt>   </td><td width=20><td>inverter symbol</td></tr>
<tr><td><tt>PIN_FUNCTION_FLAG_CLK</tt>   </td><td width=20><td>clock symbol</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_LENGTH_POINT</tt>  </td><td width=20><td>no wire</td></tr>
<tr><td><tt>PIN_LENGTH_SHORT</tt>  </td><td width=20><td>0.1 inch wire</td></tr>
<tr><td><tt>PIN_LENGTH_MIDDLE</tt> </td><td width=20><td>0.2 inch wire</td></tr>
<tr><td><tt>PIN_LENGTH_LONG</tt>   </td><td width=20><td>0.3 inch wire</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a pin name (used in formatted output only)</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PIN_VISIBLE_FLAG_OFF</tt>   </td><td width=20><td>no name drawn</td></tr>
<tr><td><tt>PIN_VISIBLE_FLAG_PAD</tt>   </td><td width=20><td>pad name drawn</td></tr>
<tr><td><tt>PIN_VISIBLE_FLAG_PIN</tt>   </td><td width=20><td>pin name drawn</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CONTACT_ROUTE_ALL</tt>   </td><td width=20><td>must explicitly route to all contacts</td></tr>
<tr><td><tt>CONTACT_ROUTE_ANY</tt>   </td><td width=20><td>may route to any contact</td></tr>
</table>
<h2>Note</h2>
The <tt>contacts()</tt> loop member loops through the <a href=#214>contacts</a>
that have been assigned to the pin through a <a href=#46>CONNECT</a>
command. This is the case in a UL_DEVICE context or coming via UL_PINREF, but not
via UL_LIBRARY.symbols(). If this is not the case the list is empty.
<p>
The <tt>contact</tt> data member returns the <a href=#214>contact</a>
that has been assigned to the pin through a <a href=#46>CONNECT</a>
command.
<b><i>This member is deprecated! It will work for backwards compatibility and as long
as only one pad has been connected to the pin, but will cause a runtime error when
used with a pin that is connected to more than one pad.</i></b>
<p>
The <tt>route</tt> member also only makes sense if there's a relation to contacts
the pin is connected to. Otherwise the value is set to 0.
<p>
The coordinates (and layer, in case of an SMD) of the contact returned by
the <tt>contact</tt> data member depend on the context in which it is called:
<ul>
<li>if the pin is derived from a UL_PART that is used on a sheet, and if there
is a corresponding element on the board, the resulting contact will have
the coordinates as used on the board
<li>in all other cases, the coordinates of the contact will be the same as
defined in the footprint drawing
</ul>
The <tt>name</tt> data member always returns the name of the pin as it was defined
in the library, with any <tt>'@'</tt> character for pins with the same name left intact
(see the <a href=#93>PIN</a> command for details).<br>
The <tt>texts</tt> loop member, on the other hand, returns the pin name (if it is
visible) in the same way as it is displayed in the current drawing type.
<p>
The <tt>net</tt> data member returns the name of the net to which this pin is connected to
(only available in a UL_SCHEMATIC context).
<h2>Example</h2>
<pre>
library(L) {
  L.symbols(S) {
    printf("Symbol: %s\n", S.name);
    S.pins(P) {
      printf("\tPin: %s, (%f %f)", P.name, u2mm(P.x), u2mm(P.y));
      if (P.direction == PIN_DIRECTION_IN)
         printf(" input");
      if ((P.function &amp; PIN_FUNCTION_FLAG_DOT) != 0)
         printf(" inverted");
      printf("\n");
      }
    }
  }
</pre>


<a name=238>
<h1>UL_PINREF</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>instance</tt>     </td><td width=20><td><a href=#225>UL_INSTANCE</a></td></tr>
<tr><td><tt>part</tt>         </td><td width=20><td><a href=#236>UL_PART</a></td></tr>
<tr><td><tt>pin</tt>          </td><td width=20><td><a href=#237>UL_PIN</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#244>UL_SEGMENT</a>,
<a href=#215>UL_CONTACTREF</a>
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    printf("Sheet: %d\n", SH.number);
    SH.nets(N) {
      printf("\tNet: %s\n", N.name);
      N.segments(SEG) {
        SEG.pinrefs(P) {
          printf("connected to: %s, %s, %s\n",
                 P.part.name, P.instance.name, P.pin.name);
          }
        }
      }
    }
  }
</pre>


<a name=239>
<h1>UL_POLYGON</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>isolate</tt>      </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>orphans</tt>      </td><td width=20><td><a href=#201>int</a> (0=off, 1=on)</td></tr>
<tr><td><tt>pour</tt>         </td><td width=20><td><a href=#201>int</a> (<tt>POLYGON_POUR_...</tt>)</td></tr>
<tr><td><tt>rank</tt>         </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>spacing</tt>      </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>thermals</tt>     </td><td width=20><td><a href=#201>int</a> (0=off, 1=on)</td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>contours()</tt>   </td><td width=20><td><a href=#253>UL_WIRE</a> (see note)</td></tr>
<tr><td><tt>fillings()</tt>   </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#233>UL_FOOTPRINT</a>,
<a href=#245>UL_SHEET</a>,
<a href=#246>UL_SIGNAL</a>,
<a href=#248>UL_SYMBOL</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>POLYGON_POUR_SOLID</tt>   </td><td width=20><td>solid</td></tr>
<tr><td><tt>POLYGON_POUR_HATCH</tt>   </td><td width=20><td>hatch</td></tr>
<tr><td><tt>POLYGON_POUR_CUTOUT</tt>  </td><td width=20><td>cutout</td></tr>
</table>
<h2>Note</h2>
The <tt>contours()</tt> and <tt>fillings()</tt> loop members loop through the
wires that are used to draw the calculated polygon if it is part of a signal and
the polygon has been calculated by the <a href=#104>RATSNEST</a>
command. The <tt>wires()</tt> loop member always loops through the polygon
wires as they were drawn by the user. For an uncalculated signal polygon
<tt>contours()</tt> does the same as <tt>wires()</tt>, and <tt>fillings()</tt>
does nothing.
<p>
If the <tt>contours()</tt> loop member is called without a second parameter,
it loops through all of the contour wires, regardless whether they
belong to a positive or a negative polygon. If you are interested in getting
the positive and negative contour wires separately, you can call <tt>contours()</tt>
with an additional integer parameter (see the second example below). The sign of
that parameter determines whether a positive or a negative polygon will be handled,
and the value indicates the index of that polygon. If there is no polygon with the
given index, the statement will not be executed. Another advantage of this method
is that you don't need to determine the beginning and end of a particular polygon
yourself (by comparing coordinates). For any given index, the statement will be
executed for all the wires of that polygon.
With the second parameter <tt>0</tt> the behavior is the same
as without a second parameter.
<h2>Polygon width</h2>
When using the <tt>fillings()</tt> loop member to get the fill wires of a solid
polygon, make sure the <i>width</i> of the polygon is not zero (actually it should
be quite a bit larger than zero, for example at least the hardware resolution of
the output device you are going to draw on). <b>Filling a polygon with zero width
may result in enormous amounts of data, since it will be calculated with the
smallest editor resolution of 1/320000mm!</b>
<h2>Partial polygons</h2>
A calculated signal polygon may consist of several distinct parts (called
<i>positive</i> polygons), each of which can contain extrusions (<i>negative</i>
polygons) resulting from other objects being subtracted from the polygon.
Negative polygons can again contain other positive polygons and so on.
<p>
The wires looped through by <tt>contours()</tt> always start with a positive
polygon. To find out where one partial polygon ends and the next one begins, simply
store the (x1,y1) coordinates of the first wire and check them against
(x2,y2) of every following wire. As soon as these are equal, the last wire
of a partial polygon has been found. It is also guaranteed that the second
point (x2,y2) of one wire is identical to the first point (x1,y1) of the
next wire in that partial polygon.
<p>
To find out where the "inside" and the "outside" of the polygon lays,
take any contour wire and imagine looking from its point (x1,y1) to (x2,y2).
The "inside" of the polygon is always on the right side of the wire.
Note that if you simply want to draw the polygon you won't need all these
details.
<h2>Example</h2>
<pre>
board(B) {
  B.signals(S) {
    S.polygons(P) {
      int x0, y0, first = 1;
      P.contours(W) {
        if (first) {
           // a new partial polygon is starting
           x0 = W.x1;
           y0 = W.y1;
           }
        // ...
        // do something with the wire
        // ...
        if (first)
           first = 0;
        else if (W.x2 == x0 &amp;&amp; W.y2 == y0) {
           // this was the last wire of the partial polygon,
           // so the next wire (if any) will be the first wire
           // of the next partial polygon
           first = 1;
           }
        }
      }
    }
  }
</pre>
<p>
<pre>
board(B) {
  B.signals(S) {
    S.polygons(P) {
      // handle only the "positive" polygons:
      int i = 1;
      int active;
      do {
         active = 0;
         P.contours(W, i) {
           active = 1;
           // do something with the wire
           }
         i++;
         } while (active);
      }
    }
  }
</pre>


<a name=240>
<h1>UL_PORT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>border</tt>       </td><td width=20><td><a href=#201>int</a> (<tt>MODULE_BORDER_...</tt>)</td></tr>
<tr><td><tt>bus</tt>          </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>direction</tt>    </td><td width=20><td><a href=#201>int</a> (<tt>PIN_DIRECTION_... (see note)</tt>)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>PORT_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>net</tt>          </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (connection point)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>nets()</tt>       </td><td width=20><td><a href=#232>UL_NET</a> (see note)</td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#230>UL_MODULE</a>,
<a href=#231>UL_MODULEINST</a>,
<a href=#241>UL_PORTREF</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>MODULE_BORDER_BOTTOM</tt>    </td><td width=20><td>at bottom border of module</td></tr>
<tr><td><tt>MODULE_BORDER_RIGHT</tt>     </td><td width=20><td>at right border of module</td></tr>
<tr><td><tt>MODULE_BORDER_TOP</tt>       </td><td width=20><td>at top border of module</td></tr>
<tr><td><tt>MODULE_BORDER_LEFT</tt>      </td><td width=20><td>at left border of module</td></tr>
<tr><td><tt>PORT_NAME_LENGTH</tt>        </td><td width=20><td>max. recommended length of a port name (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
The direction values are identical to the PIN_DIRECTION_... values (without PIN_DIRECTION_SUP).
<p>
The <tt>bus</tt> and the <tt>net</tt> data members return the name of the bus or net
to which this port is connected to (only available in a UL_MODULEINST context).
Additionally the <tt>nets</tt> loop member loops through all available nets of this
connection.
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.modules(M) {
    M.ports(P) printf("Port: %s\n", P.name);
    }
  }
</pre>


<a name=241>
<h1>UL_PORTREF</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>moduleinst</tt>   </td><td width=20><td><a href=#231>UL_MODULEINST</a></td></tr>
<tr><td><tt>port</tt>         </td><td width=20><td><a href=#240>UL_PORT</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#244>UL_SEGMENT</a>
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    printf("Sheet: %d\n", SH.number);
    SH.nets(N) {
      printf("\tNet: %s\n", N.name);
      N.segments(SEG) {
        SEG.portrefs(P) {
          printf("\tconnected to: %s, %s\n",
                 P.moduleinst.name, P.port.name);
          }
        }
      }
    }
  }
</pre>


<a name=242>
<h1>UL_RECTANGLE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#202>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#201>int</a> (lower left corner)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#201>int</a> (upper right corner)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#233>UL_FOOTPRINT</a>,
<a href=#245>UL_SHEET</a>,
<a href=#248>UL_SYMBOL</a>
<p>
The coordinates (x1 y1) and (x2 y2) are always referring to the initial orientation of the
rectangle regardless of the <tt>angle</tt>.
<p>
<tt>angle</tt> defines how many degrees the rectangle is rotated counterclockwise
around its center. The center coordinates are given by <tt>(x1+x2)/2</tt> and <tt>(y1+y2)/2</tt>.
<h2>Example</h2>
<pre>
board(B) {
  B.rectangles(R) {
    printf("Rectangle: (%f %f), (%f %f)\n",
           u2mm(R.x1), u2mm(R.y1), u2mm(R.x2), u2mm(R.y2));
    }
  }
</pre>


<a name=243>
<h1>UL_SCHEMATIC</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>alwaysvectorfont</tt></td><td width=20><td><a href=#201>int</a> (<tt>ALWAYS_VECTOR_FONT_..., see note</tt>)</td></tr>
<tr><td><tt>checked</tt>      </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>grid</tt>         </td><td width=20><td><a href=#223>UL_GRID</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>verticaltext</tt></td><td width=20><td><a href=#201>int</a> (<tt>VERTICAL_TEXT_...</tt>)</td></tr>
<tr><td><tt>xreflabel</tt>    </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>xrefpart</tt>     </td><td width=20><td><a href=#203>string</a></td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>allnets()</tt>    </td><td width=20><td><a href=#232>UL_NET</a> (see note)</td></tr>
<tr><td><tt>allparts()</tt>   </td><td width=20><td><a href=#236>UL_PART</a> (see note)</td></tr>
<tr><td><tt>attributes()</tt>  </td><td width=20><td><a href=#209>UL_ATTRIBUTE</a> (see note)</td></tr>
<tr><td><tt>classes()</tt>    </td><td width=20><td><a href=#213>UL_CLASS</a></td></tr>
<tr><td><tt>errors()</tt>     </td><td width=20><td><a href=#220>UL_ERROR</a></td></tr>
<tr><td><tt>layers()</tt>     </td><td width=20><td><a href=#228>UL_LAYER</a></td></tr>
<tr><td><tt>libraries()</tt>  </td><td width=20><td><a href=#229>UL_LIBRARY</a></td></tr>
<tr><td><tt>modules()</tt>    </td><td width=20><td><a href=#230>UL_MODULE</a></td></tr>
<tr><td><tt>nets()</tt>       </td><td width=20><td><a href=#232>UL_NET</a></td></tr>
<tr><td><tt>parts()</tt>      </td><td width=20><td><a href=#236>UL_PART</a></td></tr>
<tr><td><tt>sheets()</tt>     </td><td width=20><td><a href=#245>UL_SHEET</a></td></tr>
<tr><td><tt>variantdefs()</tt></td><td width=20><td><a href=#250>UL_VARIANTDEF</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#229>UL_LIBRARY</a>,
<a href=#349>variant()</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ALWAYS_VECTOR_FONT_GUI</tt></td><td width=20><td>alwaysvectorfont is set in the
<a href=#17>user interface dialog</a></td></tr>
<tr><td><tt>ALWAYS_VECTOR_FONT_PERSISTENT</tt></td><td width=20><td>alwaysvectorfont is set persistent in this schematic</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>VERTICAL_TEXT_UP</tt></td><td width=20><td>reading direction for vertical texts: up</td></tr>
<tr><td><tt>VERTICAL_TEXT_DOWN</tt></td><td width=20><td>reading direction for vertical texts: down</td></tr>
</table>
<h2>Note</h2>
The value returned by <tt>alwaysvectorfont</tt> can be used in boolean context
or can be masked with the <tt>ALWAYS_VECTOR_FONT_...</tt> constants to determine
the source of this setting, as in
<pre>
if (sch.alwaysvectorfont) {
   // alwaysvectorfont is set in general
   }
if (sch.alwaysvectorfont &amp; ALWAYS_VECTOR_FONT_GUI) {
   // alwaysvectorfont is set in the user interface
   }
</pre>
The value returned by <tt>checked</tt> can be used in boolean context and is
set only after a recent 'Electrical Rule Check' (<a href=#55>ERC</a>).
<p>
The <tt>name</tt> member returns the full file name, including the directory.
<p>
The <tt>xreflabel</tt> and  <tt>xrefpart</tt> members return the format strings used to display
<a href=#68>cross-reference labels</a> and <a href=#171>part cross-references</a>.
<p>
The <tt>attributes()</tt> loop member loops through the <i>global</i> attributes.
<h3>Virtual nets, <tt>allnets()</tt> loop</h3>
The <tt>allnets()</tt> loop member loops through the <tt>nets()</tt> of the
schematic itself and through all the virtual nets, generated by module instances.
<h3>Virtual parts, <tt>allparts()</tt> loop</h3>
Hierarchical parts are generated by module instances and actually do not exist in the schematic,
only corresponding parts in the modules. For this we sometimes call them 'Virtual parts'.
One module part can be used by several virtual parts via several module instances.
As each virtual part corresponds to a (real existing) element in the board,
the User Language supplies those parts as well, e.g. for BOM generation.<br>
The <tt>allparts()</tt> loop member loops through the <tt>parts()</tt> of the
schematic itself and through all the virtual parts.
<h2>Example</h2>
<pre>
schematic(S) {
  S.parts(P) printf("Part: %s\n", P.name);
  }
</pre>


<a name=244>
<h1>UL_SEGMENT</h1>
<dl>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>junctions()</tt>  </td><td width=20><td><a href=#226>UL_JUNCTION</a> (see note)</td></tr>
<tr><td><tt>labels()</tt>     </td><td width=20><td><a href=#227>UL_LABEL</a></td></tr>
<tr><td><tt>pinrefs()</tt>    </td><td width=20><td><a href=#238>UL_PINREF</a> (see note)</td></tr>
<tr><td><tt>portrefs()</tt>   </td><td width=20><td><a href=#241>UL_PORTREF</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a> (deprecated, see note)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#211>UL_BUS</a>,
<a href=#232>UL_NET</a>
<h2>Note</h2>
The <tt>junctions()</tt> and <tt>pinrefs()</tt> loop members are only available
for net segments.
<p>
The <tt>texts()</tt> loop member was used in older EAGLE versions to loop through
the labels of a segment, and is only present for compatibility. It will not
deliver the text of cross-reference labels at the correct position. Use the
<tt>labels()</tt> loop member to access a segment's labels.
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.sheets(SH) {
    printf("Sheet: %d\n", SH.number);
    SH.nets(N) {
      printf("\tNet: %s\n", N.name);
      N.segments(SEG) {
        SEG.pinrefs(P) {
          printf("connected to: %s, %s, %s\n",
                 P.part.name, P.instance.name, P.pin.name);
          }
        }
      }
    }
  }
</pre>


<a name=245>
<h1>UL_SHEET</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>area</tt>         </td><td width=20><td><a href=#208>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>  </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>headline</tt>     </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>number</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>busses()</tt>     </td><td width=20><td><a href=#211>UL_BUS</a></td></tr>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#212>UL_CIRCLE</a></td></tr>
<tr><td><tt>dimensions()</tt> </td><td width=20><td><a href=#218>UL_DIMENSION</a></td></tr>
<tr><td><tt>frames()</tt>     </td><td width=20><td><a href=#221>UL_FRAME</a></td></tr>
<tr><td><tt>instances()</tt>  </td><td width=20><td><a href=#225>UL_INSTANCE</a></td></tr>
<tr><td><tt>moduleinsts()</tt></td><td width=20><td><a href=#231>UL_MODULEINST</a></td></tr>
<tr><td><tt>nets()</tt>       </td><td width=20><td><a href=#232>UL_NET</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#239>UL_POLYGON</a></td></tr>
<tr><td><tt>rectangles()</tt> </td><td width=20><td><a href=#242>UL_RECTANGLE</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#243>UL_SCHEMATIC</a>
<h2>Example</h2>
<pre>
schematic(SCH) {
  SCH.sheets(S) {
    printf("Sheet: %d\n", S.number);
    }
  }
</pre>


<a name=246>
<h1>UL_SIGNAL</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>airwireshidden</tt></td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>class</tt>         </td><td width=20><td><a href=#213>UL_CLASS</a></td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>SIGNAL_NAME_LENGTH</tt>)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>contactrefs()</tt> </td><td width=20><td><a href=#215>UL_CONTACTREF</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#239>UL_POLYGON</a></td></tr>
<tr><td><tt>vias()</tt>       </td><td width=20><td><a href=#252>UL_VIA</a></td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SIGNAL_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a signal name (used in formatted output only)</td></tr>
</table>
<h2>Example</h2>
<pre>
board(B) {
  B.signals(S) printf("Signal: %s\n", S.name);
  }
</pre>


<a name=247>
<h1>UL_SMD</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#202>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>dx[layer], dy[layer]</tt>   </td><td width=20><td><a href=#201>int</a> (size)</td></tr>
<tr><td><tt>flags</tt>        </td><td width=20><td><a href=#201>int</a> (<tt>SMD_FLAG_...</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>name</tt>         </td><td width=20><td><a href=#203>string</a> (<tt>SMD_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>roundness</tt>    </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>signal</tt>       </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (center point, see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#233>UL_FOOTPRINT</a>,
<a href=#214>UL_CONTACT</a>,
<a href=#235>UL_PAD</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SMD_FLAG_STOP</tt>   </td><td width=20><td>generate stop mask</td></tr>
<tr><td><tt>SMD_FLAG_THERMALS</tt>         </td><td width=20><td>generate thermals</td></tr>
<tr><td><tt>SMD_FLAG_CREAM</tt>            </td><td width=20><td>generate cream mask</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SMD_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of an smd name (same as <tt>CONTACT_NAME_LENGTH</tt>)</td></tr>
</table>
<h2>Note</h2>
The parameters of the smd depend on the context in which it is accessed:
<ul>
<li>if the smd is derived from a UL_LIBRARY context, the coordinates (<tt>x, y</tt>), <tt>angle</tt>, <tt>layer</tt> and <tt>roundness</tt> of the smd will be the same as
defined in the footprint drawing
<li>in all other cases, they will have the actual values from the board
</ul>
If the <tt>dx</tt> and <tt>dy</tt> data members are called with an optional layer index,
the data for that layer is returned according to the <a href=#168>Design Rules</a>.
Valid <a href=#228>layers</a> are LAYER_TOP, LAYER_TSTOP and LAYER_TCREAM for an smd in the Top layer, and
LAYER_BOTTOM, LAYER_BSTOP and LAYER_BCREAM for an smd in the Bottom layer, respectively.
<p>
<tt>angle</tt> defines how many degrees the smd is rotated counterclockwise
around its center.
<p>
The value returned by <tt>flags</tt> must be masked with the <tt>SMD_FLAG_...</tt>
constants to determine the individual flag settings, as in
<pre>
if (smd.flags &amp; SMD_FLAG_STOP) {
   ...
   }
</pre>
Note that if your ULP just wants to draw the objects, you don't need to check these
flags explicitly. The <tt>dx[]</tt> and <tt>dy[]</tt> members will return
the proper data; for instance, if <tt>SMD_FLAG_STOP</tt> is set, <tt>dx[LAYER_TSTOP]</tt>
will return <tt>0</tt>, which should result in nothing being drawn in that layer.
The <tt>flags</tt> member is mainly for ULPs that want to create script files that
create library objects.
<h2>Example</h2>
<pre>
library(L) {
  L.footprints(FPT) {
    FPT.contacts(C) {
      if (C.smd)
         printf("Smd: '%s', (%f %f), dx=%f, dy=%f\n",
                 C.name, u2mm(C.smd.x), u2mm(C.smd.y), u2mm(C.smd.dx), u2mm(C.smd.dy));
      }
    }
  }
</pre>


<a name=248>
<h1>UL_SYMBOL</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>area</tt>           </td><td width=20><td><a href=#208>UL_AREA</a></td></tr>
<tr><td><tt>description</tt>    </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>headline</tt>       </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>library</tt>        </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>libraryurn</tt>     </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
<tr><td><tt>libraryversion</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>locallymodified</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>librarylocallymodified</tt> </td><td width=20><td><a href=#201>int</a> (see note)</td></tr>
<tr><td><tt>name</tt>           </td><td width=20><td><a href=#203>string</a> (<tt>SYMBOL_NAME_LENGTH</tt>)</td></tr>
<tr><td><tt>urn</tt>            </td><td width=20><td><a href=#203>string</a> (see note)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>circles()</tt>    </td><td width=20><td><a href=#212>UL_CIRCLE</a></td></tr>
<tr><td><tt>dimensions()</tt> </td><td width=20><td><a href=#218>UL_DIMENSION</a></td></tr>
<tr><td><tt>frames()</tt>     </td><td width=20><td><a href=#221>UL_FRAME</a></td></tr>
<tr><td><tt>rectangles()</tt> </td><td width=20><td><a href=#242>UL_RECTANGLE</a></td></tr>
<tr><td><tt>pins()</tt>       </td><td width=20><td><a href=#237>UL_PIN</a></td></tr>
<tr><td><tt>polygons()</tt>   </td><td width=20><td><a href=#239>UL_POLYGON</a></td></tr>
<tr><td><tt>texts()</tt>      </td><td width=20><td><a href=#249>UL_TEXT</a> (see note)</td></tr>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#222>UL_GATE</a>,
<a href=#229>UL_LIBRARY</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>SYMBOL_NAME_LENGTH</tt>   </td><td width=20><td>max. recommended length of a symbol name (used in formatted output only)</td></tr>
</table>
<h2>Note</h2>
If the UL_SYMBOL is derived from a UL_INSTANCE, the <tt>texts()</tt> member only loops through the
non-detached texts of that instance.
<p>
The <tt>urn</tt> contains a unique identifier for this symbol, of the form <tt>urn:adsk.eagle:symbol:123/4</tt>,
where the portion after the <tt>/</tt> is the version of the symbol. To get the base URN (without version), use
<a href=#338>urnbase()</a>; to get the version, use <a href=#339>urnversion()</a>.
<p>
The <tt>libraryurn</tt> and <tt>libraryversion</tt> are only applicable if this UL_SYMBOL comes from
a managed library. If not, <tt>libraryurn</tt> will be the empty string and <tt>libraryversion</tt> will
be -1.
<p>
The <tt>locallymodified</tt> member will be 0, if this UL_SYMBOL doesn't have local modifications, or 1, if this UL_SYMBOL has local modifications.
<br>The <tt>librarylocallymodified</tt> member will be 0 (if this UL_SYMBOL doesn't come from a locally-modified library) or 1 (if this UL_SYMBOL comes from a locally-modified library).
<h2>Example</h2>
<pre>
library(L) {
  L.symbols(S) printf("Sym: %s\n", S.name);
  }
</pre>


<a name=249>
<h1>UL_TEXT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>align</tt>        </td><td width=20><td><a href=#201>int</a> (<tt>ALIGN_...</tt>)</td></tr>
<tr><td><tt>angle</tt>        </td><td width=20><td><a href=#202>real</a> (<tt>0.0</tt>...<tt>359.9</tt>)</td></tr>
<tr><td><tt>font</tt>         </td><td width=20><td><a href=#201>int</a> (<tt>FONT_...</tt>)</td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>linedistance</tt> </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>mirror</tt>       </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>ratio</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>size</tt>         </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>spin</tt>         </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (origin point)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>wires()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#233>UL_FOOTPRINT</a>,
<a href=#245>UL_SHEET</a>,
<a href=#248>UL_SYMBOL</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>FONT_VECTOR</tt>   </td><td width=20><td>vector font</td></tr>
<tr><td><tt>FONT_PROPORTIONAL</tt>       </td><td width=20><td>proportional font</td></tr>
<tr><td><tt>FONT_FIXED</tt>              </td><td width=20><td>fixed font</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>ALIGN_BOTTOM_LEFT</tt>   </td><td width=20><td>bottom/left aligned</td></tr>
<tr><td><tt>ALIGN_BOTTOM_CENTER</tt> </td><td width=20><td>bottom/center aligned</td></tr>
<tr><td><tt>ALIGN_BOTTOM_RIGHT</tt>  </td><td width=20><td>bottom/right aligned</td></tr>
<tr><td><tt>ALIGN_CENTER_LEFT</tt>   </td><td width=20><td>center/left aligned</td></tr>
<tr><td><tt>ALIGN_CENTER</tt>        </td><td width=20><td>centered</td></tr>
<tr><td><tt>ALIGN_CENTER_RIGHT</tt>  </td><td width=20><td>center/right aligned</td></tr>
<tr><td><tt>ALIGN_TOP_LEFT</tt>      </td><td width=20><td>top/left aligned</td></tr>
<tr><td><tt>ALIGN_TOP_CENTER</tt>    </td><td width=20><td>top/center aligned</td></tr>
<tr><td><tt>ALIGN_TOP_RIGHT</tt>     </td><td width=20><td>top/right aligned</td></tr>
</table>
<h2>Note</h2>
The <tt>wires()</tt> loop member always accesses the individual wires the text
is composed of when using the vector font, even if the actual font is not
<tt>FONT_VECTOR</tt>.
<p>
If the UL_TEXT is derived from a UL_ELEMENT or UL_INSTANCE context, the member
values will be those of the actual text as located in the board or sheet drawing.
<h2>Example</h2>
<pre>
board(B) {
  B.texts(T) {
    printf("Text: %s\n", T.value);
    }
  }
</pre>


<a name=250>
<h1>UL_VARIANTDEF</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>name</tt>        </td><td width=20><td><a href=#203>string</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#251>UL_VARIANT</a>,
<a href=#243>UL_SCHEMATIC</a>,
<a href=#210>UL_BOARD</a>,
<a href=#349>variant()</a>
<h2>Example</h2>
<pre>
schematic(SCH) {
  printf("Defined assembly variants:\n");
  SCH.variantdefs(VD) {
    printf("\t'%s'\n", VD.name);
    }
  printf("\n");
  printf("Part\tVariantdef\tValue\tTechn.\tPopulated\n");
  SCH.parts(P) {
    printf("%s\t%s\t%s\t%s\t%s\n", P.name, "default", P.value, P.device.activetechnology, "yes");
    P.variants(V) {
      printf("%s\t%s\t%s\t%s\t%s\n", P.name, V.variantdef.name, V.value, V.technology, V.populate ? "yes" : "no");
      }
    }
  }
</pre>


<a name=251>
<h1>UL_VARIANT</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>populate</tt>     </td><td width=20><td><a href=#201>int</a> (0=do not populate, 1=populate)</td></tr>
<tr><td><tt>value</tt>        </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>technology</tt>   </td><td width=20><td><a href=#203>string</a></td></tr>
<tr><td><tt>variantdef</tt>   </td><td width=20><td><a href=#250>UL_VARIANTDEF</a></td></tr>
</table>
</dl>
<b>See also</b> <a href=#250>UL_VARIANTDEF</a>,
<a href=#236>UL_PART</a>,
<a href=#349>variant()</a>
<h2>Example</h2>
<pre>
schematic(SCH) {
  printf("Defined assembly variants:\n");
  SCH.variantdefs(VD) {
    printf("\t'%s'\n", VD.name);
    }
  printf("\n");
  printf("Part\tVariantdef\tValue\tTechn.\tPopulated\n");
  SCH.parts(P) {
    printf("%s\t%s\t%s\t%s\t%s\n", P.name, "default", P.value, P.device.activetechnology, "yes");
    P.variants(V) {
      printf("%s\t%s\t%s\t%s\t%s\n", P.name, V.variantdef.name, V.value, V.technology, V.populate ? "yes" : "no");
      }
    }
  }
</pre>


<a name=252>
<h1>UL_VIA</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>diameter[layer]</tt>     </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>drill</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>drillsymbol</tt>  </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>end</tt>          </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>flags</tt>        </td><td width=20><td><a href=#201>int</a> (<tt>VIA_FLAG_...</tt>)</td></tr>
<tr><td><tt>shape[layer]</tt> </td><td width=20><td><a href=#201>int</a> (<tt>VIA_SHAPE_...</tt>)</td></tr>
<tr><td><tt>start</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>x, y</tt>         </td><td width=20><td><a href=#201>int</a> (center point)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#246>UL_SIGNAL</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>VIA_FLAG_STOP</tt>   </td><td width=20><td>always generate stop mask</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>VIA_SHAPE_SQUARE</tt>   </td><td width=20><td>square</td></tr>
<tr><td><tt>VIA_SHAPE_ROUND</tt>    </td><td width=20><td>round</td></tr>
<tr><td><tt>VIA_SHAPE_OCTAGON</tt>  </td><td width=20><td>octagon</td></tr>
</table>
<h2>Note</h2>
The diameter and shape of the via depend on the layer for which they shall be retrieved,
because they may be different in each layer depending on the <a href=#168>Design Rules</a>.
If one of the <a href=#228>layers</a> LAYER_TOP...LAYER_BOTTOM, LAYER_TSTOP or LAYER_BSTOP
is given as the index to the diameter or shape data member, the resulting value will be calculated
according to the Design Rules. If LAYER_VIAS is given, the raw value as defined in the via  will
be returned.
<p>
Note that <tt>diameter</tt> and <tt>shape</tt> will always return the diameter or
shape that a via would have in the given layer, even if that particular via doesn't
cover that layer (or if that layer isn't used in the layer setup at all).
<p>
<tt>start</tt> and <tt>end</tt> return the layer numbers in which that via starts and
ends. The value of <tt>start</tt> will always be less than that of <tt>end</tt>.
<p>
<tt>drillsymbol</tt> returns the number of the drill symbol that has been assigned
to this drill diameter (see the manual for a list of defined drill symbols).
A value of <tt>0</tt> means that no symbol has been assigned to this drill diameter.
<h2>Example</h2>
<pre>
board(B) {
  B.signals(S) {
    S.vias(V) {
      printf("Via: (%f %f)\n", u2mm(V.x), u2mm(V.y));
      }
    }
  }
</pre>


<a name=253>
<h1>UL_WIRE</h1>
<dl>
<dt>
<b>Data members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>arc</tt>  </td><td width=20><td><a href=#207>UL_ARC</a></td></tr>
<tr><td><tt>cap</tt>          </td><td width=20><td><a href=#201>int</a> (<tt>CAP_...</tt>)</td></tr>
<tr><td><tt>curve</tt>        </td><td width=20><td><a href=#202>real</a></td></tr>
<tr><td><tt>layer</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>style</tt>        </td><td width=20><td><a href=#201>int</a> (<tt>WIRE_STYLE_...</tt>)</td></tr>
<tr><td><tt>width</tt>        </td><td width=20><td><a href=#201>int</a></td></tr>
<tr><td><tt>x1, y1</tt>       </td><td width=20><td><a href=#201>int</a> (starting point)</td></tr>
<tr><td><tt>x2, y2</tt>       </td><td width=20><td><a href=#201>int</a> (end point)</td></tr>
</table>
<dt>
<b>Loop members</b>
<dd>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>pieces()</tt>      </td><td width=20><td><a href=#253>UL_WIRE</a> (see note)</td></tr>
</table>
</dl>
<b>See also</b> <a href=#210>UL_BOARD</a>,
<a href=#233>UL_FOOTPRINT</a>,
<a href=#244>UL_SEGMENT</a>,
<a href=#245>UL_SHEET</a>,
<a href=#246>UL_SIGNAL</a>,
<a href=#248>UL_SYMBOL</a>,
<a href=#207>UL_ARC</a>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>CAP_FLAT</tt>  </td><td width=20><td>flat arc ends</td></tr>
<tr><td><tt>CAP_ROUND</tt>   </td><td width=20><td>round arc ends</td></tr>
<tr><td><tt>WIRE_STYLE_CONTINUOUS</tt>   </td><td width=20><td>continuous</td></tr>
<tr><td><tt>WIRE_STYLE_LONGDASH</tt>    </td><td width=20><td>long dash</td></tr>
<tr><td><tt>WIRE_STYLE_SHORTDASH</tt>   </td><td width=20><td>short dash</td></tr>
<tr><td><tt>WIRE_STYLE_DASHDOT</tt>     </td><td width=20><td>dash dot</td></tr>
</table>
<h2>Wire Style</h2>
A UL_WIRE that has a <i>style</i> other than <tt>WIRE_STYLE_CONTINUOUS</tt> can use the
<tt>pieces()</tt> loop member to access the individual segments that constitute
for example a dashed wire. If <tt>pieces()</tt> is called for a UL_WIRE with
<tt>WIRE_STYLE_CONTINUOUS</tt>, a single segment will be accessible which is just
the same as the original UL_WIRE. The <tt>pieces()</tt> loop member can't be called
from a UL_WIRE that itself has been returned by a call to <tt>pieces()</tt> (this would
cause an infinite recursion).
<h2>Arcs at Wire level</h2>
Arcs are basically wires, with a few additional properties. At the first level
arcs are treated exactly the same as wires, meaning they have a start and an end point,
a width, layer and wire style. In addition to these an arc, at the wire level, has
a <i>cap</i> and a <i>curve</i> parameter. <i>cap</i> defines whether the arc endings
are round or flat, and <i>curve</i> defines the "curvature" of the arc. The valid
range for <i>curve</i> is <tt>-360</tt>..<tt>+360</tt>, and its value means what part of
a full circle the arc consists of. A value of <tt>90</tt>, for instance, would
result in a <tt>90&deg;</tt> arc, while <tt>180</tt> would give you a semicircle.
The maximum value of <tt>360</tt> can only be reached theoretically, since this would
mean that the arc consists of a full circle, which, because the start and end points
have to lie on the circle, would have to have an infinitely large diameter.
Positive values for <i>curve</i> mean that the arc is drawn in a mathematically positive
sense (i.e. counterclockwise). If <i>curve</i> is <tt>0</tt>, the arc is a straight
line ("no curvature"), which is actually a wire.
<p>
The <i>cap</i> parameter only has a meaning for actual arcs, and will always return
<tt>CAP_ROUND</tt> for a straight wire.
<p>
Whether or not an UL_WIRE is an arc can be determined by checking the boolean return
value of the <tt>arc</tt> data member. If it returns <tt>0</tt>, we have a straight
wire, otherwise an arc. If <tt>arc</tt> returns a non-zero value it may be further
dereferenced to access the <a href=#207>UL_ARC</a> specific parameters start
and end angle, radius and center point. Note that you may only need these additional
parameters if you are going to draw the arc or process it in other ways where the
actual shape is important.
<h2>Example</h2>
<pre>
board(B) {
  B.wires(W) {
    printf("Wire: (%f %f) (%f %f)\n",
           u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2));
    }
  }
</pre>


<a name=254>
<h1>Definitions</h1>
The data items to be used in a User Language Program must be defined
before they can be used.
<p>
There are three kinds of definitions:
<ul>
<li><a href=#255>Constant Definitions</a>
<li><a href=#256>Variable Definitions</a>
<li><a href=#257>Function Definitions</a>
</ul>
The scope of a <i>constant</i> or <i>variable</i> definition
goes from the line in which it has been defined to the end of the current
<a href=#273>block</a>, or to the end of the User
Language Program, if the definition appeared outside any block.
<p>
The scope of a <i>function</i> definition goes from the closing
brace (<tt>}</tt>) of the function body to the end of the User Language
Program.


<a name=255>
<h1>Constant Definitions</h1>
<i>Constants</i> are defined using the keyword <tt>enum</tt>, as in
<pre>
enum { a, b, c };
</pre>
which would define the three constants <tt>a</tt>, <tt>b</tt> and <tt>c</tt>,
giving them the values <tt>0</tt>, <tt>1</tt> and <tt>2</tt>, respectively.
<p>
Constants may also be initialized to specific values, like
<pre>
enum { a, b = 5, c };
</pre>
where <tt>a</tt> would be <tt>0</tt>, <tt>b</tt> would be <tt>5</tt> and
<tt>c</tt> would be <tt>6</tt>.


<a name=256>
<h1>Variable Definitions</h1>
The general syntax of a <i>variable definition</i> is
<pre>
[numeric] type identifier [= initializer][, ...];
</pre>
where <tt>type</tt> is one of the
<a href=#199>data</a> or
<a href=#206>object types</a>,
<tt>identifier</tt> is the name of the variable, and <tt>initializer</tt>
is a optional initial value.
<p>
Multiple variable definitions of the same <tt>type</tt> are separated
by commas (<tt>,</tt>).
<p>
If <tt>identifier</tt> is followed by a pair of
<a href=#192>brackets</a> (<tt>[]</tt>), this defines an array
of variables of the given <tt>type</tt>. The size of an array is
automatically adjusted at runtime.
<p>
The optional keyword <tt>numeric</tt> can be used with
<a href=#203>string</a> arrays to have them sorted
alphanumerically by the <a href=#312>sort()</a> function.
<p>
By default (if no <tt>initializer</tt> is present),
<a href=#199>data variables</a> are set to <tt>0</tt>
(or <tt>""</tt>, in case of a string), and
<a href=#206>object variables</a> are "invalid".
<h2>Examples</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>int i;</tt>   </td><td width=20><td>defines an <a href=#201>int</a> variable named <tt>i</tt></td></tr>
<tr><td><tt>string s = "Hello";</tt> </td><td width=20><td>defines a <a href=#203>string</a> variable named <tt>s</tt> and initializes it to <tt>"Hello"</tt></td></tr>
<tr><td><tt>real a, b = 1.0, c;</tt> </td><td width=20><td>defines three <a href=#202>real</a> variables named <tt>a</tt>, <tt>b</tt> and <tt>c</tt>, initializing <tt>b</tt> to the value <tt>1.0</tt></td></tr>
<tr><td><tt>int n[] = { 1, 2, 3 };</tt> </td><td width=20><td>defines an array of <a href=#201>int</a>, initializing the first three elements to <tt>1</tt>, <tt>2</tt> and <tt>3</tt></td></tr>
<tr><td><tt>numeric string names[];</tt> </td><td width=20><td>defines a <a href=#203>string</a> array that can be sorted alphanumerically</td></tr>
<tr><td><tt>UL_WIRE w;</tt> </td><td width=20><td>defines a <a href=#253>UL_WIRE</a> object named <tt>w</tt></td></tr>
</table>
The members of array elements of <a href=#206>object types</a> can't be accessed directly:
<pre>
UL_SIGNAL signals[];
...
UL_SIGNAL s = signals[0];
printf("%s", s.name);
</pre>


<a name=257>
<h1>Function Definitions</h1>
You can write your own User Language functions and call them just like the
<a href=#287>Builtin Functions</a>.
<p>
The general syntax of a <i>function definition</i> is
<pre>
type identifier(parameters)
{
  statements
}
</pre>
where <tt>type</tt> is one of the
<a href=#199>data</a> or
<a href=#206>object types</a>,
<tt>identifier</tt> is the name of the function,
<tt>parameters</tt> is a list of comma separated parameter definitions,
and <tt>statements</tt> is a sequence of <a href=#272>statements</a>.
<p>
Functions that do not return a value have the type <tt>void</tt>.
<p>
A function must be defined <b>before</b> it can be called, and function
calls can not be recursive (a function cannot call itself).
<p>
The statements in the function body may modify the values of the parameters,
but this will not have any effect on the arguments of the
<a href=#271>function call</a>.
<p>
Execution of a function can be terminated by the
<tt><a href=#281>return</a></tt> statement. Without any
<tt>return</tt> statement the function body is executed until it's closing
brace (<tt>}</tt>).
<p>
A call to the <tt><a href=#306>exit()</a></tt> function will
terminate the entire User Language Program.
<h2>The special function <tt>main()</tt></h2>
If your User Language Program contains a function called
<tt>main()</tt>, that function will be explicitly called as the
main function, and it's return value will be the
<a href=#175>return value</a> of the program.
<p>
Command line arguments are available to the program through the global
<a href=#286>Builtin Variables</a> <tt>argc</tt> and <tt>argv</tt>.
<h2>Example</h2>
<pre>
int CountDots(string s)
{
  int dots = 0;
  for (int i = 0; s[i]; ++i)
      if (s[i] == '.')
         ++dots;
  return dots;
}
string dotted = "This.has.dots...";
output("test") {
  printf("Number of dots: %d\n",
                 CountDots(dotted));
  }
</pre>


<a name=258>
<h1>Operators</h1>
The following table lists all of the User Language operators, in order
of their precedence (<i>Unary</i> having the highest precedence,
<i>Comma</i> the lowest):
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>Unary           </td><td width=20><td><tt><a href=#260>!</a> <a href=#259>~</a> <a href=#263>+ - ++ --</a></tt></td></tr>
<tr><td>Multiplicative  </td><td width=20><td><tt><a href=#263>* / %</a></tt></td></tr>
<tr><td>Additive        </td><td width=20><td><tt><a href=#263>+ -</a></tt></td></tr>
<tr><td>Shift           </td><td width=20><td><tt><a href=#259>&lt;&lt; &gt;&gt;</a></tt></td></tr>
<tr><td>Relational      </td><td width=20><td><tt><a href=#261>&lt; &lt;= &gt; &gt;=</a></tt></td></tr>
<tr><td>Equality        </td><td width=20><td><tt><a href=#261>== !=</a></tt></td></tr>
<tr><td>Bitwise AND     </td><td width=20><td><tt><a href=#259>&amp;</a></tt></td></tr>
<tr><td>Bitwise XOR     </td><td width=20><td><tt><a href=#259>^</a></tt></td></tr>
<tr><td>Bitwise OR      </td><td width=20><td><tt><a href=#259>|</a></tt></td></tr>
<tr><td>Logical AND     </td><td width=20><td><tt><a href=#260>&amp;&amp;</a></tt></td></tr>
<tr><td>Logical OR      </td><td width=20><td><tt><a href=#260>||</a></tt></td></tr>
<tr><td>Conditional     </td><td width=20><td><tt><a href=#262>?:</a></tt></td></tr>
<tr><td>Assignment      </td><td width=20><td><tt><a href=#263>= *= /= %= += -=</a> <a href=#259>&amp;= ^= |= &lt;&lt;= &gt;&gt;=</a></tt></td></tr>
<tr><td>Comma           </td><td width=20><td><tt><a href=#262>,</a></tt></td></tr>
</table>
<p>
Associativity is <b>left to right</b> for all operators, except for
<i>Unary</i>, <i>Conditional</i> and <i>Assignment</i>,
which are <b>right to left</b> associative.
<p>
The normal operator precedence can be altered by the use of
<a href=#193>parentheses</a>.


<a name=259>
<h1>Bitwise Operators</h1>
Bitwise operators work only with data types
<tt><a href=#200>char</a></tt> and
<tt><a href=#201>int</a></tt>.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Unary</b>   </td><td width=20><td></td></tr>
<tr><td><tt>~</tt>          </td><td width=20><td>Bitwise (1's) complement</td></tr>
<tr><td><b>Binary</b>  </td><td width=20><td></td></tr>
<tr><td><tt>&lt;&lt;</tt>         </td><td width=20><td>Shift left</td></tr>
<tr><td><tt>&gt;&gt;</tt>         </td><td width=20><td>Shift right</td></tr>
<tr><td><tt>&amp;</tt>          </td><td width=20><td>Bitwise AND</td></tr>
<tr><td><tt>^</tt>          </td><td width=20><td>Bitwise XOR</td></tr>
<tr><td><tt>|</tt>          </td><td width=20><td>Bitwise OR</td></tr>
<tr><td><b>Assignment</b>  </td><td width=20><td></td></tr>
<tr><td><tt>&amp;=</tt>         </td><td width=20><td>Assign bitwise AND</td></tr>
<tr><td><tt>^=</tt>         </td><td width=20><td>Assign bitwise XOR</td></tr>
<tr><td><tt>|=</tt>         </td><td width=20><td>Assign bitwise OR</td></tr>
<tr><td><tt>&lt;&lt;=</tt>        </td><td width=20><td>Assign left shift</td></tr>
<tr><td><tt>&gt;&gt;=</tt>        </td><td width=20><td>Assign right shift</td></tr>
</table>


<a name=260>
<h1>Logical Operators</h1>
Logical operators work with <a href=#265>expressions</a>
of any data type.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Unary</b>   </td><td width=20><td></td></tr>
<tr><td><tt>!</tt>          </td><td width=20><td>Logical NOT</td></tr>
<tr><td><b>Binary</b>  </td><td width=20><td></td></tr>
<tr><td><tt>&amp;&amp;</tt>         </td><td width=20><td>Logical AND</td></tr>
<tr><td><tt>||</tt>         </td><td width=20><td>Logical OR</td></tr>
</table>
<p>
Using a <tt><a href=#203>string</a></tt> expression with a
logical operator checks whether the string is empty.
<p>
Using an <a href=#206>Object Type</a> with a logical
operator checks whether that object contains valid data.


<a name=261>
<h1>Comparison Operators</h1>
Comparison operators work with <a href=#265>expressions</a>
of any data type,
except <a href=#206>Object Types</a>.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>&lt;</tt>          </td><td width=20><td>Less than</td></tr>
<tr><td><tt>&lt;=</tt>         </td><td width=20><td>Less than or equal to</td></tr>
<tr><td><tt>&gt;</tt>          </td><td width=20><td>Greater than</td></tr>
<tr><td><tt>&gt;=</tt>         </td><td width=20><td>Greater than or equal to</td></tr>
<tr><td><tt>==</tt>         </td><td width=20><td>Equal to</td></tr>
<tr><td><tt>!=</tt>         </td><td width=20><td>Not equal to</td></tr>
</table>


<a name=262>
<h1>Evaluation Operators</h1>
Evaluation operators are used to evaluate <a href=#265>expressions</a>
based on a condition, or to group a sequence of expressions and have them
evaluated as one expression.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>?:</tt>         </td><td width=20><td>Conditional</td></tr>
<tr><td><tt>,</tt>          </td><td width=20><td>Comma</td></tr>
</table>
<p>
The <i>Conditional</i> operator is used to make a decision within
an expression, as in
<pre>
int a;
// ...code that calculates 'a'
string s = a ? "True" : "False";
</pre>
which is basically the same as
<pre>
int a;
string s;
// ...code that calculates 'a'
if (a)
   s = "True";
else
   s = "False";
</pre>
but the advantage of the conditional operator is that it can be used in
an expression.
<p>
The <i>Comma</i> operator is used to evaluate a sequence of expressions
from left to right, using the type and value of the right operand as
the result.
<p>
Note that arguments in a function call as well as multiple variable declarations
also use commas as delimiters, but in that case this is <b>not</b> a
comma operator!


<a name=263>
<h1>Arithmetic Operators</h1>
Arithmetic operators work with data types
<tt><a href=#200>char</a></tt>,
<tt><a href=#201>int</a></tt> and
<tt><a href=#202>real</a></tt>
(except for <tt>++</tt>, <tt>--</tt>, <tt>%</tt> and <tt>%=</tt>).
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Unary</b>   </td><td width=20><td></td></tr>
<tr><td><tt>+</tt>          </td><td width=20><td>Unary plus</td></tr>
<tr><td><tt>-</tt>          </td><td width=20><td>Unary minus</td></tr>
<tr><td><tt>++</tt>         </td><td width=20><td>Pre- or postincrement</td></tr>
<tr><td><tt>--</tt>         </td><td width=20><td>Pre- or postdecrement</td></tr>
<tr><td><b>Binary</b>  </td><td width=20><td></td></tr>
<tr><td><tt>*</tt>          </td><td width=20><td>Multiply</td></tr>
<tr><td><tt>/</tt>          </td><td width=20><td>Divide</td></tr>
<tr><td><tt>%</tt>          </td><td width=20><td>Remainder (modulus)</td></tr>
<tr><td><tt>+</tt>          </td><td width=20><td>Binary plus</td></tr>
<tr><td><tt>-</tt>          </td><td width=20><td>Binary minus</td></tr>
<tr><td><b>Assignment</b> </td><td width=20><td></td></tr>
<tr><td><tt>=</tt>          </td><td width=20><td>Simple assignment</td></tr>
<tr><td><tt>*=</tt>         </td><td width=20><td>Assign product</td></tr>
<tr><td><tt>/=</tt>         </td><td width=20><td>Assign quotient</td></tr>
<tr><td><tt>%=</tt>         </td><td width=20><td>Assign remainder (modulus)</td></tr>
<tr><td><tt>+=</tt>         </td><td width=20><td>Assign sum</td></tr>
<tr><td><tt>-=</tt>         </td><td width=20><td>Assign difference</td></tr>
</table>
<p>
<b>See also</b> <a href=#264>String Operators</a>


<a name=264>
<h1>String Operators</h1>
String operators work with data types
<tt><a href=#200>char</a></tt>,
<tt><a href=#201>int</a></tt> and
<tt><a href=#203>string</a></tt>.
The left operand must always be of type
<tt><a href=#203>string</a></tt>.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Binary</b>  </td><td width=20><td></td></tr>
<tr><td><tt>+</tt>          </td><td width=20><td>Concatenation</td></tr>
<tr><td><b>Assignment</b> </td><td width=20><td></td></tr>
<tr><td><tt>=</tt>          </td><td width=20><td>Simple assignment</td></tr>
<tr><td><tt>+=</tt>         </td><td width=20><td>Append to string</td></tr>
</table>
<p>
The <tt>+</tt> operator concatenates two strings, or adds a character
to the end of a string and returns the resulting string.
<p>
The <tt>+=</tt> operator appends a string or a character to the end of
a given string.
<p>
<b>See also</b> <a href=#263>Arithmetic Operators</a>


<a name=265>
<h1>Expressions</h1>
An <i>expression</i> can be one of the following:
<ul>
<li><a href=#266>Arithmetic Expression</a>
<li><a href=#267>Assignment Expression</a>
<li><a href=#268>String Expression</a>
<li><a href=#269>Comma Expression</a>
<li><a href=#270>Conditional Expression</a>
<li><a href=#271>Function Call</a>
</ul>
Expressions can be grouped using <a href=#193>parentheses</a>,
and may be recursive, meaning that an expression can consist of
subexpressions.


<a name=266>
<h1>Arithmetic Expression</h1>
An <i>arithmetic expression</i> is any combination of numeric
operands and an <a href=#263>arithmetic operator</a> or a
<a href=#259>bitwise operator</a>.
<h2>Examples</h2>
<pre>
a + b
c++
m &lt;&lt; 1
</pre>


<a name=267>
<h1>Assignment Expression</h1>
An <i>assignment expression</i> consists of a variable on the left
side of an <a href=#263>assignment operator</a>, and an
expression on the right side.
<h2>Examples</h2>
<pre>
a = x + 42
b += c
s = "Hello"
</pre>


<a name=268>
<h1>String Expression</h1>
A <i>string expression</i> is any combination of
<a href=#203>string</a> and <a href=#200>char</a>
operands and a <a href=#264>string operator</a>.
<h2>Examples</h2>
<pre>
s + ".brd"
t + 'x'
</pre>


<a name=269>
<h1>Comma Expression</h1>
A <i>comma expression</i> is a sequence of expressions, delimited by
the <a href=#262>comma operator</a>
<p>
Comma expressions are evaluated left to right, and the result of a comma
expression is the type and value of the rightmost expression.
<h2>Example</h2>
<pre>
i++, j++, k++
</pre>


<a name=270>
<h1>Conditional Expression</h1>
A <i>conditional expression</i> uses the
<a href=#262>conditional operator</a> to make a decision
within an expression.
<h2>Example</h2>
<pre>
int a;
// ...code that calculates 'a'
string s = a ? "True" : "False";
</pre>


<a name=271>
<h1>Function Call</h1>
A <i>function call</i> transfers the program flow to a
<a href=#257>user defined function</a> or a
<a href=#287>builtin function</a>.
The formal parameters defined in the
<a href=#257>function definition</a> are replaced
with the values of the expressions used as the actual arguments of the
function call.
<h2>Example</h2>
<pre>
int p = strchr(s, 'b');
</pre>


<a name=272>
<h1>Statements</h1>
A <i>statement</i> can be one of the following:
<ul>
<li><a href=#273>Compound Statement</a>
<li><a href=#275>Control Statement</a>
<li><a href=#274>Expression Statement</a>
<li><a href=#355>Builtin Statement</a>
<li><a href=#255>Constant Definition</a>
<li><a href=#256>Variable Definition</a>
</ul>
Statements specify the flow of control as a User Language Program
executes. In absence of specific control statements, statements are
executed sequentially in the order of appearance in the ULP file.


<a name=273>
<h1>Compound Statement</h1>
A <i>compound statement</i> (also known as <i>block</i>) is a list
(possibly empty) of statements enclosed in matching braces (<tt>{}</tt>).
Syntactically, a block can be considered to be a single statement, but it
also controls the scoping of identifiers. An
<a href=#184>identifier</a> declared within a block has a
scope starting at the point of declaration and ending at the closing
brace.
<p>
Compound statements can be nested to any depth.


<a name=274>
<h1>Expression Statement</h1>
An <i>expression statement</i> is any
<a href=#265>expression</a> followed by a
<a href=#196>semicolon</a>.
<p>
An expression statement is executed by evaluating the expression.
All side effects of this evaluation are completed before the next
<a href=#272>statement</a> is executed.
Most expression statements are
<a href=#267>assignments</a> or
<a href=#271>function calls</a>.
<p>
A special case is the <i>empty statement</i>, consisting of only a
<a href=#196>semicolon</a>.
An empty statement does nothing, but it may be useful in situations
where the ULP syntax expects a statement but your program does not
need one.


<a name=275>
<h1>Control Statements</h1>
<i>Control statements</i> are used to control the program flow.
<p>
Iteration statements are
<pre>
<a href=#278>do...while</a>
<a href=#279>for</a>
<a href=#283>while</a>
</pre>
Selection statements are
<pre>
<a href=#280>if...else</a>
<a href=#282>switch</a>
</pre>
Jump statements are
<pre>
<a href=#276>break</a>
<a href=#277>continue</a>
<a href=#281>return</a>
</pre>


<a name=276>
<h1>break</h1>
The <i>break</i> statement has the general syntax
<pre>
break;
</pre>
and immediately terminates the <b>nearest</b> enclosing
<a href=#278>do...while</a>,
<a href=#279>for</a>,
<a href=#282>switch</a> or
<a href=#283>while</a>
statement.
This also applies to <i>loop members</i> of <a href=#206>object types</a>.
<p>
Since all of these statements can be intermixed and nested to any
depth, take care to ensure that your <tt>break</tt> exits from the
correct statement.


<a name=277>
<h1>continue</h1>
The <i>continue</i> statement has the general syntax
<pre>
continue;
</pre>
and immediately transfers control to the test condition of the
<b>nearest</b> enclosing
<a href=#278>do...while</a>,
<a href=#283>while</a>, or
<a href=#279>for</a> statement, or to the increment expression
of the <b>nearest</b> enclosing
<a href=#283>for</a>
statement.
<p>
Since all of these statements can be intermixed and nested to any
depth, take care to ensure that your <tt>continue</tt> affects the
correct statement.


<a name=278>
<h1>do...while</h1>
The <i>do...while</i> statement has the general syntax
<pre>
do statement while (condition);
</pre>
and executes the <tt>statement</tt> until the <tt>condition</tt>
expression becomes zero.
<p>
The <tt>condition</tt> is tested <b>after</b> the first
execution of <tt>statement</tt>, which means that the statement is
always executed at least one time.
<p>
If there is no
<tt><a href=#276>break</a></tt> or
<tt><a href=#281>return</a></tt>
inside the <tt>statement</tt>, the <tt>statement</tt> must affect
the value of the <tt>condition</tt>, or <tt>condition</tt> itself must
change during evaluation in order to avoid an endless loop.
<h2>Example</h2>
<pre>
string s = "Trust no one!";
int i = -1;
do {
   ++i;
   } while (s[i]);
</pre>


<a name=279>
<h1>for</h1>
The <i>for</i> statement has the general syntax
<pre>
for ([init]; [test]; [inc]) statement
</pre>
and performs the following steps:
<ol>
<li>If an initializing expression <tt>init</tt> is present, it is executed.
<li>If a <tt>test</tt> expression is present, it is executed. If the result
is nonzero (or if there is no <tt>test</tt> expression at all), the
<tt>statement</tt> is executed.
<li>If an <tt>inc</tt> expression is present, it is executed.
<li>Finally control returns to step 2.
</ol>
If there is no
<tt><a href=#276>break</a></tt> or
<tt><a href=#281>return</a></tt>
inside the <tt>statement</tt>, the <tt>inc</tt> expression (or the
<tt>statement</tt>) must affect
the value of the <tt>test</tt> expression, or <tt>test</tt> itself must
change during evaluation in order to avoid an endless loop.
<p>
The initializing expression <tt>init</tt> normally initializes one or more
loop counters. It may also define a new variable as a loop counter.
The scope of such a variable is valid until the end of the block
which encloses the for loop.
<h2>Example</h2>
<pre>
string s = "Trust no one!";
int sum = 0;
for (int i = 0; s[i]; ++i)
    sum += s[i]; // sums up the characters in s
</pre>


<a name=280>
<h1>if...else</h1>
The <i>if...else</i> statement has the general syntax
<pre>
if (expression)
   t_statement
[else
   f_statement]
</pre>
The conditional <tt>expression</tt> is evaluated, and if its value is nonzero
the <tt>t_statement</tt> is executed. Otherwise the <tt>f_statement</tt> is
executed in case there is an <tt>else</tt> clause.
<p>
An <tt>else</tt> clause is always matched to the last encountered <tt>if</tt>
without an <tt>else</tt>. If this is not what you want, you need to use
<a href=#194>braces</a> to group the statements, as in
<pre>
if (a == 1) {
   if (b == 1)
      printf("a == 1 and b == 1\n");
   }
else
   printf("a != 1\n");
</pre>


<a name=281>
<h1>return</h1>
A <a href=#257>function</a> with a return type
other than <tt>void</tt> must contain at least one <i>return</i>
statement with the syntax
<pre>
return expression;
</pre>
where <tt>expression</tt> must evaluate to a type that is compatible with
the function's return type. The value of <tt>expression</tt> is the value
returned by the function.
<p>
If the function is of type <tt>void</tt>, a <tt>return</tt> statement
without an <tt>expression</tt> can be used to return from the function
call.


<a name=282>
<h1>switch</h1>
The <i>switch</i> statement has the general syntax
<pre>
switch (sw_exp) {
  case case_exp: case_statement
  ...
  [default: def_statement]
  }
</pre>
and allows for the transfer of control to one of several
<tt>case</tt>-labeled statements, depending on the value of
<tt>sw_exp</tt> (which must be of integral type).
<p>
Any <tt>case_statement</tt> can be labeled by one or more <tt>case</tt>
labels. The <tt>case_exp</tt> of each <tt>case</tt> label must evaluate
to a constant integer which is unique within it's enclosing <tt>switch</tt>
statement.
<p>
There can also be at most one <tt>default</tt> label.
<p>
After evaluating <tt>sw_exp</tt>, the <tt>case_exp</tt> are checked for
a match. If a match is found, control passes to the <tt>case_statement</tt>
with the matching <tt>case</tt> label.
<p>
If no match is found and there is a <tt>default</tt> label, control
passes to <tt>def_statement</tt>. Otherwise none of the statements in the
<tt>switch</tt> is executed.
<p>
Program execution is not affected when <tt>case</tt> and <tt>default</tt>
labels are encountered. Control simply passes through the labels to the
following statement.
<p>
To stop execution at the end of a group of statements for a particular
<tt>case</tt>, use the <a href=#276>break</a> statement.
<h2>Example</h2>
<pre>
string s = "Hello World";
int vowels = 0, others = 0;
for (int i = 0; s[i]; ++i)
    switch (toupper(s[i])) {
      case 'A':
      case 'E':
      case 'I':
      case 'O':
      case 'U': ++vowels;
                break;
      default: ++others;
      }
printf("There are %d vowels in '%s'\n", vowels, s);
</pre>


<a name=283>
<h1>while</h1>
The <i>while</i> statement has the general syntax
<pre>
while (condition) statement
</pre>
and executes the <tt>statement</tt> as long as the <tt>condition</tt>
expression is not zero.
<p>
The <tt>condition</tt> is tested <b>before</b> the first possible
execution of <tt>statement</tt>, which means that the statement may never
be executed if <tt>condition</tt> is initially zero.
<p>
If there is no
<tt><a href=#276>break</a></tt> or
<tt><a href=#281>return</a></tt>
inside the <tt>statement</tt>, the <tt>statement</tt> must affect
the value of the <tt>condition</tt>, or <tt>condition</tt> itself must
change during evaluation in order to avoid an endless loop.
<h2>Example</h2>
<pre>
string s = "Trust no one!";
int i = 0;
while (s[i])
      ++i;
</pre>


<a name=284>
<h1>Builtins</h1>
Builtins are <i>Constants</i>, <i>Variables</i>, <i>Functions</i> and <i>Statements</i>
that provide additional information and allow for data manipulations.
<ul>
<li><a href=#285>Builtin Constants</a>
<li><a href=#286>Builtin Variables</a>
<li><a href=#287>Builtin Functions</a>
<li><a href=#355>Builtin Statements</a>
</ul>


<a name=285>
<h1>Builtin Constants</h1>
<i>Builtin constants</i> are used to provide information about
object parameters, such as maximum recommended name length, flags etc.
<p>
Many of the <a href=#206>object types</a> have their
own <b>Constants</b> section which lists the builtin constants for that
particular object (see e.g. <a href=#237>UL_PIN</a>).
<p>
The following builtin constants are defined in addition to the ones
listed for the various object types:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>EAGLE_VERSION</tt> </td><td width=20><td>EAGLE program version number (<a href=#201>int</a>)</td></tr>
<tr><td><tt>EAGLE_RELEASE</tt> </td><td width=20><td>EAGLE program release number (<a href=#201>int</a>)</td></tr>
<tr><td><tt>EAGLE_SIGNATURE</tt> </td><td width=20><td>a <a href=#203>string</a> containing EAGLE program name, version and copyright information</td></tr>
<tr><td><tt>EAGLE_PATH</tt> </td><td width=20><td>a <a href=#203>string</a> containing the complete path of the EAGLE executable</td></tr>
<tr><td><tt>EAGLE_DIR</tt> </td><td width=20><td>a <a href=#203>string</a> containing the directory of the EAGLE installation (<tt>$EAGLEDIR</tt>)</td></tr>
<tr><td><tt>EAGLE_HOME</tt> </td><td width=20><td>a <a href=#203>string</a> containing the user's home directory when starting EAGLE (<tt>$HOME</tt>)</td></tr>
<tr><td><tt>eagle_epf</tt> </td><td width=20><td>a <a href=#203>string</a> containing the complete path of the currently used <tt>eagle.epf</tt></td></tr>
<tr><td><tt>OS_SIGNATURE</tt> </td><td width=20><td>a <a href=#203>string</a> containing a signature of the operating system (e.g. Mac..., Windows... or Linux)</td></tr>
<tr><td><tt>REAL_EPSILON</tt> </td><td width=20><td>the minimum positive <a href=#202>real</a> number such that <tt>1.0 + REAL_EPSILON != 1.0</tt></td></tr>
<tr><td><tt>REAL_MAX</tt> </td><td width=20><td>the largest possible <a href=#202>real</a> value</td></tr>
<tr><td><tt>REAL_MIN</tt> </td><td width=20><td>the smallest possible (positive!) <a href=#202>real</a> value<br>the smallest representable number is <tt>-REAL_MAX</tt></td></tr>
<tr><td><tt>INT_MAX</tt> </td><td width=20><td>the largest possible <a href=#201>int</a> value</td></tr>
<tr><td><tt>INT_MIN</tt> </td><td width=20><td>the smallest possible <a href=#201>int</a> value</td></tr>
<tr><td><tt>PI</tt> </td><td width=20><td>the value of "pi" (3.14..., <a href=#202>real</a>)</td></tr>
<tr><td><tt>usage</tt> </td><td width=20><td>a <a href=#203>string</a> containing the text from the <tt><a href=#182>#usage</a></tt> directive</td></tr>
</table>
<p>
These builtin constants contain the directory paths defined in the
<a href=#15>directories dialog</a>, with any of the special
variables (<tt>$HOME</tt> and <tt>$EAGLEDIR</tt>) replaced by their actual values.
Since each path can consist of several directories, these constants are <a href=#203>string</a>
arrays with an individual directory in each member. The first empty member marks the end of the path:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>path_lbr[]</tt> </td><td width=20><td>Libraries</td></tr>
<tr><td><tt>path_dru[]</tt> </td><td width=20><td>Design Rules</td></tr>
<tr><td><tt>path_ulp[]</tt> </td><td width=20><td>User Language Programs</td></tr>
<tr><td><tt>path_scr[]</tt> </td><td width=20><td>Scripts</td></tr>
<tr><td><tt>path_cam[]</tt> </td><td width=20><td>CAM Jobs</td></tr>
<tr><td><tt>path_epf[]</tt> </td><td width=20><td>Projects</td></tr>
</table>
<p>
When using these constants to build a full file name, you need to use a directory separator,
as in
<pre>
string s = path_lbr[0] + '/' + "mylib.lbr";
</pre>
<p>
The libraries that are currently in use through the <a href=#135>USE</a> command:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>used_libraries[]</tt> </td><td width=20><td></td></tr>
</table>


<a name=286>
<h1>Builtin Variables</h1>
<i>Builtin variables</i> are used to provide information at runtime.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>int argc</tt> </td><td width=20><td>number of arguments given to the <a href=#114>RUN</a> command</td></tr>
<tr><td><tt>string argv[]</tt>      </td><td width=20><td>arguments given to the RUN command (<tt>argv[0]</tt> is the full ULP file name)</td></tr>
</table>


<a name=287>
<h1>Builtin Functions</h1>
<i>Builtin functions</i> are used to perform specific tasks, like
printing formatted strings, sorting data arrays or the like.
<p>
You may also write your own <a href=#257>functions</a>
and use them to structure your User Language Program.
<p>
The builtin functions are grouped into the following categories:
<ul>
<li><a href=#288>Character Functions</a>
<li><a href=#291>File Handling Functions</a>
<li><a href=#298>Mathematical Functions</a>
<li><a href=#303>Miscellaneous Functions</a>
<li><a href=#316>Network Functions</a>
<li><a href=#320>Printing Functions</a>
<li><a href=#323>String Functions</a>
<li><a href=#340>Time Functions</a>
<li><a href=#344>Object Functions</a>
<li><a href=#350>XML Functions</a>
</ul>
Alphabetical reference of all builtin functions:
<ul>
<li><a href=#299>abs()</a>
<li><a href=#301>acos()</a>
<li><a href=#301>asin()</a>
<li><a href=#301>atan()</a>
<li><a href=#300>ceil()</a>
<li><a href=#304>cfgget()</a>
<li><a href=#304>cfgset()</a>
<li><a href=#345>clrgroup()</a>
<li><a href=#305>country()</a>
<li><a href=#301>cos()</a>
<li><a href=#306>exit()</a>
<li><a href=#302>exp()</a>
<li><a href=#307>fdlsignature()</a>
<li><a href=#294>filedir()</a>
<li><a href=#292>fileerror()</a>
<li><a href=#294>fileext()</a>
<li><a href=#293>fileglob()</a>
<li><a href=#294>filename()</a>
<li><a href=#297>fileread()</a>
<li><a href=#294>filesetext()</a>
<li><a href=#295>filesize()</a>
<li><a href=#295>filetime()</a>
<li><a href=#300>floor()</a>
<li><a href=#300>frac()</a>
<li><a href=#315>inch2u()</a>
<li><a href=#346>ingroup()</a>
<li><a href=#289>isalnum()</a>
<li><a href=#289>isalpha()</a>
<li><a href=#289>iscntrl()</a>
<li><a href=#289>isdigit()</a>
<li><a href=#289>isgraph()</a>
<li><a href=#289>islower()</a>
<li><a href=#289>isprint()</a>
<li><a href=#289>ispunct()</a>
<li><a href=#289>isspace()</a>
<li><a href=#289>isupper()</a>
<li><a href=#289>isxdigit()</a>
<li><a href=#308>language()</a>
<li><a href=#302>log()</a>
<li><a href=#302>log10()</a>
<li><a href=#309>lookup()</a>
<li><a href=#299>max()</a>
<li><a href=#315>mic2u()</a>
<li><a href=#315>mil2u()</a>
<li><a href=#299>min()</a>
<li><a href=#315>mm2u()</a>
<li><a href=#317>neterror()</a>
<li><a href=#318>netget()</a>
<li><a href=#319>netpost()</a>
<li><a href=#310>palette()</a>
<li><a href=#302>pow()</a>
<li><a href=#321>printf()</a>
<li><a href=#300>round()</a>
<li><a href=#347>setgroup()</a>
<li><a href=#348>setvariant()</a>
<li><a href=#301>sin()</a>
<li><a href=#311>sleep()</a>
<li><a href=#312>sort()</a>
<li><a href=#322>sprintf()</a>
<li><a href=#302>sqrt()</a>
<li><a href=#313>status()</a>
<li><a href=#324>strchr()</a>
<li><a href=#325>strjoin()</a>
<li><a href=#326>strlen()</a>
<li><a href=#327>strlwr()</a>
<li><a href=#328>strrchr()</a>
<li><a href=#329>strrstr()</a>
<li><a href=#330>strsplit()</a>
<li><a href=#331>strstr()</a>
<li><a href=#332>strsub()</a>
<li><a href=#333>strtod()</a>
<li><a href=#334>strtol()</a>
<li><a href=#335>strupr()</a>
<li><a href=#336>strxstr()</a>
<li><a href=#314>system()</a>
<li><a href=#343>t2day()</a>
<li><a href=#343>t2dayofweek()</a>
<li><a href=#343>t2hour()</a>
<li><a href=#343>t2minute()</a>
<li><a href=#343>t2month()</a>
<li><a href=#343>t2second()</a>
<li><a href=#343>t2string()</a>
<li><a href=#343>t2year()</a>
<li><a href=#301>tan()</a>
<li><a href=#341>time()</a>
<li><a href=#290>tolower()</a>
<li><a href=#290>toupper()</a>
<li><a href=#300>trunc()</a>
<li><a href=#315>u2inch()</a>
<li><a href=#315>u2mic()</a>
<li><a href=#315>u2mil()</a>
<li><a href=#315>u2mm()</a>
<li><a href=#349>variant()</a> 
<li><a href=#351>xmlattribute()</a>
<li><a href=#351>xmlattributes()</a>
<li><a href=#352>xmlelement()</a>
<li><a href=#352>xmlelements()</a>
<li><a href=#353>xmltags()</a>
<li><a href=#354>xmltext()</a>
</ul>


<a name=288>
<h1>Character Functions</h1>
<i>Character functions</i> are used to manipulate single characters.
<p>
The following character functions are available:
<ul>
<li><a href=#289>isalnum()</a>
<li><a href=#289>isalpha()</a>
<li><a href=#289>iscntrl()</a>
<li><a href=#289>isdigit()</a>
<li><a href=#289>isgraph()</a>
<li><a href=#289>islower()</a>
<li><a href=#289>isprint()</a>
<li><a href=#289>ispunct()</a>
<li><a href=#289>isspace()</a>
<li><a href=#289>isupper()</a>
<li><a href=#289>isxdigit()</a>
<li><a href=#290>tolower()</a>
<li><a href=#290>toupper()</a>
</ul>


<a name=289>
<h1>is...()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Check whether a character falls into a given category.
<dt>
<b>Syntax</b>
<dd>
<tt>int isalnum(char c);</tt><br>
<tt>int isalpha(char c);</tt><br>
<tt>int iscntrl(char c);</tt><br>
<tt>int isdigit(char c);</tt><br>
<tt>int isgraph(char c);</tt><br>
<tt>int islower(char c);</tt><br>
<tt>int isprint(char c);</tt><br>
<tt>int ispunct(char c);</tt><br>
<tt>int isspace(char c);</tt><br>
<tt>int isupper(char c);</tt><br>
<tt>int isxdigit(char c);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>is...</tt> functions return nonzero if the given character falls
into the category, zero otherwise.
</dl>
<h2>Character categories</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>isalnum</tt> </td><td width=20><td>letters (<tt>A</tt> to <tt>Z</tt> or <tt>a</tt> to <tt>z</tt>) or digits (<tt>0</tt> to <tt>9</tt>)</td></tr>
<tr><td><tt>isalpha </tt> </td><td width=20><td>letters (<tt>A</tt> to <tt>Z</tt> or <tt>a</tt> to <tt>z</tt>)</td></tr>
<tr><td><tt>iscntrl </tt> </td><td width=20><td>delete characters or ordinary control characters (<tt>0x7F</tt> or <tt>0x00</tt> to <tt>0x1F</tt>)</td></tr>
<tr><td><tt>isdigit </tt> </td><td width=20><td>digits (<tt>0</tt> to <tt>9</tt>)</td></tr>
<tr><td><tt>isgraph </tt> </td><td width=20><td>printing characters (except space)</td></tr>
<tr><td><tt>islower </tt> </td><td width=20><td>lowercase letters (<tt>a</tt> to <tt>z</tt>)</td></tr>
<tr><td><tt>isprint </tt> </td><td width=20><td>printing characters (<tt>0x20</tt> to <tt>0x7E</tt>)</td></tr>
<tr><td><tt>ispunct </tt> </td><td width=20><td>punctuation characters (<tt>iscntrl</tt> or <tt>isspace</tt>)</td></tr>
<tr><td><tt>isspace </tt> </td><td width=20><td>space, tab, carriage return, new line, vertical tab, or formfeed (<tt>0x09</tt> to <tt>0x0D</tt>, <tt>0x20</tt>)</td></tr>
<tr><td><tt>isupper </tt> </td><td width=20><td>uppercase letters (<tt>A</tt> to <tt>Z</tt>)</td></tr>
<tr><td><tt>isxdigit</tt> </td><td width=20><td>hex digits (<tt>0</tt> to <tt>9</tt>, <tt>A</tt> to <tt>F</tt>, <tt>a</tt> to <tt>f</tt>)</td></tr>
</table>
<h2>Example</h2>
<pre>
char c = 'A';
if (isxdigit(c))
   printf("%c is hex\n", c);
else
   printf("%c is not hex\n", c);
</pre>


<a name=290>
<h1>to...()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Convert a character to upper- or lowercase.
<dt>
<b>Syntax</b>
<dd>
<tt>char tolower(char c);</tt><br>
<tt>char toupper(char c);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>tolower</tt> function returns the converted character if <tt>c</tt>
is uppercase. All other characters are returned unchanged.<br>
The <tt>toupper</tt> function returns the converted character if <tt>c</tt>
is lowercase. All other characters are returned unchanged.
</dl>
<b>See also</b> <a href=#335>strupr</a>,
<a href=#327>strlwr</a>


<a name=291>
<h1>File Handling Functions</h1>
<i>Filename handling functions</i> are used to work with file names,
sizes and timestamps.
<p>
The following file handling functions are available:
<ul>
<li><a href=#292>fileerror()</a>
<li><a href=#293>fileglob()</a>
<li><a href=#294>filedir()</a>
<li><a href=#294>fileext()</a>
<li><a href=#294>filename()</a>
<li><a href=#297>fileread()</a>
<li><a href=#294>filesetext()</a>
<li><a href=#295>filesize()</a>
<li><a href=#295>filetime()</a>
</ul>
See <a href=#360>output()</a> for information about how to write into a file.


<a name=292>
<h1>fileerror()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Returns the status of I/O operations.
<dt>
<b>Syntax</b>
<dd>
<tt>int fileerror();</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>fileerror</tt> function returns <tt>0</tt> if everything is ok.
</dl>
<b>See also</b> <a href=#360>output</a>,
<a href=#321>printf</a>,
<a href=#297>fileread</a>
<p>
<tt>fileerror</tt> checks the status of any I/O operations that have been performed
since the last call to this function and returns <tt>0</tt> if everything was ok.
If any of the I/O operations has caused an error, a value other than <tt>0</tt>
will be returned.
<p>
You should call <tt>fileerror</tt> before any I/O operations to reset any previous
error state, and call it again after the I/O operations to see if they were successful.
<p>
When <tt>fileerror</tt> returns a value other than <tt>0</tt> (thus indicating an error)
a proper error message has already been given to the user.
<h2>Example</h2>
<pre>
fileerror();
output("file.txt", "wt") {
  printf("Test\n");
  }
if (fileerror())
   exit(1);
</pre>


<a name=293>
<h1>fileglob()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Perform a directory search.
<dt>
<b>Syntax</b>
<dd>
<tt>int fileglob(string &amp;array[], string pattern);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>fileglob</tt> function returns the number of entries copied into <tt>array</tt>.
</dl>
<b>See also</b> <a href=#368>dlgFileOpen()</a>,
<a href=#368>dlgFileSave()</a>
<p>
<tt>fileglob</tt> performs a directory search using <tt>pattern</tt>.
<p>
<tt>pattern</tt> may contain <tt>'*'</tt> and <tt>'?'</tt> as wildcard characters.
If <tt>pattern</tt> ends with a <tt>'/'</tt>, the contents of the given directory will be returned.
<p>
Names in the resulting <tt>array</tt> that end with a <tt>'/'</tt> are directory names.
<p>
The <tt>array</tt> is sorted alphabetically, with the directories coming first.
<p>
The special entries <tt>'.'</tt> and <tt>'..'</tt> (for the current and parent directories)
are never returned in the <tt>array</tt>.
<p>
If <tt>pattern</tt> doesn't match, or if you don't have permission to search the given
directory, the resulting <tt>array</tt> will be empty.
<h2>Note for Windows users</h2>
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
The directory delimiter in the <tt>array</tt> is always a <b>forward slash</b>.
This makes sure User Language Programs will work platform independently.
In the <tt>pattern</tt> the <b>backslash</b> (<tt>'\'</tt>) is also treated
as a directory delimiter.
<p>
Sorting filenames under Windows is done case insensitively.
</td></tr></table>
<h2>Example</h2>
<pre>
string a[];
int n = fileglob(a, "*.brd");
</pre>


<a name=294>
<h1>Filename Functions</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Split a filename into its separate parts.
<dt>
<b>Syntax</b>
<dd>
<tt>string filedir(string file);</tt><br>
<tt>string fileext(string file);</tt><br>
<tt>string filename(string file);</tt><br>
<tt>string filesetext(string file, string newext);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>filedir   </tt> returns the directory of <tt>file</tt> (including the drive letter under Windows).<br>
<tt>fileext   </tt> returns the extension of <tt>file</tt>.<br>
<tt>filename  </tt> returns the file name of <tt>file</tt> (including the extension).<br>
<tt>filesetext</tt> returns <tt>file</tt> with the extension set to <tt>newext</tt>.
</dl>
<b>See also</b> <a href=#295>Filedata Functions</a>
<h2>Example</h2>
<pre>
if (board) board(B) {
  output(filesetext(B.name, ".out")) {
    ...
    }
  }
</pre>


<a name=295>
<h1>Filedata Functions</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Gets the timestamp and size of a file.
<dt>
<b>Syntax</b>
<dd>
<tt>int filesize(string filename);</tt><br>
<tt>int filetime(string filename);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>filesize</tt> returns the size (in byte) of the given file.<br>
<tt>filetime</tt> returns the timestamp of the given file in seconds. The format is
compatible to be used with the <a href=#340>time functions</a>.
</dl>
<b>See also</b> <a href=#341>time</a>,
<a href=#294>Filename Functions</a>
<h2>Example</h2>
<pre>
board(B)
  printf("Board: %s\nSize: %d\nTime: %s\n",
         B.name, filesize(B.name),
         t2string(filetime(B.name)));
</pre>


<a name=296>
<h1>File Input Functions</h1>
<i>File input functions</i> are used to read data from files.
<p>
The following file input is available:
<ul>
<li><a href=#297>fileread()</a>
</ul>
See <a href=#360>output()</a> for information about how to write into a file.


<a name=297>
<h1>fileread()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Reads data from a file.
<dt>
<b>Syntax</b>
<dd>
<tt>int fileread(<i>dest</i>, string file);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>fileread</tt> returns the number of objects read from the file.<br>
The actual meaning of the return value depends on the type of <tt>dest</tt>.
</dl>
<b>See also</b> <a href=#309>lookup</a>,
<a href=#330>strsplit</a>,
<a href=#292>fileerror</a>
<p>
If <tt>dest</tt> is a character array, the file will be read as raw binary data
and the return value reflects the number of bytes read into the character array
(which is equal to the file size).
<p>
If <tt>dest</tt> is a string array, the file will be read as a text file (one line
per array member) and the return value will be the number of lines read into the
string array. Newline characters will be stripped.
<p>
If <tt>dest</tt> is a string, the entire file will be read into that string
and the return value will be the length of that string (which is not necessarily
equal to the file size, if the operating system stores text files with "cr/lf"
instead of a "newline" character).
<h2>Example</h2>
<pre>
char b[];
int nBytes = fileread(b, "data.bin");
string lines[];
int nLines = fileread(lines, "data.txt");
string text;
int nChars = fileread(text, "data.txt");
</pre>


<a name=298>
<h1>Mathematical Functions</h1>
<i>Mathematical functions</i> are used to perform mathematical
operations.
<p>
The following mathematical functions are available:
<ul>
<li><a href=#299>abs()</a>
<li><a href=#301>acos()</a>
<li><a href=#301>asin()</a>
<li><a href=#301>atan()</a>
<li><a href=#300>ceil()</a>
<li><a href=#301>cos()</a>
<li><a href=#302>exp()</a>
<li><a href=#300>floor()</a>
<li><a href=#300>frac()</a>
<li><a href=#302>log()</a>
<li><a href=#302>log10()</a>
<li><a href=#299>max()</a>
<li><a href=#299>min()</a>
<li><a href=#302>pow()</a>
<li><a href=#300>round()</a>
<li><a href=#301>sin()</a>
<li><a href=#302>sqrt()</a>
<li><a href=#300>trunc()</a>
<li><a href=#301>tan()</a>
</ul>
<h2>Error Messages</h2>
If the arguments of a mathematical function call lead to an error, the
error message will show the actual values of the arguments. Thus the
statements
<pre>
real x = -1.0;
real r = sqrt(2 * x);
</pre>
will lead to the error message
<pre>
Invalid argument in call to 'sqrt(-2)'
</pre>


<a name=299>
<h1>Absolute, Maximum and Minimum Functions</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Absolute, maximum and minimum functions.
<dt>
<b>Syntax</b>
<dd>
<tt>type abs(type x);</tt><br>
<tt>type max(type x, type y);</tt><br>
<tt>type min(type x, type y);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>abs</tt> returns the absolute value of <tt>x</tt>.<br>
<tt>max</tt> returns the maximum of <tt>x</tt> and <tt>y</tt>.<br>
<tt>min</tt> returns the minimum of <tt>x</tt> and <tt>y</tt>.
<p>
The return type of these functions is the same as the (larger) type
of the arguments. <tt>type</tt> must be one of
<tt><a href=#200>char</a></tt>,
<tt><a href=#201>int</a></tt> or
<tt><a href=#202>real</a></tt>.
</dl>
<h2>Example</h2>
<pre>
real x = 2.567, y = 3.14;
printf("The maximum is %f\n", max(x, y));
</pre>


<a name=300>
<h1>Rounding Functions</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Rounding functions.
<dt>
<b>Syntax</b>
<dd>
<tt>real ceil(real x);</tt><br>
<tt>real floor(real x);</tt><br>
<tt>real frac(real x);</tt><br>
<tt>real round(real x);</tt><br>
<tt>real trunc(real x);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>ceil </tt> returns the smallest integer not less than <tt>x</tt>.<br>
<tt>floor</tt> returns the largest integer not greater than <tt>x</tt>.<br>
<tt>frac </tt> returns the fractional part of <tt>x</tt>.<br>
<tt>round</tt> returns <tt>x</tt> rounded to the nearest integer.<br>
<tt>trunc</tt> returns the integer part of <tt>x</tt>.
</dl>
<h2>Example</h2>
<pre>
real x = 2.567;
printf("The rounded value of %f is %f\n", x, round(x));
</pre>


<a name=301>
<h1>Trigonometric Functions</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Trigonometric functions.
<dt>
<b>Syntax</b>
<dd>
<tt>real acos(real x);</tt><br>
<tt>real asin(real x);</tt><br>
<tt>real atan(real x);</tt><br>
<tt>real cos(real x);</tt><br>
<tt>real sin(real x);</tt><br>
<tt>real tan(real x);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>acos</tt> returns the arc cosine of <tt>x</tt>.<br>
<tt>asin</tt> returns the arc sine of <tt>x</tt>.<br>
<tt>atan</tt> returns the arc tangent of <tt>x</tt>.<br>
<tt>cos </tt> returns the cosine of <tt>x</tt>.<br>
<tt>sin </tt> returns the sine of <tt>x</tt>.<br>
<tt>tan </tt> returns the tangent of <tt>x</tt>.
</dl>
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PI</tt> </td><td width=20><td>the value of "pi" (3.14...)</td></tr>
</table>
<h2>Note</h2>
Angles are given in radian.
<h2>Example</h2>
<pre>
real x = PI / 2;
printf("The sine of %f is %f\n", x, sin(x));
</pre>


<a name=302>
<h1>Exponential Functions</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Exponential Functions.
<dt>
<b>Syntax</b>
<dd>
<tt>real exp(real x);</tt><br>
<tt>real log(real x);</tt><br>
<tt>real log10(real x);</tt><br>
<tt>real pow(real x, real y);</tt><br>
<tt>real sqrt(real x);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>exp  </tt> returns the exponential <i>e</i> to the power of <tt>x</tt>.<br>
<tt>log  </tt> returns the natural logarithm of <tt>x</tt>.<br>
<tt>log10</tt> returns the base 10 logarithm of <tt>x</tt>.<br>
<tt>pow  </tt> returns the value of <tt>x</tt> to the power of <tt>y</tt>.<br>
<tt>sqrt </tt> returns the square root of <tt>x</tt>.
</dl>
<h2>Example</h2>
<pre>
real x = 2.1;
printf("The square root of %f is %f\n", x, sqrt(x));
printf("The 3rd root of %f is %f\n", x, pow(x, 1.0/3));
</pre>


<a name=303>
<h1>Miscellaneous Functions</h1>
<i>Miscellaneous functions</i> are used to perform various tasks.
<p>
The following miscellaneous functions are available:
<ul>
<li><a href=#305>country()</a>
<li><a href=#306>exit()</a>
<li><a href=#307>fdlsignature()</a>
<li><a href=#308>language()</a>
<li><a href=#309>lookup()</a>
<li><a href=#310>palette()</a>
<li><a href=#312>sort()</a>
<li><a href=#313>status()</a>
<li><a href=#314>system()</a>
<li><a href=#304>Configuration Parameters</a>
<li><a href=#315>Unit Conversions</a>
</ul>


<a name=304>
<h1>Configuration Parameters</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Store and retrieve configuration parameters.
<dt>
<b>Syntax</b>
<dd>
<tt>string cfgget(string name[, string default]);</tt><br>
<tt>void cfgset(string name, string value);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>cfgget</tt> returns the value of the parameter stored under the given <tt>name</tt>.
If no such parameter has been stored, yet, the value of the optional <tt>default</tt>
is returned (or an empty string, if no <tt>default</tt> is given).
</dl>
The <tt>cfgget</tt> function retrieves values that have previously been stored with
a call to <tt>cfgset()</tt>.
<p>
The <tt>cfgset</tt> function sets the parameter with the given <tt>name</tt> to
the given <tt>value</tt>.
<p>
The valid characters for <tt>name</tt> are
<tt>'A'</tt>-<tt>'Z'</tt>,
<tt>'a'</tt>-<tt>'z'</tt>,
<tt>'0'</tt>-<tt>'9'</tt>,
<tt>'.'</tt> and
<tt>'_'</tt>.<br>
Parameter names are case sensitive.
<p>
The parameters are stored in the user's eaglerc file.
To ensure that different User Language Programs don't overwrite each other's
parameters in case they use the same parameter names, it is recommended to put
the name of the ULP at the beginning of the parameter name. For example, a ULP
named <tt>mytool.ulp</tt> that uses a parameter named <tt>MyParam</tt> could store
that parameter under the name
<pre>
mytool.MyParam
</pre>
Because the configuration parameters are stored in the eaglerc file, which also
contains all of EAGLE's other user specific parameters, it is also possible to
access the EAGLE parameters with <tt>cfgget()</tt> and <tt>cfgset()</tt>.
In order to make sure no ULP parameters collide with any EAGLE parameters, the
EAGLE parameters must be prefixed with <tt>"EAGLE:"</tt>, as in
<pre>
EAGLE:Option.XrefLabelFormat
</pre>
Note that there is no documentation of all of EAGLE's internal parameters and how
they are stored in the eaglerc file. Also, be very careful when changing any of these
parameters! As with the eaglerc file itself, you should only manipulate these
parameters if you know what you are doing! Some EAGLE parameters may require a
restart of EAGLE for changes to take effect.
<p>
In the eaglerc file the User Language parameters are stored with the prefix
<tt>"ULP:"</tt>. Therefore this prefix may be optionally put in front of User Language
parameter names, as in
<pre>
ULP:mytool.MyParam
</pre>
<h2>Example</h2>
<pre>
string MyParam = cfgget("mytool.MyParam", "SomeDefault");
MyParam = "OtherValue";
cfgset("mytool.MyParam", MyParam);
</pre>


<a name=305>
<h1>country()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Returns the country code of the system in use.
<dt>
<b>Syntax</b>
<dd>
<tt>string country();</tt>
<dt>
<b>Returns</b>
<dd>
<tt>country</tt> returns a string consisting of two uppercase characters
that identifies the country used on the current system.
If no such country setting can be determined, the default "US" will
be returned.
</dl>
<b>See also</b> <a href=#308>language</a>
<h2>Example</h2>
<pre>
dlgMessageBox("Your country code is: " + country());
</pre>


<a name=306>
<h1>exit()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Exits from a User Language Program.
<dt>
<b>Syntax</b>
<dd>
<tt>void exit(int result);</tt><br>
<tt>void exit(string command);</tt>
</dl>
<b>See also</b> <a href=#114>RUN</a>
<p>
The <tt>exit</tt> function terminates execution of a User Language Program.<br>
If an integer <tt>result</tt> is given it will be used as the
<a href=#175>return value</a> of the program.<br>
If a string <tt>command</tt> is given, that command will be executed as if it
were entered into the command line immediately after the RUN command. In that
case the return value of the ULP is set to <tt>EXIT_SUCCESS</tt>.
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>EXIT_SUCCESS</tt>   </td><td width=20><td>return value for successful program execution (value <tt>0</tt>)</td></tr>
<tr><td><tt>EXIT_FAILURE</tt>   </td><td width=20><td>return value for failed program execution (value <tt>-1</tt>)</td></tr>
</table>
<p>


<a name=307>
<h1>fdlsignature()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Calculates a digital signature for Premier Farnell's <i>Design Link</i>.
<dt>
<b>Syntax</b>
<dd>
<tt>string fdlsignature(string s, string key);</tt>
</dl>
The <tt>fdlsignature</tt> function is used to calculate a digital signature
when accessing Premier Farnell's <i>Design Link</i> interface.


<a name=308>
<h1>language()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Returns the language code of the system in use.
<dt>
<b>Syntax</b>
<dd>
<tt>string language();</tt>
<dt>
<b>Returns</b>
<dd>
<tt>language</tt> returns a string consisting of two lowercase characters
that identifies the language used on the current system.
If no such language setting can be determined, the default "en" will
be returned.
</dl>
<b>See also</b> <a href=#305>country</a>
<p>
The <tt>language</tt> function can be used to make a ULP use different
message string, depending on which language the current system is using.
<p>
In the example below all the strings used in the ULP are listed in the
string array <tt>I18N[]</tt>, preceeded by a string containing the
various language codes supported by this ULP. Note the <tt>vtab</tt>
characters used to separate the individual parts of each string (they
are important for the <tt>lookup</tt> function) and the use of the commas
to separate the strings. The actual work is done in the function <tt>tr()</tt>,
which returns the translated version of the given string.
If the original string can't be found in the <tt>I18N</tt> array, or there
is no translation for the current language, the original string will be used
untranslated.
<p>
The first language defined in the <tt>I18N</tt> array must be the one in which
the strings used throughout the ULP are written, and should generally be
English in order to make the program accessible to the largest number of users.
<h2>Example</h2>
<pre>
string I18N[] = {
  "en\v"
  "de\v"
  "it\v"
  ,
  "I18N Demo\v"
  "Beispiel f?r Internationalisierung\v"
  "Esempio per internazionalizzazione\v"
  ,
  "Hello world!\v"
  "Hallo Welt!\v"
  "Ciao mondo!\v"
  ,
  "+Ok\v"
  "+Ok\v"
  "+Approvazione\v"
  ,
  "-Cancel\v"
  "-Abbrechen\v"
  "-Annullamento\v"
  };
int Language = strstr(I18N[0], language()) / 3;
string tr(string s)
{
  string t = lookup(I18N, s, Language, '\v');
  return t ? t : s;
}
dlgDialog(tr("I18N Demo")) {
  dlgHBoxLayout dlgSpacing(350);
  dlgLabel(tr("Hello world!"));
  dlgHBoxLayout {
    dlgPushButton(tr("+Ok")) dlgAccept();
    dlgPushButton(tr("-Cancel")) dlgReject();
    }
  };
</pre>


<a name=309>
<h1>lookup()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Looks up data in a string array.
<dt>
<b>Syntax</b>
<dd>
<tt>string lookup(string array[], string key, int field_index[, char separator]);</tt><br>
<tt>string lookup(string array[], string key, string field_name[, char separator]);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>lookup</tt> returns the value of the field identified by <tt>field_index</tt>
or <tt>field_name</tt>.<br>
If the field doesn't exist, or no string matching <tt>key</tt> is found,
an empty string is returned.
</dl>
<b>See also</b> <a href=#297>fileread</a>,
<a href=#330>strsplit</a>
<p>
An <tt>array</tt> that can be used with <tt>lookup()</tt> consists of strings of text,
each string representing one data record.
<p>
Each data record contains an arbitrary number of fields, which are separated by
the character <tt>separator</tt> (default is <tt>'\t'</tt>, the tabulator).
The first field in a record is used as the <tt>key</tt> and is numbered <tt>0</tt>.
<p>
All records must have unique <tt>key</tt> fields and none of the <tt>key</tt> fields
may be empty - otherwise it is undefined which record will be found.
<p>
If the first string in the <tt>array</tt> contains a "Header" record (i.e. a record where
each field describes its contents), using <tt>lookup</tt> with a <tt>field_name</tt>
string automatically determines the index of that field. This allows using the
<tt>lookup</tt> function without exactly knowing which field index contains
the desired data.<br>
It is up to the user to make sure that the first record actually
contains header information.
<p>
If the <tt>key</tt> parameter in the call to <tt>lookup()</tt> is an empty
string, the first string of the <tt>array</tt> will be used. This allows a program to
determine whether there is a header record with the required field names.
<p>
If a field contains the <tt>separator</tt> character, that field must be enclosed
in double quotes (as in <tt>"abc;def"</tt>, assuming the semicolon (<tt>';'</tt>)
is used as separator). The same applies if the field contains double quotes
(<tt>"</tt>), in which case the double quotes inside the field have to be doubled
(as in <tt>"abc;""def"";ghi"</tt>, which would be <tt>abc;"def";ghi</tt>).<br>
<b>It is best to use the default "tab" separator, which doesn't have these problems
(no field can contain a tabulator).</b>
<p>
Here's an example data file (<tt>';'</tt> has been used as separator for better readability):
<pre>
Name;Manufacturer;Code;Price
7400;Intel;I-01-234-97;$0.10
68HC12;Motorola;M68HC1201234;$3.50
</pre>
<h2>Example</h2>
<pre>
string OrderCodes[];
if (fileread(OrderCodes, "ordercodes") &gt; 0) {
   if (lookup(OrderCodes, "", "Code", ';')) {
      schematic(SCH) {
        SCH.parts(P) {
          string OrderCode;
          // both following statements do exactly the same:
          OrderCode = lookup(OrderCodes, P.device.name, "Code", ';');
          OrderCode = lookup(OrderCodes, P.device.name, 2, ';');
          }
        }
      }
   else
      dlgMessageBox("Missing 'Code' field in file 'ordercodes');
   }
</pre>


<a name=310>
<h1>palette()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Returns color palette information.
<dt>
<b>Syntax</b>
<dd>
<tt>int palette(int index[, int type]);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>palette</tt> function returns an integer ARGB value in the form 0xaarrggbb,
or the type of the currently used palette (depending on the value of <tt>index</tt>).
</dl>
The <tt>palette</tt> function returns the ARGB value of the color with the given
<tt>index</tt> (which may be in the range 0..PALETTE_ENTRIES-1). If <tt>type</tt> is not
given (or is <tt>-1</tt>) the palette assigned to the current editor window will
be used. Otherwise <tt>type</tt> specifies which color palette to use (PALETTE_BLACK,
PALETTE_WHITE or PALETTE_COLORED).
<p>
The special value <tt>-1</tt> for <tt>index</tt> makes the function return the type
of the palette that is currently in use by the editor window.
<p>
If either <tt>index</tt> or <tt>type</tt> is out of range, an error message will be
given and the ULP will be terminated.
<h2>Constants</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>PALETTE_TYPES</tt>   </td><td width=20><td>the number of palette types (3)</td></tr>
<tr><td><tt>PALETTE_BLACK</tt>  </td><td width=20><td>the black background palette (0)</td></tr>
<tr><td><tt>PALETTE_WHITE</tt>  </td><td width=20><td>the white background palette (1)</td></tr>
<tr><td><tt>PALETTE_COLORED</tt>  </td><td width=20><td>the colored background palette (2)</td></tr>
<tr><td><tt>PALETTE_ENTRIES</tt>  </td><td width=20><td>the number of colors per palette (64)</td></tr>
</table>


<a name=311>
<h1>sleep()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Sleeps number of <tt>seconds</tt>.
<dt>
<b>Syntax</b>
<dd>
<tt>void sleep(int seconds);</tt><br>
</dl>
<b>See also</b> <a href=#341>time()</a>
<p>
The <tt>sleep</tt> function delays the execution of an ULP program for number
of <tt>seconds</tt>.
</dl>


<a name=312>
<h1>sort()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Sorts an array or a set of arrays.
<dt>
<b>Syntax</b>
<dd>
<tt>void sort(int number, array1[, array2,...]);</tt>
</dl>
The <tt>sort</tt> function either directly sorts a given <tt>array1</tt>,
or it sorts a set of arrays (starting with <tt>array2</tt>), in which case
<tt>array1</tt> is supposed to be an array of <b>int</b>, which will
be used as a pointer array.
<p>
In any case, the <tt>number</tt> argument defines the number of items in the
array(s).
<h2>Sorting a single array</h2>
If the <tt>sort</tt> function is called with one single array, that array
will be sorted directly, as in the following example:
<pre>
string A[];
int n = 0;
A[n++] = "World";
A[n++] = "Hello";
A[n++] = "The truth is out there...";
sort(n, A);
for (int i = 0; i &lt; n; ++i)
    printf(A[i]);
</pre>
<h2>Sorting a set of arrays</h2>
If the <tt>sort</tt> function is called with more than one array, the first
array must be an array of <b>int</b>, while all of the other arrays may be
of any array type and hold the data to be sorted. The following example
illustrates how the first array will be used as a pointer:
<pre>
numeric string Nets[], Parts[], Instances[], Pins[];
int n = 0;
int index[];
schematic(S) {
  S.nets(N) N.pinrefs(P) {
    Nets[n] = N.name;
    Parts[n] = P.part.name;
    Instances[n] = P.instance.name;
    Pins[n] = P.pin.name;
    ++n;
    }
  sort(n, index, Nets, Parts, Instances, Pins);
  for (int i = 0; i &lt; n; ++i)
      printf("%-8s %-8s %-8s %-8s\n",
             Nets[index[i]], Parts[index[i]],
             Instances[index[i]], Pins[index[i]]);
  }
</pre>
The idea behind this is that one net can have several pins connected to it,
and in a netlist you might want to have the net names sorted, and within
one net you also want the part names sorted and so on.
<p>
Note the use of the keyword <tt>numeric</tt> in the string arrays. This causes
the strings to be sorted in a way that takes into account a numeric part
at the end of the strings, which leads to IC1, IC2,... IC9, IC10 instead of
the alphabetical order IC1, IC10, IC2,...IC9.
<p>
When sorting a set of arrays, the first (index) array must be of type
<tt><a href=#201>int</a></tt> and need not be initialized. Any
contents the index array might have before calling the <tt>sort</tt>
function will be overwritten by the resulting index values.


<a name=313>
<h1>status()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Displays a status message in the status bar.
<dt>
<b>Syntax</b>
<dd>
<tt>void status(string message);</tt><br>
</dl>
<b>See also</b> <a href=#369>dlgMessageBox()</a>
<p>
The <tt>status</tt> function displays the given <tt>message</tt> in the status bar of the
editor window in which the ULP is running.
</dl>


<a name=314>
<h1>system()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Executes an external program.
<dt>
<b>Syntax</b>
<dd>
<tt>int system(string command);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>system</tt> function returns the exit status of the command. This is
typically <tt>0</tt> if everything was ok, and non-zero in case of an error.
</dl>
The <tt>system</tt> function executes the external program given by the <tt>command</tt>
string, and waits until the program ends.
<h2>Input/Output redirection</h2>
If the external program shall read its standard input from (or write its standard
output to) a particular file, input/output needs to be redirected.
<p>
<table><tr><td valign="top"><img src="platforms-lin.png"><br><img src="platforms-mac.png"></td><td valign="middle">
On <b>Linux</b> and <b>Mac OS X</b> this is done by simply adding a <tt>'&lt;'</tt> or
<tt>'&gt;'</tt> to the command line, followed by the desired file name, as in
<pre>
system("program &lt; infile &gt; outfile");
</pre>
which runs <tt>program</tt> and makes it read from <tt>infile</tt> and write
to <tt>outfile</tt>.
</td></tr></table>
<p>
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
On <b>Windows</b> you have to explicitly run a command processor to do this, as in
<pre>
system("cmd.exe /c program &lt; infile &gt; outfile");
</pre>
(on DOS based Windows systems use <tt>command.com</tt> instead of <tt>cmd.exe</tt>).
</td></tr></table>
<h2>Background execution</h2>
The <tt>system</tt> function waits until the given program has ended.
This is useful for programs that only run for a few seconds, or completely
take over the user's attention.
<p>
<table><tr><td valign="top"><img src="platforms-lin.png"><br><img src="platforms-mac.png"></td><td valign="middle">
If an external program runs for a longer time, and you want the system
call to return immediately, without waiting for the program to end, you
can simply add an <tt>'&amp;'</tt> to the command string under <b>Linux</b> and
<b>Mac OS X</b>, as in
<pre>
system("program &amp;");
</pre>
</td></tr></table>
<p>
<table><tr><td valign="top"><img src="platforms-win.png"></td><td valign="middle">
Under Windows you need to explicitly run a command processor to do this, as in
<pre>
system("cmd.exe /c start program");
</pre>
(on DOS based Windows systems use <tt>command.com</tt> instead of <tt>cmd.exe</tt>).
</td></tr></table>
<h2>Example</h2>
<pre>
int result = system("simulate -f filename");
</pre>
This would call a simulation program, giving it a file which the ULP has
just created.
Note that <tt>simulate</tt> here is just an example, it is not part of the EAGLE package!
<p>
If you want to have control over what system commands are actually executed,
you can write a wrapper function that prompts the user for confirmation before
executing the command, like
<pre>
int MySystem(string command)
{
  if (dlgMessageBox("!Ok to execute the following command?&lt;p&gt;&lt;tt&gt;" + command + "&lt;/tt&gt;", "&amp;Yes", "&amp;No") == 0)
     return system(command);
  return -1;
}
int result = MySystem("simulate -f filename");
</pre>


<a name=315>
<h1>Unit Conversions</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Converts internal units.
<dt>
<b>Syntax</b>
<dd>
<tt>real u2inch(int n);</tt><br>
<tt>real u2mic(int n);</tt><br>
<tt>real u2mil(int n);</tt><br>
<tt>real u2mm(int n);</tt><br>
<tt>int inch2u(real n);</tt><br>
<tt>int mic2u(real n);</tt><br>
<tt>int mil2u(real n);</tt><br>
<tt>int mm2u(real n);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>u2inch</tt> returns the value of <tt>n</tt> in <i>inch</i>.<br>
<tt>u2mic</tt>  returns the value of <tt>n</tt> in <i>microns</i> (1/1000mm).<br>
<tt>u2mil</tt>  returns the value of <tt>n</tt> in <i>mil</i> (1/1000inch).<br>
<tt>u2mm</tt>   returns the value of <tt>n</tt> in <i>millimeters</i>.<br>
<tt>inch2u</tt> returns the value of <tt>n</tt> (which is in <i>inch</i>) as internal units.<br>
<tt>mic2u</tt>  returns the value of <tt>n</tt> (which is in <i>microns</i>) as internal units.<br>
<tt>mil2u</tt>  returns the value of <tt>n</tt> (which is in <i>mil</i>) as internal units.<br>
<tt>mm2u</tt>   returns the value of <tt>n</tt> (which is in <i>millimeters</i>) as internal units.
</dl>
<b>See also</b> <a href=#223>UL_GRID</a>
<p>
EAGLE stores all coordinate and size values as <tt><a href=#201>int</a></tt>
values with a resolution of 1/320000mm (0.003125&micro;). The above unit conversion
functions can be used to convert these internal units to the desired
measurement units, and vice versa.
<h2>Example</h2>
<pre>
board(B) {
  B.elements(E) {
    printf("%s at (%f, %f)\n", E.name,
           u2mm(E.x), u2mm(E.y));
    }
  }
</pre>


<a name=316>
<h1>Network Functions</h1>
<i>Network functions</i> are used to access remote sites on the Internet.
<p>
The following network functions are available:
<ul>
<li><a href=#317>neterror()</a>
<li><a href=#318>netget()</a>
<li><a href=#319>netpost()</a>
</ul>


<a name=317>
<h1>neterror()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Returns the error message of the most recent network function call.
<dt>
<b>Syntax</b>
<dd>
<tt>string neterror(void);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>neterror</tt> returns a textual message describing the error that occurred
in the most recent call to a network function.<br>
If no error has occurred, the return value is an empty string.
</dl>
<b>See also</b> <a href=#318>netget</a>,
<a href=#319>netpost</a>
<p>
The <tt>neterror</tt> function should be called after any of the other
network functions has returned a negative value, indicating that an
error has occurred. The return value of <tt>neterror</tt> is a textual
string that can be presented to the user.
<p>
For errors related to SSL connections (HTTPS) also consider the note in
<a href=#318>netget</a>.
<h2>Example</h2>
<pre>
string Result;
if (netget(Result, "http://web.cadsoft.de/cgi-bin/http-test?see=me&amp;hear=them") &gt;= 0) {
   // process Result
   }
else
   dlgMessageBox(neterror());
</pre>


<a name=318>
<h1>netget()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Performs a GET request on the network.
<dt>
<b>Syntax</b>
<dd>
<tt>int netget(<i>dest</i>, string url[, int timeout]);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>netget</tt> returns the number of objects read from the network.<br>
The actual meaning of the return value depends on the type of <tt>dest</tt>.<br>
In case of an error, a negative value is returned and
<a href=#317>neterror()</a>
may be called to display an error message to the user.
</dl>
<b>See also</b> <a href=#319>netpost</a>,
<a href=#317>neterror</a>,
<a href=#297>fileread</a>
<p>
The <tt>netget</tt> function sends the given <tt>url</tt> to the network and
stores the result in the <tt>dest</tt> variable.<br>
If no network activity has occurred for <tt>timeout</tt> seconds,
the connection will be terminated.  The default timeout is 20 seconds.<br>
The <tt>url</tt> must contain the protocol to use (HTTP, HTTPS or FTP) and can
contain name=value pairs of parameters, as in
<pre>
http://web.cadsoft.de/cgi-bin/http-test?see=me&amp;hear=them
ftp://ftp.cadsoft.de/eagle/userfiles/README
</pre>
If a user id and password is required to access a remote site, these can be
given as
<pre>
https://userid:password@www.secret-site.com/...
</pre>
If <tt>dest</tt> is a character array, the result will be treated as raw binary data
and the return value reflects the number of bytes stored in the character array.
<p>
If <tt>dest</tt> is a string array, the result will be treated as text data (one line
per array member) and the return value will be the number of lines stored in the
string array. Newline characters will be stripped.
<p>
If <tt>dest</tt> is a string, the result will be stored in that string
and the return value will be the length of the string. Note that in case
of binary data the result is truncated at the first occurrence of a byte with
the value 0x00.
<p>
If you need to use a proxy to access the Internet with HTTP or HTTPS, you can set
that up in the "Configure" dialog under "Help/Check for Update" in the Control Panel.
<h2>SSL Connections</h2>
For SSL connections (request per HTTPS) certificates are necessary, which may miss
or be expired on some systems. The connection fails then with according error message
that you can query with <tt>neterror()</tt>.<br>
With this error message it should be possible to install missing or update expired
certificates and make the connection work this way. It depends on your system how to
do this (in Windows e.g. via Control Panel/Internet Options etc.).
<h2>Example</h2>
<pre>
string Result;
if (netget(Result, "http://web.cadsoft.de/cgi-bin/http-test?see=me&amp;hear=them") &gt;= 0) {
   // process Result
   }
else
   dlgMessageBox(neterror());
</pre>


<a name=319>
<h1>netpost()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Performs a POST request on the network.
<dt>
<b>Syntax</b>
<dd>
<tt>int netpost(<i>dest</i>, string url, string data[, int timeout[, string content_type] ]);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>netpost</tt> returns the number of objects read from the network.<br>
The actual meaning of the return value depends on the type of <tt>dest</tt>.<br>
In case of an error, a negative value is returned and
<a href=#317>neterror()</a>
may be called to display an error message to the user.
</dl>
<b>See also</b> <a href=#318>netget</a>,
<a href=#317>neterror</a>,
<a href=#297>fileread</a>
<p>
The <tt>netpost</tt> function sends the given <tt>data</tt> to the given <tt>url</tt>
on the network and stores the result in the <tt>dest</tt> variable.<br>
If no network activity has occurred for <tt>timeout</tt> seconds,
the connection will be terminated.  The default timeout is 20 seconds.<br>
If <tt>content_type</tt> is given, it overwrites the default content type
of <tt>"text/html; charset=utf-8"</tt>.<br>
The <tt>url</tt> must contain the protocol to use (HTTP or HTTPS).
<p>
If a user id and password is required to access a remote site, these can be
given as
<pre>
https://userid:password@www.secret-site.com/...
</pre>
If <tt>dest</tt> is a character array, the result will be treated as raw binary data
and the return value reflects the number of bytes stored in the character array.
<p>
If <tt>dest</tt> is a string array, the result will be treated as text data (one line
per array member) and the return value will be the number of lines stored in the
string array. Newline characters will be stripped.
<p>
If <tt>dest</tt> is a string, the result will be stored in that string
and the return value will be the length of the string. Note that in case
of binary data the result is truncated at the first occurrence of a byte with
the value 0x00.
<p>
If you need to use a proxy to access the Internet with HTTP or HTTPS, you can set
that up in the "Configure" dialog under "Help/Check for Update" in the Control Panel.
<p>
If you should face problems related to SSL connections (HTTPS) consider the note in
<a href=#318>netget</a>.
<h2>Example</h2>
<pre>
string Data = "see=me\nhear=them";
string Result;
if (netpost(Result, "http://web.cadsoft.de/cgi-bin/http-test", Data) &gt;= 0) {
   // process Result
   }
else
   dlgMessageBox(neterror());
</pre>


<a name=320>
<h1>Printing Functions</h1>
<i>Printing functions</i> are used to print formatted strings.
<p>
The following printing functions are available:
<ul>
<li><a href=#321>printf()</a>
<li><a href=#322>sprintf()</a>
</ul>


<a name=321>
<h1>printf()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Writes formatted output to a file.
<dt>
<b>Syntax</b>
<dd>
<tt>int printf(string format[, argument, ...]);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>printf</tt> function returns the number of characters written
to the file that has been opened by the most recent <a href=#360>output</a>
statement.
<p>
In case of an error, <tt>printf</tt> returns <tt>-1</tt>.
</dl>
<b>See also</b> <a href=#322>sprintf</a>,
<a href=#360>output</a>,
<a href=#292>fileerror</a>
<h2>Format string</h2>
The format string controls how the arguments will be converted,
formatted and printed. There must be exactly as many arguments
as necessary for the format. The number and type of arguments
will be checked against the format, and any mismatch will lead
to an error message.
<p>
The format string contains two types of objects - <i>plain characters</i>
and <i>format specifiers</i>:
<ul>
<li>Plain characters are simply copied verbatim to the output
<li>Format specifiers fetch arguments from the argument list
and apply formatting to them
</ul>
<h2>Format specifiers</h2>
A format specifier has the following form:
<p>
<tt>% [flags] [width] [.prec] type</tt>
<p>
Each format specification begins with the percent character (<tt>%</tt>).
After the <tt>%</tt> comes the following, in this order:
<ul>
<li>an optional sequence of flag characters, <tt>[flags]</tt>
<li>an optional width specifier, <tt>[width]</tt>
<li>an optional precision specifier, <tt>[.prec]</tt>
<li>the conversion type character, <tt>type</tt>
</ul>
<h2>Conversion type characters</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>d</tt>   </td><td width=20><td><b>signed</b> decimal <b>int</b></td></tr>
<tr><td><tt>o</tt>   </td><td width=20><td><b>unsigned</b> octal <b>int</b></td></tr>
<tr><td><tt>u</tt>   </td><td width=20><td><b>unsigned</b> decimal <b>int</b></td></tr>
<tr><td><tt>x</tt>   </td><td width=20><td><b>unsigned</b> hexadecimal <b>int</b> (with <b>a</b>, <b>b</b>,...)</td></tr>
<tr><td><tt>X</tt>   </td><td width=20><td><b>unsigned</b> hexadecimal <b>int</b> (with <b>A</b>, <b>B</b>,...)</td></tr>
<tr><td><tt>f</tt>   </td><td width=20><td><b>signed real</b> value of the form <tt>[-]dddd.dddd</tt></td></tr>
<tr><td><tt>e</tt>   </td><td width=20><td><b>signed real</b> value of the form <tt>[-]d.dddd</tt>e<tt>[&plusmn;]ddd</tt></td></tr>
<tr><td><tt>E</tt>   </td><td width=20><td>same as <tt>e</tt>, but with <b>E</b> for exponent</td></tr>
<tr><td><tt>g</tt>   </td><td width=20><td><b>signed real</b> value in either <tt>e</tt> or <tt>f</tt> form, based on given value and precision</td></tr>
<tr><td><tt>G</tt>   </td><td width=20><td>same as <tt>g</tt>, but with <b>E</b> for exponent if <tt>e</tt> format used</td></tr>
<tr><td><tt>c</tt>   </td><td width=20><td>single character</td></tr>
<tr><td><tt>s</tt>   </td><td width=20><td>character string</td></tr>
<tr><td><tt>%</tt>   </td><td width=20><td>the <tt>%</tt> character is printed</td></tr>
</table>
<h2>Flag characters</h2>
The following flag characters can appear in any order and combination.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>"-"</tt>   </td><td width=20><td>the formatted item is left-justified within the field; normally, items are right-justified</td></tr>
<tr><td><tt>"+"</tt>   </td><td width=20><td>a signed, positive item will always start with a plus character (<tt>+</tt>); normally, only negative items begin with a sign</td></tr>
<tr><td><tt>" "</tt>   </td><td width=20><td>a signed, positive item will always start with a space character; if both <tt>"+"</tt> and <tt>" "</tt> are specified,  <tt>"+"</tt> overrides <tt>" "</tt></td></tr>
</table>
<h2>Width specifiers</h2>
The width specifier sets the minimum field width for an output value.
<p>
Width is specified either directly, through a decimal digit string, or
indirectly, through an asterisk (<tt>*</tt>). If you use an asterisk for the
width specifier, the preceding argument (which must be an <tt>int</tt>) to the one being
formatted (with this format specifier) determines the minimum output field width.
<p>
In no case does a nonexistent or small field width cause truncation of
a field. If the result of a conversion is wider than the field width,
the field is simply expanded to contain the conversion result.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt><i>n</i></tt>   </td><td width=20><td>At least <i>n</i> characters are printed. If the output value has less than <i>n</i> characters, the output is padded with blanks (right-padded if <tt>"-"</tt> flag given, left-padded otherwise).</td></tr>
<tr><td><tt>0<i>n</i></tt>   </td><td width=20><td>At least <i>n</i> characters are printed. If the output value has less than <i>n</i> characters, it is filled on the left with zeros.</td></tr>
<tr><td><tt>*</tt>   </td><td width=20><td>The argument list supplies the width specifier, which must precede the actual argument being formatted.</td></tr>
</table>
<h2>Precision specifiers</h2>
A precision specifier always begins with a period (<tt>.</tt>) to
separate it from any preceding width specifier. Then, like width,
precision is specified either directly through a decimal digit string, or
indirectly, through an asterisk (<tt>*</tt>). If you use an asterisk for the
precision specifier, the preceding argument (which must be an <tt>int</tt>) to the one being
formatted (with this format specifier) determines the precision.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>none   </td><td width=20><td>Precision set to default.</td></tr>
<tr><td><tt>.0</tt>   </td><td width=20><td>For <tt>int</tt> types, precision is set to default; for <tt>real</tt> types, no decimal point is printed.</td></tr>
<tr><td><tt>.<i>n</i></tt>   </td><td width=20><td><i>n</i> characters or <i>n</i> decimal places are printed. If the output value has more than <i>n</i> characters the output might be truncated or rounded (depending on the type character).</td></tr>
<tr><td><tt>*</tt>   </td><td width=20><td>The argument list supplies the precision specifier, which must precede the actual argument being formatted.</td></tr>
</table>
<h2>Default precision values</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>douxX</tt>   </td><td width=20><td>1</td></tr>
<tr><td><tt>eEf</tt>   </td><td width=20><td>6</td></tr>
<tr><td><tt>gG</tt>   </td><td width=20><td>all significant digits</td></tr>
<tr><td><tt>c</tt>   </td><td width=20><td>no effect</td></tr>
<tr><td><tt>s</tt>   </td><td width=20><td>print entire string</td></tr>
</table>
<h2>How precision specification (<tt>.n</tt>) affects conversion</h2>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>douxX</tt>   </td><td width=20><td><i>.n</i> specifies that at least <i>n</i> characters are printed. If the input argument has less than <i>n</i> digits, the output value is left-padded with zeros. If the input argument has more than <i>n</i> digits, the output value is <b>not</b> truncated.</td></tr>
<tr><td><tt>eEf</tt>   </td><td width=20><td><i>.n</i> specifies that <i>n</i> characters are printed after the decimal point, and the last digit printed is rounded.</td></tr>
<tr><td><tt>gG</tt>   </td><td width=20><td><i>.n</i> specifies that at most <i>n</i> significant digits are printed.</td></tr>
<tr><td><tt>c</tt>   </td><td width=20><td><i>.n</i> has no effect on the output.</td></tr>
<tr><td><tt>s</tt>   </td><td width=20><td><i>.n</i> specifies that no more than <i>n</i> characters are printed.</td></tr>
</table>
<h2>Binary zero characters</h2>
Unlike <a href=#322>sprintf</a>, the <tt>printf</tt> function can print binary zero characters (0x00).
<pre>
char c = 0x00;
printf("%c", c);
</pre>
<h2>Example</h2>
<pre>
int i = 42;
real r = 3.14;
char c = 'A';
string s = "Hello";
printf("Integer: %8d\n", i);
printf("Hex:     %8X\n", i);
printf("Real:    %8f\n", r);
printf("Char:    %-8c\n", c);
printf("String:  %-8s\n", s);
</pre>


<a name=322>
<h1>sprintf()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Writes formatted output into a string.
<dt>
<b>Syntax</b>
<dd>
<tt>int sprintf(string result, string format[, argument, ...]);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>sprintf</tt> function returns the number of characters written
into the <tt>result</tt> string.
<p>
In case of an error, <tt>sprintf</tt> returns <tt>-1</tt>.
</dl>
<b>See also</b> <a href=#321>printf</a>
<h2>Format string</h2>
See <a href=#321>printf</a>.
<h2>Binary zero characters</h2>
Note that <tt>sprintf</tt> can not return strings with embedded binary zero
characters (0x00). If the resulting string contains a binary zero character,
any characters following that zero character will be dropped.
Use <a href=#321>printf</a> if you need to output binary data.
<h2>Example</h2>
<pre>
string result;
int number = 42;
sprintf(result, "The number is %d", number);
</pre>


<a name=323>
<h1>String Functions</h1>
<i>String functions</i> are used to manipulate character strings.
<p>
The following string functions are available:
<ul>
<li><a href=#324>strchr()</a>
<li><a href=#325>strjoin()</a>
<li><a href=#326>strlen()</a>
<li><a href=#327>strlwr()</a>
<li><a href=#328>strrchr()</a>
<li><a href=#329>strrstr()</a>
<li><a href=#330>strsplit()</a>
<li><a href=#331>strstr()</a>
<li><a href=#332>strsub()</a>
<li><a href=#333>strtod()</a>
<li><a href=#334>strtol()</a>
<li><a href=#335>strupr()</a>
<li><a href=#336>strxstr()</a>
</ul>


<a name=324>
<h1>strchr()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Scans a string for the first occurrence of a given character.
<dt>
<b>Syntax</b>
<dd>
<tt>int strchr(string s, char c[, int index]);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strchr</tt> function returns the integer offset of the
character in the string, or <tt>-1</tt> if the character does not
occur in the string.
</dl>
<b>See also</b> <a href=#328>strrchr</a>,
<a href=#331>strstr</a>
<p>
If <tt>index</tt> is given, the search starts at that position.
Negative values are counted from the end of the string.
<h2>Example</h2>
<pre>
string s = "This is a string";
char c = 'a';
int pos = strchr(s, c);
if (pos &gt;= 0)
   printf("The character %c is at position %d\n", c, pos);
else
   printf("The character was not found\n");
</pre>


<a name=325>
<h1>strjoin()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Joins a string array to form a single string.
<dt>
<b>Syntax</b>
<dd>
<tt>string strjoin(string array[], char separator);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strjoin</tt> function returns the combined entries of <tt>array</tt>.
</dl>
<b>See also</b> <a href=#330>strsplit</a>,
<a href=#309>lookup</a>,
<a href=#297>fileread</a>
<p>
<tt>strjoin</tt> joins all entries in <tt>array</tt>, delimited by the given
<tt>separator</tt> and returns the resulting string.
<p>
If <tt>separator</tt> is the newline character (<tt>'\n'</tt>) the resulting
string will be terminated with a newline character.
This is done to have a text file that
consists of N lines (each of which is terminated with a newline) and is read
in with the <a href=#297>fileread()</a> function and
<a href=#330>split</a> into
an array of N strings to be joined to the original string as read from the file.
<h2>Example</h2>
<pre>
string a[] = { "Field 1", "Field 2", "Field 3" };
string s = strjoin(a, ':');
</pre>


<a name=326>
<h1>strlen()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Calculates the length of a string.
<dt>
<b>Syntax</b>
<dd>
<tt>int strlen(string s);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strlen</tt> function returns the number of characters in
the string.
</dl>
<h2>Example</h2>
<pre>
string s = "This is a string";
int l = strlen(s);
printf("The string is %d characters long\n", l);
</pre>


<a name=327>
<h1>strlwr()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Converts uppercase letters in a string to lowercase.
<dt>
<b>Syntax</b>
<dd>
<tt>string strlwr(string s);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strlwr</tt> function returns the modified string.
The original string (given as parameter) is not changed.
</dl>
<b>See also</b> <a href=#335>strupr</a>,
<a href=#290>tolower</a>
<h2>Example</h2>
<pre>
string s = "This Is A String";
string r = strlwr(s);
printf("Prior to strlwr: %s - after strlwr: %s\n", s, r);
</pre>


<a name=328>
<h1>strrchr()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Scans a string for the last occurrence of a given character.
<dt>
<b>Syntax</b>
<dd>
<tt>int strrchr(string s, char c[, int index]);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strrchr</tt> function returns the integer offset of the
character in the string, or <tt>-1</tt> if the character does not
occur in the string.
</dl>
<b>See also</b> <a href=#324>strchr</a>,
<a href=#329>strrstr</a>
<p>
If <tt>index</tt> is given, the search starts at that position.
Negative values are counted from the end of the string.
<h2>Example</h2>
<pre>
string s = "This is a string";
char c = 'a';
int pos = strrchr(s, c);
if (pos &gt;= 0)
   printf("The character %c is at position %d\n", c, pos);
else
   printf("The character was not found\n");
</pre>


<a name=329>
<h1>strrstr()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Scans a string for the last occurrence of a given substring.
<dt>
<b>Syntax</b>
<dd>
<tt>int strrstr(string s1, string s2[, int index]);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strrstr</tt> function returns the integer offset of the
first character of s2 in s1, or <tt>-1</tt> if the substring does not
occur in the string.
</dl>
<b>See also</b> <a href=#331>strstr</a>,
<a href=#328>strrchr</a>
<p>
If <tt>index</tt> is given, the search starts at that position.
Negative values are counted from the end of the string.
<h2>Example</h2>
<pre>
string s1 = "This is a string", s2 = "is a";
int pos = strrstr(s1, s2);
if (pos &gt;= 0)
   printf("The substring starts at %d\n", pos);
else
   printf("The substring was not found\n");
</pre>


<a name=330>
<h1>strsplit()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Splits a string into separate fields.
<dt>
<b>Syntax</b>
<dd>
<tt>int strsplit(string &amp;array[], string s, char separator);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strsplit</tt> function returns the number of entries copied into <tt>array</tt>.
</dl>
<b>See also</b> <a href=#325>strjoin</a>,
<a href=#309>lookup</a>,
<a href=#297>fileread</a>
<p>
<tt>strsplit</tt> splits the string <tt>s</tt> at the given <tt>separator</tt>
and stores the resulting fields in the <tt>array</tt>.
<p>
If <tt>separator</tt> is the newline character (<tt>'\n'</tt>) the last field
will be silently dropped if it is empty. This is done to have a text file that
consists of N lines (each of which is terminated with a newline) and is read
in with the <a href=#297>fileread()</a> function to be split into
an array of N strings. With any other <tt>separator</tt> an empty field at the
end of the string will count, so <tt>"a:b:c:"</tt> will result in 4 fields,
the last of which is empty.
<h2>Example</h2>
<pre>
string a[];
int n = strsplit(a, "Field 1:Field 2:Field 3", ':');
</pre>


<a name=331>
<h1>strstr()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Scans a string for the first occurrence of a given substring.
<dt>
<b>Syntax</b>
<dd>
<tt>int strstr(string s1, string s2[, int index]);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strstr</tt> function returns the integer offset of the
first character of s2 in s1, or <tt>-1</tt> if the substring does not
occur in the string.
</dl>
<b>See also</b> <a href=#329>strrstr</a>,
<a href=#324>strchr</a>,
<a href=#336>strxstr</a>
<p>
If <tt>index</tt> is given, the search starts at that position.
Negative values are counted from the end of the string.
<h2>Example</h2>
<pre>
string s1 = "This is a string", s2 = "is a";
int pos = strstr(s1, s2);
if (pos &gt;= 0)
   printf("The substring starts at %d\n", pos);
else
   printf("The substring was not found\n");
</pre>


<a name=332>
<h1>strsub()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Extracts a substring from a string.
<dt>
<b>Syntax</b>
<dd>
<tt>string strsub(string s, int start[, int length]);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strsub</tt> function returns the substring indicated by
the <tt>start</tt> and <tt>length</tt> value.
<p>
The value for <tt>length</tt> must be positive, otherwise an empty string
will be returned. If <tt>length</tt> is ommitted, the rest of the string
(beginning at <tt>start</tt>) is returned.
<p>
If <tt>start</tt> points to a position outside the string, an empty string
is returned.
</dl>
<h2>Example</h2>
<pre>
string s = "This is a string";
string t = strsub(s, 4, 7);
printf("The extracted substring is: %s\n", t);
</pre>


<a name=333>
<h1>strtod()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Converts a string to a real value.
<dt>
<b>Syntax</b>
<dd>
<tt>real strtod(string s);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strtod</tt> function returns the numerical representation
of the given string as a <tt>real</tt> value. Conversion ends at the
first character that does not fit into the format of a
<a href=#188>real constant</a>.
If an error occurs during conversion of the string <tt>0.0</tt>
will be returned.
</dl>
<b>See also</b> <a href=#334>strtol</a>
<h2>Example</h2>
<pre>
string s = "3.1415";
real r = strtod(s);
printf("The value is %f\n", r);
</pre>


<a name=334>
<h1>strtol()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Converts a string to an integer value.
<dt>
<b>Syntax</b>
<dd>
<tt>int strtol(string s);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strtol</tt> function returns the numerical representation
of the given string as an <tt>int</tt> value. Conversion ends at the
first character that does not fit into the format of an
<a href=#187>integer constant</a>.
If an error occurs during conversion of the string <tt>0</tt>
will be returned.
</dl>
<b>See also</b> <a href=#333>strtod</a>
<h2>Example</h2>
<pre>
string s = "1234";
int i = strtol(s);
printf("The value is %d\n", i);
</pre>


<a name=335>
<h1>strupr()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Converts lowercase letters in a string to uppercase.
<dt>
<b>Syntax</b>
<dd>
<tt>string strupr(string s);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strupr</tt> function returns the modified string.
The original string (given as parameter) is not changed.
</dl>
<b>See also</b> <a href=#327>strlwr</a>,
<a href=#290>toupper</a>
<h2>Example</h2>
<pre>
string s = "This Is A String";
string r = strupr(s);
printf("Prior to strupr: %s - after strupr: %s\n", s, r);
</pre>


<a name=336>
<h1>strxstr()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Scans a string for the first occurrence of a given regular expression.
<dt>
<b>Syntax</b>
<dd>
<tt>int strxstr(string s1, string s2[, int index[, int &amp;length]]);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>strxstr</tt> function returns the integer offset of the substring
in s1 that matches the regular expression in s2, or <tt>-1</tt> if
the regular expression does not match in the string.
</dl>
<b>See also</b> <a href=#331>strstr</a>,
<a href=#324>strchr</a>,
<a href=#329>strrstr</a>
<p>
If <tt>index</tt> is given, the search starts at that position.
Negative values are counted from the end of the string.
<p>
If <tt>length</tt> is given, the actual length of the matching substring
is returned in that variable.
<p>
<i>Regular expressions</i> allow you to find a pattern within a text string.
For instance, the regular expression "i.*a" would find a sequence of characters
that starts with an 'i', followed by any character ('.') any number of times ('*'),
and ends with an 'a'. It would match on "is a" as well as "is this a" or "ia".<br>
Details on regular expressions can be found, for instance, in the book
<i>Mastering Regular Expressions</i> by Jeffrey E. F. Friedl.
<h2>Example</h2>
<pre>
string s1 = "This is a string", s2 = "i.*a";
int len = 0;
int pos = strxstr(s1, s2, 0, len);
if (pos &gt;= 0)
   printf("The substring starts at %d and is %d charcaters long\n", pos, len);
else
   printf("The substring was not found\n");
</pre>


<a name=337>
<h1>URN Functions</h1>
<i>URN functions</i> are used to process URNs.
<p>
The following URN functions are available:
<ul>
<li><a href=#338>urnbase()</a>
<li><a href=#339>urnversion()</a>
</ul>


<a name=338>
<h1>urnbase()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Extracts the base URN from a URN string.
<dt>
<b>Syntax</b>
<dd>
<tt>string urnbase(string urn);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>urnbase</tt> function returns the base URN of the provided URN, i.e. the URN
without trailing version or <tt>/</tt> - e.g. the base URN of "urn:adsk.eagle:footprint:123/4"
is "urn:adsk.eagle:footprint:123". If no version is present, the input string will be returned.
</dl>
<h2>Example</h2>
<pre>
string urn = "urn:adsk.eagle:footprint:123/4";
string base = urnbase(urn);
printf("The base URN is: %s\n", base);
</pre>


<a name=339>
<h1>urnversion()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Extracts the version from a URN string.
<dt>
<b>Syntax</b>
<dd>
<tt>int urnversion(string urn);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>urnversion</tt> function returns the version of the provided URN, i.e. the number
following the <tt>/</tt>. If no version is present, -1 is returned.
</dl>
<h2>Example</h2>
<pre>
string urn = "urn:adsk.eagle:footprint:123/4";
int version = urnversion(urn);
printf("The URN version is: %d\n", version);
</pre>


<a name=340>
<h1>Time Functions</h1>
<i>Time functions</i> are used to get and process time and date
information.
<p>
The following time functions are available:
<ul>
<li><a href=#311>sleep()</a>
<li><a href=#343>t2day()</a>
<li><a href=#343>t2dayofweek()</a>
<li><a href=#343>t2hour()</a>
<li><a href=#343>t2minute()</a>
<li><a href=#343>t2month()</a>
<li><a href=#343>t2second()</a>
<li><a href=#343>t2string()</a>
<li><a href=#343>t2year()</a>
<li><a href=#341>time()</a>
<li><a href=#342>timems()</a>
</ul>


<a name=341>
<h1>time()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Gets the current system time.
<dt>
<b>Syntax</b>
<dd>
<tt>int time(void);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>time</tt> function returns the current system time as the number
of seconds elapsed since a system dependent reference date.
</dl>
<b>See also</b> <a href=#343>Time Conversions</a>,
<a href=#295>filetime</a>,
<a href=#342>timems()</a>
<h2>Example</h2>
<pre>
int CurrentTime = time();
</pre>


<a name=342>
<h1>timems()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Gets the number of milliseconds since the start of the ULP.
<dt>
<b>Syntax</b>
<dd>
<tt>int timems(void);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>timems</tt> function returns the number of milliseconds since the
start of the ULP.
<p>
After 86400000 milliseconds (i.e. every 24 hours), the value starts at 0 again.
</dl>
<b>See also</b> <a href=#341>time</a>
<h2>Example</h2>
<pre>
int elapsed = timems();
</pre>


<a name=343>
<h1>Time Conversions</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Convert a time value to day, month, year etc.
<dt>
<b>Syntax</b>
<dd>
<tt>int t2day(int t);</tt><br>
<tt>int t2dayofweek(int t);</tt><br>
<tt>int t2hour(int t);</tt><br>
<tt>int t2minute(int t);</tt><br>
<tt>int t2month(int t);</tt><br>
<tt>int t2second(int t);</tt><br>
<tt>int t2year(int t);</tt><br>
<br>
<tt>string t2string(int t[, string format]);</tt>
<dt>
<b>Returns</b>
<dd>
<tt>t2day      </tt> returns the day of the month (<tt>1</tt>..<tt>31</tt>)<br>
<tt>t2dayofweek</tt> returns the day of the week (<tt>0</tt>=sunday..<tt>6</tt>)<br>
<tt>t2hour     </tt> returns the hour (<tt>0</tt>..<tt>23</tt>)<br>
<tt>t2minute   </tt> returns the minute (<tt>0</tt>..<tt>59</tt>)<br>
<tt>t2month    </tt> returns the month (<tt>0</tt>..<tt>11</tt>)<br>
<tt>t2second   </tt> returns the second (<tt>0</tt>..<tt>59</tt>)<br>
<tt>t2year     </tt> returns the year (including century!)<br>
<tt>t2string   </tt> returns a formatted string containing date and time
</dl>
<b>See also</b> <a href=#341>time</a>
<p>
The <tt>t2string</tt> function without the optional <tt>format</tt> parameter
converts the given time <tt>t</tt> into a country specific string in local time.
<p>
If <tt>t2string</tt> is called with a <tt>format</tt> string, that format is
used to determine what the result should look like.
<p>
The following expressions can be used in a <tt>format</tt> string:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td>d</td><td width=20><td>the day as a number without a leading zero (1 to 31)</td></tr>
<tr><td>dd</td><td width=20><td>the day as a number with a leading zero (01 to 31)</td></tr>
<tr><td>ddd</td><td width=20><td>the abbreviated localized day name (e.g. "Mon" to "Sun")</td></tr>
<tr><td>dddd</td><td width=20><td>the long localized day name (e.g. "Monday" to "Sunday")</td></tr>
<tr><td>M</td><td width=20><td>the month as a number without a leading zero (1-12)</td></tr>
<tr><td>MM</td><td width=20><td>the month as a number with a leading zero (01-12)</td></tr>
<tr><td>MMM</td><td width=20><td>the abbreviated localized month name (e.g. "Jan" to "Dec")</tr>
<tr><td>MMMM</td><td width=20><td>the long localized month name (e.g. "January" to "December")</td></tr>
<tr><td>yy</td><td width=20><td>the year as a two digit number (00-99)</td></tr>
<tr><td>yyyy</td><td width=20><td>the year as a four digit number</td></tr>
<tr><td>h</td><td width=20><td>the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)</td></tr>
<tr><td>hh</td><td width=20><td>the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)</td></tr>
<tr><td>m</td><td width=20><td>the minute without a leading zero (0 to 59)</td></tr>
<tr><td>mm</td><td width=20><td>the minute with a leading zero (00 to 59)</td></tr>
<tr><td>s</td><td width=20><td>the second without a leading zero (0 to 59)</td></tr>
<tr><td>ss</td><td width=20><td>the second with a leading zero (00 to 59)</td></tr>
<tr><td>z</td><td width=20><td>the milliseconds without leading zeros (always 0, since the given time only has a one second resolution)</td></tr>
<tr><td>zzz</td><td width=20><td>the milliseconds with leading zeros (always 000, since the given time only has a one second resolution)</td></tr>
<tr><td>AP</td><td width=20><td>use AM/PM display (<i>AP</i> will be replaced by either "AM" or "PM")</td></tr>
<tr><td>ap</td><td width=20><td>use am/pm display (<i>ap</i> will be replaced by either "am" or "pm")</td></tr>
<tr><td>U</td><td width=20><td>display the given time as UTC (must be the first character; default is local time)</td></tr>
</table>
<p>
All other characters will be copied "as is".
Any sequence of characters that are enclosed in singlequotes will be treated as
text and not be used as an expression. Two consecutive single quotes ('') are
replaced by a single quote in the output.
<h2>Example</h2>
<pre>
int t = time();
printf("It is now %02d:%02d:%02d\n",
       t2hour(t), t2minute(t), t2second(t));
printf("ISO time is %s\n", t2string(t, "Uyyyy-MM-dd hh:mm:ss"));
</pre>


<a name=344>
<h1>Object Functions</h1>
<i>Object functions</i> are used to access common information about objects.
<p>
The following object functions are available:
<ul>
<li><a href=#345>clrgroup()</a>
<li><a href=#346>ingroup()</a>
<li><a href=#347>setgroup()</a>
<li><a href=#348>setvariant()</a>
<li><a href=#349>variant()</a>
</ul>


<a name=345>
<h1>clrgroup()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Clears the group flags of an object.
<dt>
<b>Syntax</b>
<dd>
<tt>void clrgroup(object);</tt>
<dt>
</dl>
<b>See also</b> <a href=#346>ingroup()</a>,
<a href=#347>setgroup()</a>,
<a href=#62>GROUP command</a>
<p>
The <tt>clrgroup()</tt> function clears the group flags of the given object,
so that it is no longer part of the previously defined group.
<p>
When applied to an object that contains other objects (like a UL_BOARD or
UL_NET) the group flags of all contained objects are cleared recursively,
but with analogous limitations like for <a href=#347>setgroup()</a>.
<h2>Example</h2>
<pre>
board(B) {
  B.elements(E)
    clrgroup(E);
  }
</pre>


<a name=346>
<h1>ingroup()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Checks whether an object is in the group.
<dt>
<b>Syntax</b>
<dd>
<tt>int ingroup(object);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>ingroup</tt> function returns a non-zero value if the given object is
in the group.
</dl>
<b>See also</b> <a href=#345>clrgroup()</a>,
<a href=#347>setgroup()</a>,
<a href=#62>GROUP command</a>
<p>
If a group has been defined in the editor, the <tt>ingroup()</tt> function can
be used to check whether a particular object is part of the group.
<p>
Objects with a single coordinate that are individually selectable in the current
drawing (like UL_TEXT, UL_VIA, UL_CIRCLE etc.) return a non-zero value
in a call to <tt>ingroup()</tt> if that coordinate is within the defined group.
<p>
A UL_WIRE returns 0, 1, 2 or 3, depending on whether none, the first, the second
or both of its end points are in the group.
<p>
A UL_RECTANGLE and UL_FRAME returns a non-zero value if one or more of its corners are in the group.
The value has bit 0 set for the upper right corner, bit 1 for the upper left, bit 2
for the bottom left, and bit 3 for the bottom right corner.
<p>
Higher ranking objects that have no coordinates (UL_NET, UL_SEGMENT, UL_SIGNAL, UL_POLYGON)
or that are actually not available as drawing objects (UL_SHEET, UL_DEVICESET, UL_SYMBOL, UL_FOOTPRINT),
return a non-zero value if one or more of the objects within them are in the group.
For details on the object hierarchies see <a href=#206>Object Types</a>.
<br>
UL_CONTACTREF and UL_PINREF, though not having coordinates of their own, return
a non-zero value if the referenced UL_CONTACT or UL_PIN, respectively, is within
the group. <br>
For other not selectable objects like UL_GRID, UL_VARIANT or wires of a UL_TEXT or
UL_FRAME object, the behaviour of <tt>ingroup()</tt> is undefined and therefore should not be used.
<p>
<h2>Identifying the context menu object </h2>
If the ULP is started from a context menu the selected object can be accessed
by the group mechansim. A one element group is made from the selected object.
So it can be identified with <tt>ingroup().</tt>
(see also <a href=#116>SET</a> and <a href=#114>RUN</a>).
<h2>Example</h2>
<pre>
output("group.txt") {
  board(B) {
    B.elements(E) {
      if (ingroup(E))
         printf("Element %s is in the group\n", E.name);
      }
    }
  }
</pre>


<a name=347>
<h1>setgroup()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Sets the group flags of an object.
<dt>
<b>Syntax</b>
<dd>
<tt>void setgroup(object[, int flags]);</tt>
</dl>
<b>See also</b> <a href=#345>clrgroup()</a>,
<a href=#346>ingroup()</a>,
<a href=#62>GROUP command</a>
<p>
The <tt>setgroup()</tt> function sets the group flags of the given object,
so that it becomes part of the group.
<p>
If no <tt>flags</tt> are given, the object is added to the group as a whole
(i.e. all of its selection points, in case it has more than one).
<p>
If <tt>flags</tt> has a non-zero value, only the group flags of the given
points of the object are set. For a UL_WIRE this means that <tt>'1'</tt>
sets the group flag of the first point, <tt>'2'</tt> that of the second point,
and <tt>'3'</tt> sets both. Any previously set group flags remain unchanged
by a call to <tt>setgroup()</tt>.
<p>
When applied to an object that contains other objects (like a UL_BOARD or
UL_NET) the group flags of all contained objects are set recursively with following limitations:<br>
It's not the case for UL_LIBRARY and UL_SCHEMATIC. Subordinate objects that are not selectable
or not inidividually selectable are not flagged (e.g. UL_GRID or UL_VARIANT objects or wires
of UL_TEXT or UL_FRAME objects). <br>
For details on the object hierarchies see <a href=#206>Object Types</a>.
<h2>Example</h2>
<pre>
board(B) {
  B.elements(E)
    setgroup(E);
  }
</pre>


<a name=348>
<h1>setvariant()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Sets the current assembly variant.
<dt>
<b>Syntax</b>
<dd>
<tt>int setvariant(string name);</tt>
</dl>
<b>See also</b> <a href=#349>variant()</a>,
<a href=#250>UL_VARIANTDEF</a>,
<a href=#137>VARIANT command</a>
<p>
The <tt>setvariant()</tt> function sets the current assembly variant to the one
given by <tt>name</tt>. This can be used to loop through all of the parts and
"see" their data exactly as defined in the given variant.
<p>
<tt>name</tt> must reference a valid assembly variant that is contained in the
current drawing.
<p>
This function returns a non-zero value if the given assembly variant exists,
zero otherwise.
<p>
The assembly variant that has been set by a call to <tt>setvariant()</tt> is
only active until the User Language Program returns. After that, the variant
in the drawing will be the same as before the start of the ULP.
<p>
Setting the assembly variant in a board is only possible if the consistent
schematic is loaded.
<h2>Example</h2>
<pre>
if (setvariant("My variant")) {
   // do something ...
else
   // error: unknown variant
</pre>


<a name=349>
<h1>variant()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Query the current assembly variant.
<dt>
<b>Syntax</b>
<dd>
<tt>string variant(void);</tt>
</dl>
<b>See also</b> <a href=#348>setvariant()</a>,
<a href=#250>UL_VARIANTDEF</a>,
<a href=#137>VARIANT command</a>
<p>
The <tt>variant()</tt> function returns the name of the current assembly variant.
If no variant is currently selected, the empty string (<tt>''</tt>) is returned.
<h2>Example</h2>
<pre>
string CurrentVariant = variant();
</pre>


<a name=350>
<h1>XML Functions</h1>
<i>XML functions</i> are used to process XML (<i>Extensible Markup Language</i>) data.
<p>
The following XML functions are available:
<ul>
<li><a href=#351>xmlattribute()</a>
<li><a href=#351>xmlattributes()</a>
<li><a href=#352>xmlelement()</a>
<li><a href=#352>xmlelements()</a>
<li><a href=#353>xmltags()</a>
<li><a href=#354>xmltext()</a>
</ul>


<a name=351>
<h1>xmlattribute(), xmlattributes()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Extract the attributes of an XML tag.
<dt>
<b>Syntax</b>
<dd>
<tt>string xmlattribute(string xml, string tag, string attribute);</tt><br>
<tt>int xmlattributes(string &amp;array[], string xml, string tag);</tt>
</dl>
<b>See also</b> <a href=#352>xmlelement()</a>,
<a href=#353>xmltags()</a>,
<a href=#354>xmltext()</a>
<p>
The <tt>xmlattribute</tt> function returns the value of the given <tt>attribute</tt>
from the given <tt>tag</tt> within the given <tt>xml</tt> code.
If an attribute appears more than once in the same tag, the value of its last
occurrence is taken.
<p>
The <tt>xmlattributes</tt> function stores the names of all attributes
from the given <tt>tag</tt> within the given <tt>xml</tt> code in the <tt>array</tt>
and returns the number of attributes found.
The order is not necessarily the same like in the given <tt>xml</tt> code.
If an attribute appears more than once in the same tag, its name appears only
once in the <tt>array</tt>.
<p>
The <tt>tag</tt> is given in the form of a <i>path</i>.
<p>
If the given <tt>xml</tt> code contains an error, the result of any XML function
is empty, and a warning dialog is presented to the user, giving information
about where in the ULP and XML code the error occurred. Note that the line and
column number within the XML code refers to the actual string given to this
function as the <tt>xml</tt> parameter.
<h2>Example</h2>
<pre>
// String XML contains the following data:
//&lt;root&gt;
//  &lt;body abc="def" xyz="123"&gt;
//    ...
//  &lt;/body&gt;
//&lt;/root&gt;<br>
string s[];
int n = xmlattributes(s, XML, "root/body");<br>
// Result: { "abc", "xyz" }<br>
string s = xmlattribute(XML, "root/body", "xyz");<br>
// Result: "123"
</pre>


<a name=352>
<h1>xmlelement(), xmlelements()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Extract elements from an XML code.
<dt>
<b>Syntax</b>
<dd>
<tt>string xmlelement(string xml, string tag);</tt><br>
<tt>int xmlelements(string &amp;array[], string xml, string tag);</tt>
</dl>
<b>See also</b> <a href=#353>xmltags()</a>,
<a href=#351>xmlattribute()</a>,
<a href=#354>xmltext()</a>
<p>
The <tt>xmlelement</tt> function returns the complete XML element of the given
<tt>tag</tt> within the given <tt>xml</tt> code.
The result still contains the element's outer XML tag, and can thus be used
for further processing with the other XML functions.
Any whitespace within plain text parts of the element is retained.
The overall formatting of the XML tags within the element and the order of element
attributes may be different than the original <tt>xml</tt> code, though.<br>
If there is more than one occurrence of <tt>tag</tt> within <tt>xml</tt>, the
first one will be returned. Use <tt>xmlelements</tt> if you want to get all
occurrences.
<p>
The <tt>xmlelements</tt> function works just like <tt>xmlelement</tt>, but returns
all occurrences of elements with the given <tt>tag</tt>. The return value is the
number of elements stored in the <tt>array</tt>.
<p>
The <tt>tag</tt> is given in the form of a <i>path</i>.
<p>
If the given <tt>xml</tt> code contains an error, the result of any XML function
is empty, and a warning dialog is presented to the user, giving information
about where in the ULP and XML code the error occurred. Note that the line and
column number within the XML code refers to the actual string given to this
function as the <tt>xml</tt> parameter.
<h2>Example</h2>
<pre>
// String XML contains the following data:
//&lt;root&gt;
//  &lt;body&gt;
//    &lt;contents&gt;
//      &lt;string&gt;Some text 1&lt;/string&gt;
//      &lt;any&gt;anything 1&lt;/any&gt;
//    &lt;/contents&gt;
//    &lt;contents&gt;
//      &lt;string&gt;Some text 2&lt;/string&gt;
//      &lt;any&gt;anything 2&lt;/any&gt;
//    &lt;/contents&gt;
//    &lt;appendix&gt;
//      &lt;string&gt;Some text 3&lt;/string&gt;
//    &lt;/appendix&gt;
//  &lt;/body&gt;
//&lt;/root&gt;
//<br>
string s = xmlelement(XML, "root/body/appendix");<br>
// Result: " &lt;appendix&gt;\n  &lt;string&gt;Some text 3&lt;/string&gt;\n &lt;/appendix&gt;\n"<br>
string s[];
int n = xmlelements(s, XML, "root/body/contents");<br>
// Result: { " &lt;contents&gt;\n  &lt;string&gt;Some text 1&lt;/string&gt;\n  &lt;any&gt;anything 1&lt;/any&gt;\n &lt;/contents&gt;\n",
//           " &lt;contents&gt;\n  &lt;string&gt;Some text 2&lt;/string&gt;\n  &lt;any&gt;anything 2&lt;/any&gt;\n &lt;/contents&gt;\n"
//         }
</pre>


<a name=353>
<h1>xmltags()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Extract the list of tag names within an XML code.
<dt>
<b>Syntax</b>
<dd>
<tt>int xmltags(string &amp;array[], string xml, string tag);</tt>
</dl>
<b>See also</b> <a href=#352>xmlelement()</a>,
<a href=#351>xmlattribute()</a>,
<a href=#354>xmltext()</a>
<p>
The <tt>xmltags</tt> function returns the names of all the tags on the top level
of the given <tt>tag</tt> within the given <tt>xml</tt> code.
The return value is the number of tag names stored in the <tt>array</tt>.
<p>
Each tag name is returned only once, even if it appears several times in the XML code.
<p>
The <tt>tag</tt> is given in the form of a <i>path</i>.
<p>
If the given <tt>xml</tt> code contains an error, the result of any XML function
is empty, and a warning dialog is presented to the user, giving information
about where in the ULP and XML code the error occurred. Note that the line and
column number within the XML code refers to the actual string given to this
function as the <tt>xml</tt> parameter.
<h2>Example</h2>
<pre>
//String XML contains the following data:
//&lt;root&gt;
//  &lt;body&gt;
//    &lt;contents&gt;
//      &lt;string&gt;Some text 1&lt;/string&gt;
//      &lt;any&gt;anything 1&lt;/any&gt;
//    &lt;/contents&gt;
//    &lt;contents&gt;
//      &lt;string&gt;Some text 2&lt;/string&gt;
//      &lt;any&gt;anything 2&lt;/any&gt;
//    &lt;/contents&gt;
//    &lt;appendix&gt;
//      &lt;string&gt;Some text 3&lt;/string&gt;
//    &lt;/appendix&gt;
//  &lt;/body&gt;
//&lt;/root&gt;
//<br>
string s[];
int n = xmltags(s, XML, "root/body");<br>
// Result: { "contents", "appendix" } <br>
int n = xmltags(s, XML, "");        <br>
// Result: "root"
</pre>


<a name=354>
<h1>xmltext()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Extract the textual data of an XML element.
<dt>
<b>Syntax</b>
<dd>
<tt>string xmltext(string xml, string tag);</tt>
</dl>
<b>See also</b> <a href=#352>xmlelement()</a>,
<a href=#351>xmlattribute()</a>,
<a href=#353>xmltags()</a>
<p>
The <tt>xmltext</tt> function returns the textual data from
the given <tt>tag</tt> within the given <tt>xml</tt> code.
<p>
Any tags within the text are stripped, whitespace (including
newline characters) is retained.
<p>
The <tt>tag</tt> is given in the form of a <i>path</i>.
<p>
If the given <tt>xml</tt> code contains an error, the result of any XML function
is empty, and a warning dialog is presented to the user, giving information
about where in the ULP and XML code the error occurred. Note that the line and
column number within the XML code refers to the actual string given to this
function as the <tt>xml</tt> parameter.
<h2>Example</h2>
<pre>
// String XML contains the following data:
//&lt;root&gt;
//  &lt;body&gt;
//    Some &lt;b&gt;text&lt;/b&gt;.
//  &lt;/body&gt;
//&lt;/root&gt;
//<br>
string s = xmltext(XML, "root/body");<br>
// Result: "\n    Some text.\n  "
</pre>


<a name=355>
<h1>Builtin Statements</h1>
<i>Builtin statements</i> are generally used to open a certain context in which
data structures or files can be accessed.
<p>
The general syntax of a builtin statement is
<pre>
name(parameters) statement
</pre>
where <tt>name</tt> is the name of the builtin statement, <tt>parameters</tt>
stands for one or more parameters, and <tt>statement</tt> is the code that
will be executed inside the context opened by the builtin statement.
<p>
Note that <tt>statement</tt> can be a compound statement, as in
<pre>
board(B) {
  B.elements(E) printf("Element: %s\n", E.name);
  B.Signals(S)  printf("Signal: %s\n", S.name);
  }
</pre>
The following builtin statements are available:
<ul>
<li><a href=#356>board()</a>
<li><a href=#357>deviceset()</a>
<li><a href=#358>library()</a>
<li><a href=#359>module()</a>
<li><a href=#360>output()</a>
<li><a href=#361>footprint()</a> (new as of EAGLE 9.1)
<li><a href=#362>schematic()</a>
<li><a href=#363>sheet()</a>
<li><a href=#364>symbol()</a>
</ul>


<a name=356>
<h1>board()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a board context.
<dt>
<b>Syntax</b>
<dd>
<tt>board(identifier) statement</tt>
</dl>
<b>See also</b> <a href=#362>schematic</a>,
<a href=#358>library</a>
<p>
The <tt>board</tt> statement opens a board context if the current editor
window contains a board drawing. A variable of type
<a href=#210>UL_BOARD</a> is created and is given
the name indicated by <tt>identifier</tt>.
<p>
Once the board context is successfully opened and a board variable has been
created, the <tt>statement</tt> is executed. Within the scope of the
<tt>statement</tt> the board variable can be accessed to retrieve further
data from the board.
<p>
If the current editor window does not contain a board drawing, an error
message is given and the ULP is terminated.
<h2>Check if there is a board</h2>
By using the <tt>board</tt> statement without an argument you can check
if the current editor window contains a board drawing. In that case,
<tt>board</tt> behaves like an integer constant, returning <tt>1</tt> if
there is a board drawing in the current editor window, and <tt>0</tt>
otherwise.
<h2>Accessing board from a schematic</h2>
If the current editor window contains a schematic drawing, you can still
access that schematic's board by preceding the <tt>board</tt> statement
with the prefix <tt>project</tt>, as in
<pre>
project.board(B) { ... }
</pre>
This will open a board context regardless whether the current editor window
contains a board or a schematic drawing. However, there must be an editor
window containing that board somewhere on the desktop!
<h2>Example</h2>
<pre>
if (board)
   board(B) {
     B.elements(E)
       printf("Element: %s\n", E.name);
     }
</pre>


<a name=357>
<h1>deviceset()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a device set context.
<dt>
<b>Syntax</b>
<dd>
<tt>deviceset(identifier) statement</tt>
</dl>
<b>See also</b> <a href=#361>footprint</a>,
<a href=#364>symbol</a>,
<a href=#358>library</a>
<p>
The <tt>deviceset</tt> statement opens a device set context if the current editor
window contains a device drawing. A variable of type
<a href=#217>UL_DEVICESET</a> is created and is given
the name indicated by <tt>identifier</tt>.
<p>
Once the device set context is successfully opened and a device set variable has been
created, the <tt>statement</tt> is executed. Within the scope of the
<tt>statement</tt> the device set variable can be accessed to retrieve further
data from the device set.
<p>
If the current editor window does not contain a device drawing, an error
message is given and the ULP is terminated.
<h2>Check if there is a device set</h2>
By using the <tt>deviceset</tt> statement without an argument you can check
if the current editor window contains a device drawing. In that case,
<tt>deviceset</tt> behaves like an integer constant, returning <tt>1</tt> if
there is a device drawing in the current editor window, and <tt>0</tt>
otherwise.
<h2>Example</h2>
<pre>
if (deviceset)
   deviceset(D) {
     D.gates(G)
       printf("Gate: %s\n", G.name);
     }
</pre>


<a name=358>
<h1>library()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a library context.
<dt>
<b>Syntax</b>
<dd>
<tt>library(identifier) statement</tt>
</dl>
<b>See also</b> <a href=#356>board</a>,
<a href=#362>schematic</a>,
<a href=#357>deviceset</a>,
<a href=#361>footprint</a>,
<a href=#364>symbol</a>
<p>
The <tt>library</tt> statement opens a library context if the current editor
window contains a library drawing. A variable of type
<a href=#229>UL_LIBRARY</a> is created and is given
the name indicated by <tt>identifier</tt>.
<p>
Once the library context is successfully opened and a library variable has been
created, the <tt>statement</tt> is executed. Within the scope of the
<tt>statement</tt> the library variable can be accessed to retrieve further
data from the library.
<p>
If the current editor window does not contain a library drawing, an error
message is given and the ULP is terminated.
<h2>Check if there is a library</h2>
By using the <tt>library</tt> statement without an argument you can check
if the current editor window contains a library drawing. In that case,
<tt>library</tt> behaves like an integer constant, returning <tt>1</tt> if
there is a library drawing in the current editor window, and <tt>0</tt>
otherwise.
<h2>Example</h2>
<pre>
if (library)
   library(L) {
     L.devices(D)
       printf("Device: %s\n", D.name);
     }
</pre>


<a name=359>
<h1>module()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a module context.
<dt>
<b>Syntax</b>
<dd>
<tt>module(identifier) statement</tt>
</dl>
<b>See also</b> <a href=#356>board</a>,
<a href=#358>library</a>,
<a href=#362>schematic</a>,
<a href=#363>sheet</a>
<p>
#The <tt>module</tt> statement opens a module context if the current editor#
#window contains a module drawing. A variable of type#
The <tt>module</tt> statement opens a module context if in the editor
window currently a module drawing is edited. A variable of type
<a href=#230>UL_MODULE</a> is created and is given
the name indicated by <tt>identifier</tt>.
<p>
Once the module context is successfully opened and a module variable has been
created, the <tt>statement</tt> is executed. Within the scope of the
<tt>statement</tt> the module variable can be accessed to retrieve further
data from the module.
<p>
#If the current editor window does not contain a module drawing, an error#
#message is given and the ULP is terminated.#
If in the editor window currently no module drawing is edited, an error
message is given and the ULP is terminated.
<h2>Check if there is a module</h2>
By using the <tt>module</tt> statement without an argument you can check
#if the current editor window contains a module drawing. In that case,#
if in the editor window currently a module drawing is edited. In that case,
<tt>module</tt> behaves like an integer constant, returning <tt>1</tt> if
there is a module drawing in the current editor window, and <tt>0</tt>
otherwise.
<h2>Example</h2>
<pre>
if (module)
   module(M) {
     printf("Module: %s\n", M.name);
     }
</pre>


<a name=360>
<h1>output()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens an output file for subsequent printf() calls.
<dt>
<b>Syntax</b>
<dd>
<tt>output(string filename[, string mode]) statement</tt>
</dl>
<b>See also</b> <a href=#321>printf</a>,
<a href=#292>fileerror</a>
<p>
The <tt>output</tt> statement opens a file with the given <tt>filename</tt>
and <tt>mode</tt> for output through subsequent printf() calls.
If the file has been successfully opened, the <tt>statement</tt> is
executed, and after that the file is closed.
<p>
If the file cannot be opened, an error message is given and execution
of the ULP is terminated.
<p>
By default the output file is written into the <b>Project</b> directory.
<h2>File Modes</h2>
The <tt>mode</tt> parameter defines how the output file is to be opened.
If no <tt>mode</tt> parameter is given, the default is <tt>"wt"</tt>.
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><tt>a</tt>   </td><td width=20><td>append to an existing file, or create a new file if it does not exist</td></tr>
<tr><td><tt>w</tt>   </td><td width=20><td>create a new file (overwriting an existing file)</td></tr>
<tr><td><tt>t</tt>   </td><td width=20><td>open file in text mode</td></tr>
<tr><td><tt>b</tt>   </td><td width=20><td>open file in binary mode</td></tr>
<tr><td><tt>D</tt>   </td><td width=20><td>delete this file when ending the EAGLE session (only works together with <tt>w</tt>)</td></tr>
<tr><td><tt>F</tt>   </td><td width=20><td>force using this file name (normally *.brd, *.sch and *.lbr are rejected)</td></tr>
</table>
<p>
Mode characters may appear in any order and combination. However, only the
last one of <tt>a</tt> and <tt>w</tt> or <tt>t</tt> and <tt>b</tt>, respectively,
is significant. For example a mode of <tt>"abtw"</tt> would open a file for
textual write, which would be the same as <tt>"wt"</tt>.
<h2>Nested Output statements</h2>
<tt>output</tt> statements can be nested, as long as there are enough file
handles available, and provided that no two active <tt>output</tt> statements
access the <b>same</b> file.
<h2>Example</h2>
<pre>
void PrintText(string s)
{
  printf("This also goes into the file: %s\n", s);
}
output("file.txt", "wt") {
  printf("Directly printed\n");
  PrintText("via function call");
  }
</pre>


<a name=361>
<h1>footprint(), new as of EAGLE 9.1</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a footprint context.
<dt>
<b>Syntax</b>
<dd>
<tt>footprint(identifier) statement</tt> (new as of EAGLE 9.1)
</dl>
<b>See also</b> <a href=#358>library</a>,
<a href=#357>deviceset</a>,
<a href=#364>symbol</a>
<p>
The <tt>footprint</tt> statement opens a package context if the current editor
window contains a package drawing. A variable of type
<a href=#233>UL_FOOTPRINT</a> is created and is given
the name indicated by <tt>identifier</tt>.
<p>
Note: the <tt>footprint</tt> statement is new in EAGLE 9.1. For backwards
compatibility with prior EAGLE versions, <tt>package</tt> is available as an alias.
<p>
Once the footprint context is successfully opened and a footprint variable has been
created, the <tt>statement</tt> is executed. Within the scope of the
<tt>statement</tt> the footprint variable can be accessed to retrieve further
data from the footprint.
<p>
If the current editor window does not contain a footprint drawing, an error
message is given and the ULP is terminated.
<h2>Check if there is a footprint</h2>
By using the <tt>footprint</tt> statement without an argument you can check
if the current editor window contains a footprint drawing. In that case,
<tt>footprint</tt> behaves like an integer constant, returning <tt>1</tt> if
there is a footprint drawing in the current editor window, and <tt>0</tt>
otherwise.
<h2>Example</h2>
<pre>
if (footprint)
   footprint(F) {
     F.contacts(C)
       printf("Contact: %s\n", C.name);
     }
</pre>


<a name=362>
<h1>schematic()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a schematic context.
<dt>
<b>Syntax</b>
<dd>
<tt>schematic(identifier) statement</tt>
</dl>
<b>See also</b> <a href=#356>board</a>,
<a href=#358>library</a>,
<a href=#359>module</a>,
<a href=#363>sheet</a>
<p>
The <tt>schematic</tt> statement opens a schematic context if the current editor
window contains a schematic drawing. A variable of type
<a href=#243>UL_SCHEMATIC</a> is created and is given
the name indicated by <tt>identifier</tt>.
<p>
Once the schematic context is successfully opened and a schematic variable has been
created, the <tt>statement</tt> is executed. Within the scope of the
<tt>statement</tt> the schematic variable can be accessed to retrieve further
data from the schematic.
<p>
If the current editor window does not contain a schematic drawing, an error
message is given and the ULP is terminated.
<h2>Check if there is a schematic</h2>
By using the <tt>schematic</tt> statement without an argument you can check
if the current editor window contains a schematic drawing. In that case,
<tt>schematic</tt> behaves like an integer constant, returning <tt>1</tt> if
there is a schematic drawing in the current editor window, and <tt>0</tt>
otherwise.
<h2>Accessing schematic from a board</h2>
If the current editor window contains a board drawing, you can still
access that board's schematic by preceding the <tt>schematic</tt> statement
with the prefix <tt>project</tt>, as in
<pre>
project.schematic(S) { ... }
</pre>
This will open a schematic context regardless whether the current editor window
contains a schematic or a board drawing. However, there must be an editor
window containing that schematic somewhere on the desktop!
<h2>Access the current Sheet</h2>
Use the <tt><a href=#363>sheet</a></tt> statement to
directly access the currently loaded sheet.
<h2>Access the current Module</h2>
Use the <tt><a href=#359>module</a></tt> statement to
directly access the currently edited module.
<h2>Example</h2>
<pre>
if (schematic)
   schematic(S) {
     S.parts(P)
       printf("Part: %s\n", P.name);
     }
</pre>


<a name=363>
<h1>sheet()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a sheet context.
<dt>
<b>Syntax</b>
<dd>
<tt>sheet(identifier) statement</tt>
</dl>
<b>See also</b> <a href=#362>schematic</a>
<p>
The <tt>sheet</tt> statement opens a sheet context if the current editor
window contains a sheet drawing. A variable of type
<a href=#245>UL_SHEET</a> is created and is given
the name indicated by <tt>identifier</tt>.
<p>
Once the sheet context is successfully opened and a sheet variable has been
created, the <tt>statement</tt> is executed. Within the scope of the
<tt>statement</tt> the sheet variable can be accessed to retrieve further
data from the sheet.
<p>
If the current editor window does not contain a sheet drawing, an error
message is given and the ULP is terminated.
<h2>Check if there is a sheet</h2>
By using the <tt>sheet</tt> statement without an argument you can check
if the current editor window contains a sheet drawing. In that case,
<tt>sheet</tt> behaves like an integer constant, returning <tt>1</tt> if
there is a sheet drawing in the current editor window, and <tt>0</tt>
otherwise.
<h2>Example</h2>
<pre>
if (sheet)
   sheet(S) {
     S.instances(I)
       printf("Instance: %s\n", I.name);
     }
</pre>


<a name=364>
<h1>symbol()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a symbol context.
<dt>
<b>Syntax</b>
<dd>
<tt>symbol(identifier) statement</tt>
</dl>
<b>See also</b> <a href=#358>library</a>,
<a href=#357>deviceset</a>,
<a href=#361>footprint</a>
<p>
The <tt>symbol</tt> statement opens a symbol context if the current editor
window contains a symbol drawing. A variable of type
<a href=#248>UL_SYMBOL</a> is created and is given
the name indicated by <tt>identifier</tt>.
<p>
Once the symbol context is successfully opened and a symbol variable has been
created, the <tt>statement</tt> is executed. Within the scope of the
<tt>statement</tt> the symbol variable can be accessed to retrieve further
data from the symbol.
<p>
If the current editor window does not contain a symbol drawing, an error
message is given and the ULP is terminated.
<h2>Check if there is a symbol</h2>
By using the <tt>symbol</tt> statement without an argument you can check
if the current editor window contains a symbol drawing. In that case,
<tt>symbol</tt> behaves like an integer constant, returning <tt>1</tt> if
there is a symbol drawing in the current editor window, and <tt>0</tt>
otherwise.
<h2>Example</h2>
<pre>
if (symbol)
   symbol(S) {
     S.pins(P)
       printf("Pin: %s\n", P.name);
     }
</pre>


<a name=365>
<h1>Dialogs</h1>
User Language Dialogs allow you to define your own frontend to a User Language Program.
<p>
The following sections describe User Language Dialogs in detail:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#366>Predefined Dialogs</a>  </td><td width=20><td>describes the ready to use standard dialogs</td></tr>
<tr><td><a href=#370>Dialog Objects</a>  </td><td width=20><td>defines the objects that can be used in a dialog</td></tr>
<tr><td><a href=#394>Layout Information</a>  </td><td width=20><td>explains how to define the location of objects within a dialog</td></tr>
<tr><td><a href=#395>Dialog Functions</a>  </td><td width=20><td>describes special functions for use with dialogs</td></tr>
<tr><td><a href=#402>A Complete Example</a>  </td><td width=20><td>shows a complete ULP with a data entry dialog</td></tr>
</table>


<a name=366>
<h1>Predefined Dialogs</h1>
<i>Predefined Dialogs</i> implement the typical standard dialogs that are frequently used
for selecting file names or issuing error messages.
<p>
The following predefined dialogs are available:
<ul>
<li><a href=#367>dlgDirectory()</a>
<li><a href=#368>dlgFileOpen()</a>
<li><a href=#368>dlgFileSave()</a>
<li><a href=#369>dlgMessageBox()</a>
</ul>
See <a href=#370>Dialog Objects</a> for information on how to
define your own complex user dialogs.


<a name=367>
<h1>dlgDirectory()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Displays a directory dialog.
<dt>
<b>Syntax</b>
<dd>
<tt>string dlgDirectory(string Title[, string Start])</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>dlgDirectory</tt> function returns the full pathname of the selected directory.<br>
If the user has canceled the dialog, the result will be an empty string.
</dl>
<b>See also</b> <a href=#368>dlgFileOpen</a>
<p>
The <tt>dlgDirectory</tt> function displays a directory dialog from which the user can
select a directory.
<p>
<tt>Title</tt> will be used as the dialog's title.
<p>
If <tt>Start</tt> is not empty, it will be used as the starting point for the <tt>dlgDirectory</tt>.
<h2>Example</h2>
<pre>
string dirName;
dirName = dlgDirectory("Select a directory", "");
</pre>


<a name=368>
<h1>dlgFileOpen(), dlgFileSave()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Displays a file dialog.
<dt>
<b>Syntax</b>
<dd>
<tt>string dlgFileOpen(string Title[, string Start[, string Filter]])</tt><br>
<tt>string dlgFileSave(string Title[, string Start[, string Filter]])</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>dlgFileOpen</tt> and <tt>dlgFileSave</tt> functions return the full pathname of the selected file.<br>
If the user has canceled the dialog, the result will be an empty string.
</dl>
<b>See also</b> <a href=#367>dlgDirectory</a>
<p>
The <tt>dlgFileOpen</tt> and <tt>dlgFileSave</tt> functions display a file dialog from which the user can
select a file.
<p>
<tt>Title</tt> will be used as the dialog's title.
<p>
If <tt>Start</tt> is not empty, it will be used as the starting point for the file dialog.
Otherwise the current directory will be used.
<p>
Only files matching <tt>Filter</tt> will be displayed. If <tt>Filter</tt> is empty, all files will
be displayed.
<p>
<tt>Filter</tt> can be either a simple wildcard (as in <tt>"*.brd"</tt>), a list of
wildcards (as in <tt>"*.bmp&nbsp;*.jpg"</tt>) or may even contain descriptive text, as in
<tt>"Bitmap&nbsp;files&nbsp;(*.bmp)"</tt>. If the "File type" combo box of the file dialog shall
contain several entries, they have to be separated by double semicolons, as in
<tt>"Bitmap&nbsp;files&nbsp;(*.bmp);;Other&nbsp;images&nbsp;(*.jpg&nbsp;*.png)"</tt>.
<h2>Example</h2>
<pre>
string fileName;
fileName = dlgFileOpen("Select a file", "", "*.brd");
</pre>


<a name=369>
<h1>dlgMessageBox()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Displays a message box.
<dt>
<b>Syntax</b>
<dd>
<tt>int dlgMessageBox(string Message[, <i>button_list</i>])</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>dlgMessageBox</tt> function returns the index of the button the user has selected.<br>
The first button in <tt>button_list</tt> has index <tt>0</tt>.
</dl>
<b>See also</b> <a href=#313>status()</a>
<p>
The <tt>dlgMessageBox</tt> function displays the given <tt>Message</tt> in a modal dialog and
waits until the user selects one of the buttons defined in <tt>button_list</tt>.
<p>
If <tt>Message</tt> contains any HTML tags, the characters '&lt;', '&gt;' and '&amp;'
must be given as "&amp;lt;", "&amp;gt;" and "&amp;amp;", respectively, if they shall
be displayed as such.
<p>
<tt>button_list</tt> is an optional list of comma separated strings, which defines the
set of buttons that will be displayed at the bottom of the message box.<br>
A maximum of three buttons can be defined.
If no <tt>button_list</tt> is given, it defaults to <tt>"OK"</tt>.
<p>
The first button in <tt>button_list</tt> will become the default button (which will be selected
if the user hits ENTER), and the last button in the list will become the "cancel button", which
is selected if the user hits ESCape or closes the message box. You can make a different
button the default button by starting its name with a <tt>'+'</tt>, and you can make
a different button the cancel button by starting its name with a <tt>'-'</tt>.
To start a button text with an actual <tt>'+'</tt> or <tt>'-'</tt> it has to be <a href=#401>escaped</a>.
<p>
If a button text contains an <tt>'&amp;'</tt>, the character following the ampersand
will become a hotkey, and when the user hits the corresponding key, that button will be selected.
To have an actual <tt>'&amp;'</tt> character in the text it has to be <a href=#401>escaped</a>.
<p>
The message box can be given an icon by setting the first character of <tt>Message</tt> to<br>
&nbsp;&nbsp;&nbsp;<tt>'<b>;</b>'</tt> - for an <i>Information</i><br>
&nbsp;&nbsp;&nbsp;<tt>'<b>!</b>'</tt> - for a <i>Warning</i><br>
&nbsp;&nbsp;&nbsp;<tt>'<b>:</b>'</tt> - for an <i>Error</i><br>
If, however, the <tt>Message</tt> shall begin with one of these characters, it has to be <a href=#401>escaped</a>.
<p>
<table><tr><td valign="top"><img src="platforms-mac.png"></td><td valign="middle">
On <b>Mac OS X</b> only the character <tt>'<b>:</b>'</tt> will actually result in
showing an icon. All others are ignored.
</td></tr></table>
<h2>Example</h2>
<pre>
if (dlgMessageBox("!Are you sure?", "&amp;Yes", "&amp;No") == 0) {
   // let's do it!
   }
</pre>


<a name=370>
<h1>Dialog Objects</h1>
A User Language Dialog is built from the following <i>Dialog Objects</i>:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#371>dlgCell</a>    </td><td width=20><td>a grid cell context</td></tr>
<tr><td><a href=#372>dlgCheckBox</a>      </td><td width=20><td>a checkbox</td></tr>
<tr><td><a href=#373>dlgComboBox</a>      </td><td width=20><td>a combo box selection field</td></tr>
<tr><td><a href=#374>dlgDialog</a>          </td><td width=20><td>the basic container of any dialog</td></tr>
<tr><td><a href=#375>dlgGridLayout</a>  </td><td width=20><td>a grid based layout context</td></tr>
<tr><td><a href=#376>dlgGroup</a>            </td><td width=20><td>a group field</td></tr>
<tr><td><a href=#377>dlgHBoxLayout</a>  </td><td width=20><td>a horizontal box layout context</td></tr>
<tr><td><a href=#378>dlgIntEdit</a>        </td><td width=20><td>an integer entry field</td></tr>
<tr><td><a href=#379>dlgLabel</a>            </td><td width=20><td>a text label</td></tr>
<tr><td><a href=#380>dlgListBox</a>        </td><td width=20><td>a list box</td></tr>
<tr><td><a href=#381>dlgListView</a>      </td><td width=20><td>a list view</td></tr>
<tr><td><a href=#382>dlgPushButton</a>  </td><td width=20><td>a push button</td></tr>
<tr><td><a href=#383>dlgRadioButton</a></td><td width=20><td>a radio button</td></tr>
<tr><td><a href=#384>dlgRealEdit</a>      </td><td width=20><td>a real entry field</td></tr>
<tr><td><a href=#385>dlgSpacing</a>        </td><td width=20><td>a layout spacing object</td></tr>
<tr><td><a href=#386>dlgSpinBox</a>        </td><td width=20><td>a spin box selection field</td></tr>
<tr><td><a href=#387>dlgStretch</a>        </td><td width=20><td>a layout stretch object</td></tr>
<tr><td><a href=#388>dlgStringEdit</a>  </td><td width=20><td>a string entry field</td></tr>
<tr><td><a href=#389>dlgTabPage</a>        </td><td width=20><td>a tab page</td></tr>
<tr><td><a href=#390>dlgTabWidget</a>    </td><td width=20><td>a tab page container</td></tr>
<tr><td><a href=#391>dlgTextEdit</a>      </td><td width=20><td>a text entry field</td></tr>
<tr><td><a href=#392>dlgTextView</a>      </td><td width=20><td>a text viewer field</td></tr>
<tr><td><a href=#393>dlgVBoxLayout</a>  </td><td width=20><td>a vertical box layout context</td></tr>
</table>
<p>


<a name=371>
<h1>dlgCell</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a cell location within a grid layout context.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgCell(int row, int column[, int row2, int column2]) <i>statement</i></tt>
</dl>
<b>See also</b> <a href=#375>dlgGridLayout</a>,
<a href=#377>dlgHBoxLayout</a>,
<a href=#393>dlgVBoxLayout</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgCell</tt> statement defines the location of a cell within a
<a href=#375>grid layout context</a>.
<p>
The row and column indexes start at 0, so the upper left cell has the index&nbsp;(0,&nbsp;0).
<p>
With two parameters the dialog object defined by <tt>statement</tt> will be placed in
the single cell addresses by <tt>row</tt> and <tt>column</tt>.
With four parameters the dialog object will span over all cells from <tt>row</tt>/<tt>column</tt>
to <tt>row2</tt>/<tt>column2</tt>.
<p>
By default a <tt>dlgCell</tt> contains a <a href=#377>dlgHBoxLayout</a>,
so if the cell contains more than one dialog object, they will be placed next to
each other horizontally.
<h2>Example</h2>
<pre>
string Text;
dlgGridLayout {
  dlgCell(0, 0) dlgLabel("Cell 0,0");
  dlgCell(1, 2, 4, 7) dlgTextEdit(Text);
  }
</pre>


<a name=372>
<h1>dlgCheckBox</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a checkbox.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgCheckBox(string Text, int &amp;Checked) [ <i>statement</i> ]</tt>
</dl>
<b>See also</b> <a href=#383>dlgRadioButton</a>,
<a href=#376>dlgGroup</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgCheckBox</tt> statement defines a check box with the given <tt>Text</tt>.
<p>
If <tt>Text</tt> contains an <tt>'&amp;'</tt>, the character following the ampersand
will become a hotkey, and when the user hits <tt>Alt+hotkey</tt>, the checkbox will be toggled.
To have an actual <tt>'&amp;'</tt> character in the text it has to be <a href=#401>escaped</a>.
<p>
<tt>dlgCheckBox</tt> is mainly used within a <a href=#376>dlgGroup</a>,
but can also be used otherwise.<br>
All check boxes within the same dialog must have <b>different</b> <tt>Checked</tt> variables!
<p>
If the user checks a <tt>dlgCheckBox</tt>, the associated <tt>Checked</tt> variable is set
to <tt>1</tt>, otherwise it is set to <tt>0</tt>.
The initial value of <tt>Checked</tt> defines whether a checkbox is initially checked.
If <tt>Checked</tt> is not equal to <tt>0</tt>, the checkbox is initially checked.
<p>
The optional <tt>statement</tt> is executed every time the <tt>dlgCheckBox</tt> is toggled.
<h2>Example</h2>
<pre>
int mirror = 0;
int rotate = 1;
int flip   = 0;
dlgGroup("Orientation") {
  dlgCheckBox("&amp;Mirror", mirror);
  dlgCheckBox("&amp;Rotate", rotate);
  dlgCheckBox("&amp;Flip", flip);
  }
</pre>


<a name=373>
<h1>dlgComboBox</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a combo box selection field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgComboBox(string array[], int &amp;Selected) [ <i>statement</i> ]</tt>
</dl>
<b>See also</b> <a href=#380>dlgListBox</a>,
<a href=#379>dlgLabel</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgComboBox</tt> statement defines a combo box selection field with the contents
of the given <tt>array</tt>.
<p>
<tt>Selected</tt> reflects the index of the selected combo box entry. The first entry has index <tt>0</tt>.
<p>
Each element of <tt>array</tt> defines the contents of one entry in the combo box.
None of the strings in <tt>array</tt> may be empty (if there is an empty string,
all strings after and including that one will be dropped).
<p>
The optional <tt>statement</tt> is executed whenever the selection in the <tt>dlgComboBox</tt> changes.<br>
Before the <tt>statement</tt> is executed, all variables that have been used with dialog objects
are updated to their current values, and any changes made to these variables inside the
<tt>statement</tt> will be reflected in the dialog when the statement returns.
<p>
If the initial value of <tt>Selected</tt> is outside the range of the <tt>array</tt>
indexes, it is set to <tt>0</tt>.
<h2>Example</h2>
<pre>
string Colors[] = { "red", "green", "blue", "yellow" };
int Selected = 2; // initially selects "blue"
dlgComboBox(Colors, Selected) dlgMessageBox("You have selected " + Colors[Selected]);
</pre>


<a name=374>
<h1>dlgDialog</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Executes a User Language Dialog.
<dt>
<b>Syntax</b>
<dd>
<tt>int dlgDialog(string Title) <i>block</i> ;</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>dlgDialog</tt> function returns an integer value that can be given a user defined meaning
through a call to the <tt><a href=#396>dlgAccept()</a></tt> function.<br>
If the dialog is simply closed, the return value will be <tt>-1</tt>.
</dl>
<b>See also</b> <a href=#375>dlgGridLayout</a>,
<a href=#377>dlgHBoxLayout</a>,
<a href=#393>dlgVBoxLayout</a>,
<a href=#396>dlgAccept</a>,
<a href=#398>dlgReset</a>,
<a href=#399>dlgReject</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgDialog</tt> function executes the dialog defined by
<tt><a href=#273>block</a></tt>.
This is the only dialog object that actually is a User Language builtin
function. Therefore it can be used anywhere where a function call is allowed.
<p>
The <tt>block</tt> normally contains only other <a href=#370>dialog objects</a>,
but it is also possible to use other User Language statements, for example to conditionally add
objects to the dialog (see the second example below).
<p>
By default a <tt>dlgDialog</tt> contains a <a href=#393>dlgVBoxLayout</a>,
so a simple dialog doesn't have to worry about the layout.
<p>
A <tt>dlgDialog</tt> should at some point contain a call to the <tt><a href=#396>dlgAccept()</a></tt>
function in order to allow the user to close the dialog and accept its contents.
<p>
If all you need is a simple message box or file dialog you might want to use one of the
<a href=#366>Predefined Dialogs</a> instead.
<h2>Examples</h2>
<pre>
int Result = dlgDialog("Hello") {
  dlgLabel("Hello world");
  dlgPushButton("+OK") dlgAccept();
  };
int haveButton = 1;
dlgDialog("Test") {
  dlgLabel("Start");
  if (haveButton)
     dlgPushButton("Here") dlgAccept();
  };
</pre>


<a name=375>
<h1>dlgGridLayout</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a grid layout context.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgGridLayout <i>statement</i></tt>
</dl>
<b>See also</b> <a href=#371>dlgCell</a>,
<a href=#377>dlgHBoxLayout</a>,
<a href=#393>dlgVBoxLayout</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgGridLayout</tt> statement opens a grid layout context.
<p>
The only dialog object that can be used directly in <tt>statement</tt> is
<a href=#371>dlgCell</a>, which defines the location of a particular
dialog object within the grid layout.
<p>
The row and column indexes start at 0, so the upper left cell has the index&nbsp;(0,&nbsp;0).<br>
The number of rows and columns is automatically extended according to the location of
dialog objects that are defined within the grid layout context, so you don't have
to explicitly define the number of rows and columns.
<h2>Example</h2>
<pre>
dlgGridLayout {
  dlgCell(0, 0) dlgLabel("Row 0/Col 0");
  dlgCell(1, 0) dlgLabel("Row 1/Col 0");
  dlgCell(0, 1) dlgLabel("Row 0/Col 1");
  dlgCell(1, 1) dlgLabel("Row 1/Col 1");
  }
</pre>


<a name=376>
<h1>dlgGroup</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a group field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgGroup(string Title) <i>statement</i></tt>
</dl>
<b>See also</b> <a href=#372>dlgCheckBox</a>,
<a href=#383>dlgRadioButton</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgGroup</tt> statement defines a group with the given <tt>Title</tt>.
<p>
By default a <tt>dlgGroup</tt> contains a <a href=#393>dlgVBoxLayout</a>,
so a simple group doesn't have to worry about the layout.
<p>
<tt>dlgGroup</tt> is mainly used to contain a set of <a href=#383>radio buttons</a>
or <a href=#372>check boxes</a>, but may as well contain any other objects in its
<tt>statement</tt>.<br>
Radio buttons within a <tt>dlgGroup</tt> are numbered starting with <tt>0</tt>.
<h2>Example</h2>
<pre>
int align = 1;
dlgGroup("Alignment") {
  dlgRadioButton("&amp;Top", align);
  dlgRadioButton("&amp;Center", align);
  dlgRadioButton("&amp;Bottom", align);
  }
</pre>


<a name=377>
<h1>dlgHBoxLayout</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a horizontal box layout context.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgHBoxLayout <i>statement</i></tt>
</dl>
<b>See also</b> <a href=#375>dlgGridLayout</a>,
<a href=#393>dlgVBoxLayout</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgHBoxLayout</tt> statement opens a horizontal box layout context for the given
<tt>statement</tt>.
<h2>Example</h2>
<pre>
dlgHBoxLayout {
  dlgLabel("Box 1");
  dlgLabel("Box 2");
  dlgLabel("Box 3");
  }
</pre>


<a name=378>
<h1>dlgIntEdit</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines an integer entry field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgIntEdit(int &amp;Value, int Min, int Max)</tt>
</dl>
<b>See also</b> <a href=#384>dlgRealEdit</a>,
<a href=#388>dlgStringEdit</a>,
<a href=#379>dlgLabel</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgIntEdit</tt> statement defines an integer entry field with the given <tt>Value</tt>.
<p>
If <tt>Value</tt> is initially outside the range defined by <tt>Min</tt> and <tt>Max</tt>
it will be limited to these values.
<h2>Example</h2>
<pre>
int Value = 42;
dlgHBoxLayout {
  dlgLabel("Enter a &amp;Number between 0 and 99");
  dlgIntEdit(Value, 0, 99);
  }
</pre>


<a name=379>
<h1>dlgLabel</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a text label.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgLabel(string Text [, int Update])</tt>
</dl>
<b>See also</b> <a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>,
<a href=#397>dlgRedisplay()</a>
<p>
The <tt>dlgLabel</tt> statement defines a label with the given <tt>Text</tt>.
<p>
<tt>Text</tt> can be either a string literal, as in <tt>"Hello"</tt>, or a string variable.
<p>
If <tt>Text</tt> contains any HTML tags, the characters '&lt;', '&gt;' and '&amp;'
must be given as "&amp;lt;", "&amp;gt;" and "&amp;amp;", respectively, if they shall
be displayed as such.
<p>
External hyperlinks in the <tt>Text</tt> will be opened with the appropriate
application program.
<p>
If the <tt>Update</tt> parameter is not <tt>0</tt> and <tt>Text</tt> is a string variable,
its contents can be modified in the <tt>statement</tt> of, e.g., a <a href=#382>dlgPushButton</a>,
and the label will be automatically updated. This, of course, is only
useful if <tt>Text</tt> is a dedicated string variable (not, e.g., the loop variable of
a <tt>for</tt> statement).
<p>
If <tt>Text</tt> contains an <tt>'&amp;'</tt>, and the object following the label
can have the keyboard focus, the character following the ampersand
will become a hotkey, and when the user hits <tt>Alt+hotkey</tt>, the focus will go to the
object that was defined immediately following the <tt>dlgLabel</tt>.
To have an actual <tt>'&amp;'</tt> character in the text it has to be <a href=#401>escaped</a>.
<h2>Example</h2>
<pre>
string OS = "Windows";
dlgHBoxLayout {
  dlgLabel(OS, 1);
  dlgPushButton("&amp;Change OS") { OS = "Linux"; }
  }
</pre>


<a name=380>
<h1>dlgListBox</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a list box selection field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgListBox(string array[], int &amp;Selected) [ <i>statement</i> ]</tt>
</dl>
<b>See also</b> <a href=#373>dlgComboBox</a>,
<a href=#381>dlgListView</a>,
<a href=#400>dlgSelectionChanged</a>,
<a href=#379>dlgLabel</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgListBox</tt> statement defines a list box selection field with the contents
of the given <tt>array</tt>.
<p>
<tt>Selected</tt> reflects the index of the selected list box entry. The first entry has index <tt>0</tt>.
<p>
Each element of <tt>array</tt> defines the contents of one line in the list box.
None of the strings in <tt>array</tt> may be empty (if there is an empty string,
all strings after and including that one will be dropped).
<p>
The optional <tt>statement</tt> is executed whenever the user double clicks on an entry
of the <tt>dlgListBox</tt> (see <a href=#400>dlgSelectionChanged</a>
for information on how to have the <tt>statement</tt> called when only the selection in the list
changes).<br>
Before the <tt>statement</tt> is executed, all variables that have been used with dialog objects
are updated to their current values, and any changes made to these variables inside the
<tt>statement</tt> will be reflected in the dialog when the statement returns.
<p>
If the initial value of <tt>Selected</tt> is outside the range of the <tt>array</tt>
indexes, no entry will be selected.
<h2>Example</h2>
<pre>
string Colors[] = { "red", "green", "blue", "yellow" };
int Selected = 2; // initially selects "blue"
dlgListBox(Colors, Selected) dlgMessageBox("You have selected " + Colors[Selected]);
</pre>


<a name=381>
<h1>dlgListView</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a multi column list view selection field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgListView(string Headers, string array[], int &amp;Selected[, int &amp;Sort]) [ <i>statement</i> ]</tt>
</dl>
<b>See also</b> <a href=#380>dlgListBox</a>,
<a href=#400>dlgSelectionChanged</a>,
<a href=#379>dlgLabel</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgListView</tt> statement defines a multi column list view selection field with the contents
of the given <tt>array</tt>.
<p>
<tt>Headers</tt> is the tab separated list of column headers.
<p>
<tt>Selected</tt> reflects the index of the selected list view entry in the <tt>array</tt>
(the sequence in which the entries are actually displayed may be different, because the contents
of a <tt>dlgListView</tt> can be sorted by the various columns).
The first entry has index <tt>0</tt>.<br>
If no particular entry shall be initially selected, <tt>Selected</tt> should be
initialized to <tt>-1</tt>.
If it is set to <tt>-2</tt>, the first item according
to the current sort column is made current.
If no view entry has been selected, -1 is returned.
<p>
<tt>Sort</tt> defines which column should be used to sort the list view. The leftmost
column is numbered <tt>1</tt>. The sign of this parameter defines the direction in which
to sort (positive values sort in ascending order). If <tt>Sort</tt> is <tt>0</tt> or
outside the valid number of columns, no sorting will be done. The returned value of
<tt>Sort</tt> reflects the column and sort mode selected by the user by clicking
on the list column headers. By default <tt>dlgListView</tt> sorts by the first
column, in ascending order.
<p>
Each element of <tt>array</tt> defines the contents of one line in the list view,
and must contain tab separated values. If there are fewer values in an element of <tt>array</tt>
than there are entries in the <tt>Headers</tt> string the remaining fields will be empty.
If there are more values in an element of <tt>array</tt> than there are entries in the
<tt>Headers</tt> string the superfluous elements will be silently dropped.
None of the strings in <tt>array</tt> may be empty (if there is an empty string,
all strings after and including that one will be dropped).
<p>
A list entry that contains line feeds (<tt>'\n'</tt>) will be displayed in several
lines accordingly.
<p>
The optional <tt>statement</tt> is executed whenever the user double clicks on an entry
of the <tt>dlgListView</tt> (see <a href=#400>dlgSelectionChanged</a>
for information on how to have the <tt>statement</tt> called when only the selection in the list
changes).<br>
Before the <tt>statement</tt> is executed, all variables that have been used with dialog objects
are updated to their current values, and any changes made to these variables inside the
<tt>statement</tt> will be reflected in the dialog when the statement returns.
<p>
If the initial value of <tt>Selected</tt> is outside the range of the <tt>array</tt>
indexes, no entry will be selected.
<p>
If <tt>Headers</tt> is an empty string, the first element of the <tt>array</tt> is used
as the header string. Consequently the index of the first entry is then <tt>1</tt>.
<p>
The contents of a <tt>dlgListView</tt> can be sorted by any column by clicking on
that column's header. Columns can also be swapped by "click&amp;dragging" a column
header. Note that none of these changes will have any effect on the contents of the
<tt>array</tt>.
If the contents shall be sorted alphanumerically a <tt>numeric string[]</tt> array
can be used.
<h2>Example</h2>
<pre>
string Colors[] = { "red\tThe color RED", "green\tThe color GREEN", "blue\tThe color BLUE" };
int Selected = 0; // initially selects "red"
dlgListView("Name\tDescription", Colors, Selected) dlgMessageBox("You have selected " + Colors[Selected]);
</pre>


<a name=382>
<h1>dlgPushButton</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a push button.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgPushButton(string Text) <i>statement</i></tt>
</dl>
<b>See also</b> <a href=#394>Layout Information</a>,
<a href=#395>Dialog Functions</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgPushButton</tt> statement defines a push button with the given <tt>Text</tt>.
<p>
If <tt>Text</tt> contains an <tt>'&amp;'</tt>, the character following the ampersand
will become a hotkey, and when the user hits <tt>Alt+hotkey</tt>, the button will be selected.
To have an actual <tt>'&amp;'</tt> character in the text it has to be <a href=#401>escaped</a>.
<p>
If <tt>Text</tt> starts with a <tt>'+'</tt> character, this button will become the default
button, which will be selected if the user hits ENTER.<br>
If <tt>Text</tt> starts with a <tt>'-'</tt> character, this button will become the cancel
button, which will be selected if the user closes the dialog.<br>
<b>CAUTION: Make sure that the <tt>statement</tt> of such a marked cancel button contains
a call to <a href=#399>dlgReject()</a>! Otherwise the user may be unable
to close the dialog at all!</b><br>
To have an actual <tt>'+'</tt> or <tt>'-'</tt> character as the first character of the text
it has to be <a href=#401>escaped</a>.
<p>
If the user selects a <tt>dlgPushButton</tt>, the given <tt>statement</tt> is executed.<br>
Before the <tt>statement</tt> is executed, all variables that have been used with dialog objects
are updated to their current values, and any changes made to these variables inside the
<tt>statement</tt> will be reflected in the dialog when the statement returns.
<h2>Example</h2>
<pre>
int defaultWidth = 10;
int defaultHeight = 20;
int width = 5;
int height = 7;
dlgPushButton("&amp;Reset defaults") {
  width = defaultWidth;
  height = defaultHeight;
  }
dlgPushButton("+&amp;Accept") dlgAccept();
dlgPushButton("-Cancel") { if (dlgMessageBox("Are you sure?", "Yes", "No") == 0) dlgReject(); }
</pre>


<a name=383>
<h1>dlgRadioButton</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a radio button.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgRadioButton(string Text, int &amp;Selected) [ <i>statement</i> ]</tt>
</dl>
<b>See also</b> <a href=#372>dlgCheckBox</a>,
<a href=#376>dlgGroup</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgRadioButton</tt> statement defines a radio button with the given <tt>Text</tt>.
<p>
If <tt>Text</tt> contains an <tt>'&amp;'</tt>, the character following the ampersand
will become a hotkey, and when the user hits <tt>Alt+hotkey</tt>, the button will be selected.
To have an actual <tt>'&amp;'</tt> character in the text it has to be <a href=#401>escaped</a>.
<p>
<tt>dlgRadioButton</tt> can only be used within a <a href=#376>dlgGroup</a>.<br>
All radio buttons within the same group must use the <b>same</b> <tt>Selected</tt> variable!
<p>
If the user selects a <tt>dlgRadioButton</tt>, the index of that button within the <tt>dlgGroup</tt>
is stored in the <tt>Selected</tt> variable.<br>
The initial value of <tt>Selected</tt> defines which radio button is initially selected.
If <tt>Selected</tt> is outside the valid range for this group, no radio button will be selected.
In order to get the correct radio button selection, <tt>Selected</tt> must be set <b>before</b>
the first <tt>dlgRadioButton</tt> is defined, and must not be modified between adding subsequent
radio buttons. Otherwise it is undefined which (if any) radio button will be selected.
<p>
The optional <tt>statement</tt> is executed every time the <tt>dlgRadioButton</tt> is selected.
<h2>Example</h2>
<pre>
int align = 1;
dlgGroup("Alignment") {
  dlgRadioButton("&amp;Top", align);
  dlgRadioButton("&amp;Center", align);
  dlgRadioButton("&amp;Bottom", align);
  }
</pre>


<a name=384>
<h1>dlgRealEdit</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a real entry field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgRealEdit(real &amp;Value, real Min, real Max)</tt>
</dl>
<b>See also</b> <a href=#378>dlgIntEdit</a>,
<a href=#388>dlgStringEdit</a>,
<a href=#379>dlgLabel</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgRealEdit</tt> statement defines a real entry field with the given <tt>Value</tt>.
<p>
If <tt>Value</tt> is initially outside the range defined by <tt>Min</tt> and <tt>Max</tt>
it will be limited to these values.
<h2>Example</h2>
<pre>
real Value = 1.4142;
dlgHBoxLayout {
  dlgLabel("Enter a &amp;Number between 0 and 99");
  dlgRealEdit(Value, 0.0, 99.0);
  }
</pre>


<a name=385>
<h1>dlgSpacing</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines additional space in a box layout context.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgSpacing(int Size)</tt>
</dl>
<b>See also</b> <a href=#377>dlgHBoxLayout</a>,
<a href=#393>dlgVBoxLayout</a>,
<a href=#387>dlgStretch</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgSpacing</tt> statement defines additional space in a vertical or horizontal box layout context.
<p>
<tt>Size</tt> defines the number of pixels of the additional space.
<h2>Example</h2>
<pre>
dlgVBoxLayout {
  dlgLabel("Label 1");
  dlgSpacing(40);
  dlgLabel("Label 2");
  }
</pre>


<a name=386>
<h1>dlgSpinBox</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a spin box selection field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgSpinBox(int &amp;Value, int Min, int Max)</tt>
</dl>
<b>See also</b> <a href=#378>dlgIntEdit</a>,
<a href=#379>dlgLabel</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgSpinBox</tt> statement defines a spin box entry field with the given <tt>Value</tt>.
<p>
If <tt>Value</tt> is initially outside the range defined by <tt>Min</tt> and <tt>Max</tt>
it will be limited to these values.
<h2>Example</h2>
<pre>
int Value = 42;
dlgHBoxLayout {
  dlgLabel("&amp;Select value");
  dlgSpinBox(Value, 0, 99);
  }
</pre>


<a name=387>
<h1>dlgStretch</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines an empty stretchable space in a box layout context.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgStretch(int Factor)</tt>
</dl>
<b>See also</b> <a href=#377>dlgHBoxLayout</a>,
<a href=#393>dlgVBoxLayout</a>,
<a href=#385>dlgSpacing</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgStretch</tt> statement defines an empty stretchable space in a vertical or horizontal box layout context.
<p>
<tt>Factor</tt> defines the stretch factor of the space.
<h2>Example</h2>
<pre>
dlgHBoxLayout {
  dlgStretch(1);
  dlgPushButton("+OK")    { dlgAccept(); };
  dlgPushButton("Cancel") { dlgReject(); };
  }
</pre>


<a name=388>
<h1>dlgStringEdit</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a string entry field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgStringEdit(string &amp;Text[, string &amp;History[][, int Size]])</tt>
</dl>
<b>See also</b> <a href=#384>dlgRealEdit</a>,
<a href=#378>dlgIntEdit</a>,
<a href=#391>dlgTextEdit</a>,
<a href=#379>dlgLabel</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgStringEdit</tt> statement defines a one line text entry field with the given <tt>Text</tt>.
<p>
If <tt>History</tt> is given, the strings the user has entered over time are stored
in that string array. The entry field then has a button that allows the user to
select from previously entered strings. If a <tt>Size</tt> greater than zero is given,
only at most that number of strings are stored in the array. If <tt>History</tt>
contains data when the dialog is newly opened, that data will be used to initialize
the history. The most recently entered user input is stored at index 0.<br>
None of the strings in <tt>History</tt> may be empty (if there is an empty string,
all strings after and including that one will be dropped).
<h2>Example</h2>
<pre>
string Name = "Linus";
dlgHBoxLayout {
  dlgLabel("Enter &amp;Name");
  dlgStringEdit(Name);
  }
</pre>


<a name=389>
<h1>dlgTabPage</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a tab page.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgTabPage(string Title) <i>statement</i></tt>
</dl>
<b>See also</b> <a href=#390>dlgTabWidget</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgTabPage</tt> statement defines a tab page with the given <tt>Title</tt> containing
the given <tt>statement</tt>.
<p>
If <tt>Title</tt> contains an <tt>'&amp;'</tt>, the character following the ampersand
will become a hotkey, and when the user hits <tt>Alt+hotkey</tt>, this tab page will be opened.
To have an actual <tt>'&amp;'</tt> character in the text it has to be <a href=#401>escaped</a>.
<p>
Tab pages can only be used within a <a href=#390>dlgTabWidget</a>.
<p>
By default a <tt>dlgTabPage</tt> contains a <a href=#393>dlgVBoxLayout</a>,
so a simple tab page doesn't have to worry about the layout.
<h2>Example</h2>
<pre>
dlgTabWidget {
  dlgTabPage("Tab &amp;1") {
    dlgLabel("This is page 1");
    }
  dlgTabPage("Tab &amp;2") {
    dlgLabel("This is page 2");
    }
  }
</pre>


<a name=390>
<h1>dlgTabWidget</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a container for tab pages.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgTabWidget <i>{ tabpages }</i></tt><br>
<tt>dlgTabWidget(int &amp;Index) <i>{ tabpages }</i></tt>
</dl>
<b>See also</b> <a href=#389>dlgTabPage</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgTabWidget</tt> defines a container for a set of tab pages.
<p>
<tt>tabpages</tt> must be a sequence of one or more <a href=#389>dlgTabPage</a> objects.
There must be no other dialog objects in this sequence.
<p>
<tt>Index</tt> defines which tab should be selected initially. If this selection
changes the variable <tt>Index</tt> is set accordingly. The first page has index
<tt>0</tt> (independent of its title).
<h2>Examples</h2>
<pre>
dlgTabWidget {
  dlgTabPage("Tab &amp;1") {
    dlgLabel("This is page 1");
    }
  dlgTabPage("Tab &amp;2") {
    dlgLabel("This is page 2");
    }
  }
</pre>
<pre>
dlgDialog("test")
{
  int TabNr = 0;
  int CheckBoxValue[];
  dlgTabWidget(TabNr) {
     for (int i = 0; i &lt;= 9; i++) {
         string s;
         sprintf(s, "%d", i);
         dlgTabPage("Tab " + s) {
            dlgLabel("This is page " + s);
            dlgCheckBox(s, CheckBoxValue[i]) {
               string Msg;
               sprintf(Msg, "Value #%d: %d\n", TabNr, CheckBoxValue[TabNr]);
               dlgMessageBox(Msg);
               }
            }
         }
     }
};
</pre>


<a name=391>
<h1>dlgTextEdit</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a multiline text entry field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgTextEdit(string &amp;Text)</tt>
</dl>
<b>See also</b> <a href=#388>dlgStringEdit</a>,
<a href=#392>dlgTextView</a>,
<a href=#379>dlgLabel</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgTextEdit</tt> statement defines a multiline text entry field with the given <tt>Text</tt>.
<p>
The lines in the <tt>Text</tt> have to be delimited by a newline character (<tt>'\n'</tt>).
Any whitespace characters at the end of the lines contained in <tt>Text</tt> will be
removed, and upon return there will be no whitespace characters at the end of the lines.
Empty lines at the end of the text will be removed entirely.
<h2>Example</h2>
<pre>
string Text = "This is some text.\nLine 2\nLine 3";
dlgVBoxLayout {
  dlgLabel("&amp;Edit the text");
  dlgTextEdit(Text);
  }
</pre>


<a name=392>
<h1>dlgTextView</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Defines a multiline text viewer field.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgTextView(string Text)</tt><br>
<tt>dlgTextView(string Text, string &amp;Link) <i>statement</i></tt>
</dl>
<b>See also</b> <a href=#391>dlgTextEdit</a>,
<a href=#379>dlgLabel</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgTextView</tt> statement defines a multiline text viewer field with the given <tt>Text</tt>.
<p>
The <tt>Text</tt> may contain <a href=#403>HTML</a> tags.
<p>
External hyperlinks in the <tt>Text</tt> will be opened with the appropriate
application program.
<p>
If <tt>Link</tt> is given and the <tt>Text</tt> contains hyperlinks, <tt>statement</tt>
will be executed every time the user clicks on a hyperlink, with the value of <tt>Link</tt>
set to whatever the <tt>&lt;a href=...&gt;</tt> tag defines as the value of <i>href</i>.
If, after the execution of <tt>statement</tt>, the <tt>Link</tt> variable is not empty,
the default handling of hyperlinks will take place. This is also the case if <tt>Link</tt>
contains some text before dlgTextView is opened, which allows for an initial
scrolling to a given position.
If a <tt>Link</tt> is given, external hyperlinks will not be opened.
<h2>Example</h2>
<pre>
string Text = "This is some text.\nLine 2\nLine 3";
dlgVBoxLayout {
  dlgLabel("&amp;View the text");
  dlgTextView(Text);
  }
</pre>


<a name=393>
<h1>dlgVBoxLayout</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Opens a vertical box layout context.
<dt>
<b>Syntax</b>
<dd>
<tt>dlgVBoxLayout <i>statement</i></tt>
</dl>
<b>See also</b> <a href=#375>dlgGridLayout</a>,
<a href=#377>dlgHBoxLayout</a>,
<a href=#394>Layout Information</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgVBoxLayout</tt> statement opens a vertical box layout context for the given
<tt>statement</tt>.
<p>
By default a <a href=#374>dlgDialog</a> contains a <tt>dlgVBoxLayout</tt>,
so a simple dialog doesn't have to worry about the layout.
<h2>Example</h2>
<pre>
dlgVBoxLayout {
  dlgLabel("Box 1");
  dlgLabel("Box 2");
  dlgLabel("Box 3");
  }
</pre>


<a name=394>
<h1>Layout Information</h1>
All objects within a User Language Dialog a placed inside a <i>layout context</i>.
<p>
Layout contexts can be either <a href=#375>grid</a>, <a href=#377>horizontal</a>
or <a href=#393>vertical</a>.
<h2>Grid Layout Context</h2>
Objects in a grid layout context must specify the grid coordinates of the cell or cells into
which they shall be placed. To place a text label at row 5, column 2, you would write
<pre>
dlgGridLayout {
  dlgCell(5, 2) dlgLabel("Text");
  }
</pre>
If the object shall span over more than one cell you need to specify the coordinates of the
starting cell and the ending cell. To place a group that extends from row 1, column 2 up to row 3,
column 5, you would write
<pre>
dlgGridLayout {
  dlgCell(1, 2, 3, 5) dlgGroup("Title") {
    //...
    }
  }
</pre>
<h2>Horizontal Layout Context</h2>
Objects in a horizontal layout context are placed left to right.
<p>
The special objects <a href=#387>dlgStretch</a> and <a href=#385>dlgSpacing</a>
can be used to further refine the distribution of the available space.
<p>
To define two buttons that are pushed all the way to the right edge of the dialog,
you would write
<pre>
dlgHBoxLayout {
  dlgStretch(1);
  dlgPushButton("+OK")    dlgAccept();
  dlgPushButton("Cancel") dlgReject();
  }
</pre>
<h2>Vertical Layout Context</h2>
Objects in a vertical layout context follow the same rules as those in a horizontal
layout context, except that they are placed top to bottom.
<h2>Mixing Layout Contexts</h2>
Vertical, horizontal and grid layout contexts can be mixed to create the desired layout
structure of a dialog.
See the <a href=#402>Complete Example</a> for a demonstration of this.


<a name=395>
<h1>Dialog Functions</h1>
The following functions can be used with User Language Dialogs:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><a href=#396>dlgAccept()</a>  </td><td width=20><td>closes the dialog and accepts its contents</td></tr>
<tr><td><a href=#397>dlgRedisplay()</a>  </td><td width=20><td>immediately redisplays the dialog after changes to any values</td></tr>
<tr><td><a href=#398>dlgReset()</a>  </td><td width=20><td>resets all dialog objects to their initial values</td></tr>
<tr><td><a href=#399>dlgReject()</a>  </td><td width=20><td>closes the dialog and rejects its contents</td></tr>
<tr><td><a href=#400>dlgSelectionChanged()</a>  </td><td width=20><td>tells whether the current selection in a dlgListView or dlgListBox has changed</td></tr>
</table>


<a name=396>
<h1>dlgAccept()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Closes the dialog and accepts its contents.
<dt>
<b>Syntax</b>
<dd>
<tt>void dlgAccept([ <i>int Result</i> ]);</tt>
</dl>
<b>See also</b> <a href=#399>dlgReject</a>,
<a href=#374>dlgDialog</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgAccept</tt> function causes the <a href=#374>dlgDialog</a> to be closed
and return after the current statement sequence has been completed.
<p>
Any changes the user has made to the dialog values will be accepted and are copied into
the variables that have been given when the <a href=#370>dialog objects</a>
were defined.
<p>
The optional <tt>Result</tt> is the value that will be returned by the dialog.
Typically this should be a positive integer value.
If no value is given, it defaults to <tt>1</tt>.
<p>
Note that <tt>dlgAccept()</tt> does return to the normal program execution,
so in a sequence like
<pre>
dlgPushButton("OK") {
  dlgAccept();
  dlgMessageBox("Accepting!");
  }
</pre>
the statement after <tt>dlgAccept()</tt> will still be executed!
<h2>Example</h2>
<pre>
int Result = dlgDialog("Test") {
               dlgPushButton("+OK")    dlgAccept(42);
               dlgPushButton("Cancel") dlgReject();
               };
</pre>


<a name=397>
<h1>dlgRedisplay()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Redisplays the dialog after changing values.
<dt>
<b>Syntax</b>
<dd>
<tt>void dlgRedisplay(void);</tt>
</dl>
<b>See also</b> <a href=#398>dlgReset</a>,
<a href=#374>dlgDialog</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgRedisplay</tt> function can be called to immediately refresh the
<a href=#374>dlgDialog</a> after changes have been made to the variables
used when defining the <a href=#370>dialog objects</a>.
<p>
You only need to call <tt>dlgRedisplay()</tt> if you want the dialog to be refreshed
while still executing program code. In the example below the status is changed
to "Running..." and <tt>dlgRedisplay()</tt> has to be called to make this change
take effect before the "program action" is performed. After the final status
change to "Finished." there is no need to call <tt>dlgRedisplay()</tt>, since
all dialog objects are automatically updated after leaving the statement.
<h2>Example</h2>
<pre>
string Status = "Idle";
int Result = dlgDialog("Test") {
               dlgLabel(Status, 1); // note the '1' to tell the label to be updated!
               dlgPushButton("+OK")    dlgAccept(42);
               dlgPushButton("Cancel") dlgReject();
               dlgPushButton("Run") {
                 Status = "Running...";
                 dlgRedisplay();
                 // some program action here...
                 Status = "Finished.";
                 }
               };
</pre>


<a name=398>
<h1>dlgReset()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Resets all dialog objects to their initial values.
<dt>
<b>Syntax</b>
<dd>
<tt>void dlgReset(void);</tt>
</dl>
<b>See also</b> <a href=#399>dlgReject</a>,
<a href=#374>dlgDialog</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgReset</tt> function copies the initial values back into all
<a href=#370>dialog objects</a> of the current
<a href=#374>dlgDialog</a>.
<p>
Any changes the user has made to the dialog values will be discarded.
<p>
Calling <a href=#399><tt>dlgReject()</tt></a> implies a call
to <tt>dlgReset()</tt>.
<h2>Example</h2>
<pre>
int Number = 1;
int Result = dlgDialog("Test") {
               dlgIntEdit(Number);
               dlgPushButton("+OK")    dlgAccept(42);
               dlgPushButton("Cancel") dlgReject();
               dlgPushButton("Reset")  dlgReset();
               };
</pre>


<a name=399>
<h1>dlgReject()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Closes the dialog and rejects its contents.
<dt>
<b>Syntax</b>
<dd>
<tt>void dlgReject([ <i>int Result</i> ]);</tt>
</dl>
<b>See also</b> <a href=#396>dlgAccept</a>,
<a href=#398>dlgReset</a>,
<a href=#374>dlgDialog</a>,
<a href=#402>A Complete Example</a>
<p>
The <tt>dlgReject</tt> function causes the <a href=#374>dlgDialog</a> to be closed
and return after the current statement sequence has been completed.
<p>
Any changes the user has made to the dialog values will be discarded.
The variables that have been given when the <a href=#370>dialog objects</a>
were defined will be reset to their original values when the dialog returns.
<p>
The optional <tt>Result</tt> is the value that will be returned by the dialog.
Typically this should be <tt>0</tt> or a negative integer value.
If no value is given, it defaults to <tt>0</tt>.
<p>
Note that <tt>dlgReject()</tt> does return to the normal program execution,
so in a sequence like
<pre>
dlgPushButton("Cancel") {
  dlgReject();
  dlgMessageBox("Rejecting!");
  }
</pre>
the statement after <tt>dlgReject()</tt> will still be executed!
<p>
Calling <tt>dlgReject()</tt> implies a call to <a href=#398><tt>dlgReset()</tt></a>.
<h2>Example</h2>
<pre>
int Result = dlgDialog("Test") {
               dlgPushButton("+OK")    dlgAccept(42);
               dlgPushButton("Cancel") dlgReject();
               };
</pre>


<a name=400>
<h1>dlgSelectionChanged()</h1>
<dl>
<dt>
<b>Function</b>
<dd>
Tells whether the current selection in a dlgListView or dlgListBox has changed.
<dt>
<b>Syntax</b>
<dd>
<tt>int dlgSelectionChanged(void);</tt>
<dt>
<b>Returns</b>
<dd>
The <tt>dlgSelectionChanged</tt> function returns a nonzero value if only the
selection in the list has changed.
</dl>
<b>See also</b> <a href=#381>dlgListView</a>,
<a href=#380>dlgListBox</a>
<p>
The <tt>dlgSelectionChanged</tt> function can be used in a list context
to determine whether the statement of the <tt>dlgListView</tt> or <tt>dlgListBox</tt> was
called because the user double clicked on an item, or whether only the
current selection in the list has changed.
<p>
If the statement of a <tt>dlgListView</tt> or <tt>dlgListBox</tt> doesn't contain any
call to <tt>dlgSelectionChanged</tt>, that statement is only executed when the user
double clicks on an item in the list. However, if a ULP needs to react on changes
to the current selection in the list, it can call <tt>dlgSelectionChanged</tt> within
the list's statement. This causes the statement to also be called if the current
selection in the list changes.
<p>
If a list item is initially selected when the dialog is opened and the list's statement
contains a call to <tt>dlgSelectionChanged</tt>, the statement is executed with
<tt>dlgSelectionChanged</tt> returning true in order to indicate the initial change
from "no selection" to an actual selection. Any later programmatical changes to the strings
or the selection of the list will not trigger an automatic execution of the list's
statement. This is important to remember in case the current list item controls another
dialog object, for instance a <tt>dlgTextView</tt> that shows an extended representation of
the currently selected item.
<h2>Example</h2>
<pre>
string Colors[] = { "red\tThe color RED", "green\tThe color GREEN", "blue\tThe color BLUE" };
int Selected = 0; // initially selects "red"
string MyColor;
dlgLabel(MyColor, 1);
dlgListView("Name\tDescription", Colors, Selected) {
  if (dlgSelectionChanged())
     MyColor = Colors[Selected];
  else
     dlgMessageBox("You have chosen " + Colors[Selected]);
  }
</pre>


<a name=401>
<h1>Escape Character</h1>
Some characters have special meanings in button
or label texts, so they need to be <i>escaped</i> if they shall appear literally.
<p>
To do this you need to prepend the character with a <i>backslash</i>, as in
<pre>
dlgLabel("Miller \\&amp; Co.");
</pre>
This will result in "Miller &amp; Co." displayed in the dialog.
<p>
Note that there are actually <b>two</b> backslash characters here, since this line
will first go through the User Language parser, which will strip the first backslash.


<a name=402>
<h1>A Complete Example</h1>
Here's a complete example of a User Language Dialog.
<pre>
int hor = 1;
int ver = 1;
string fileName;
int Result = dlgDialog("Enter Parameters") {
  dlgHBoxLayout {
    dlgStretch(1);
    dlgLabel("This is a simple dialog");
    dlgStretch(1);
    }
  dlgHBoxLayout {
    dlgGroup("Horizontal") {
      dlgRadioButton("&amp;Top", hor);
      dlgRadioButton("&amp;Center", hor);
      dlgRadioButton("&amp;Bottom", hor);
      }
    dlgGroup("Vertical") {
      dlgRadioButton("&amp;Left", ver);
      dlgRadioButton("C&amp;enter", ver);
      dlgRadioButton("&amp;Right", ver);
      }
    }
  dlgHBoxLayout {
    dlgLabel("File &amp;name:");
    dlgStringEdit(fileName);
    dlgPushButton("Bro&amp;wse") {
      fileName = dlgFileOpen("Select a file", fileName);
      }
    }
  dlgGridLayout {
    dlgCell(0, 0) dlgLabel("Row 0/Col 0");
    dlgCell(1, 0) dlgLabel("Row 1/Col 0");
    dlgCell(0, 1) dlgLabel("Row 0/Col 1");
    dlgCell(1, 1) dlgLabel("Row 1/Col 1");
    }
  dlgSpacing(10);
  dlgHBoxLayout {
    dlgStretch(1);
    dlgPushButton("+OK")    dlgAccept();
    dlgPushButton("Cancel") dlgReject();
    }
  };
</pre>


<a name=403>
<h1>Supported HTML tags</h1>
EAGLE supports a subset of the tags used to format HTML pages.
This can be used to format the text of several <a href=#365>User Language Dialog</a> objects,
in the <tt><a href=#182>#usage</a></tt> directive or in the <a href=#50>description</a>
of library objects.
<p>
Text is considered to be HTML if the first line contains a tag.
If this is not the case, and you want the text to be formatted, you need to
enclose the entire text in the <tt>&lt;html&gt;...&lt;/html&gt;</tt> tag.
<p>
The following table lists all supported HTML tags and their available attributes:
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Tag</b></td><td width=20><td><b>Description</b></td></tr>
<tr><td>&lt;html&gt;...&lt;/html&gt;</td><td width=20><td>An HTML document.</td></tr>
<tr><td>&lt;body&gt;...&lt;/body&gt;</td><td width=20><td>The body of an HTML document. It understands the following attribute
<ul>
<li><tt>bgcolor</tt> - The background color, for example <tt>bgcolor="yellow"</tt> or <tt>bgcolor="#0000FF"</tt>.
                       This attribute works only within a <a href=#392>dlgTextView</a>.
</ul>
</td></tr>
<tr><td>&lt;h1&gt;...&lt;/h1&gt;</td><td width=20><td>A top-level heading.</td></tr>
<tr><td>&lt;h2&gt;...&lt;/h2&gt;</td><td width=20><td>A sub-level heading.</td></tr>
<tr><td>&lt;h3&gt;...&lt;/h3&gt;</td><td width=20><td>A sub-sub-level heading.</td></tr>
<tr><td>&lt;p&gt;...&lt;/p&gt;</td><td width=20><td>A left-aligned paragraph. Adjust the alignment with the <tt>align</tt> attribute. Possible values are <tt>left</tt>, <tt>right</tt> and <tt>center</tt>.</td></tr>
<tr><td>&lt;center&gt;...&lt;/center&gt;</td><td width=20><td>A centered paragraph.</td></tr>
<tr><td>&lt;blockquote&gt;...&lt;/blockquote&gt;</td><td width=20><td>An indented paragraph, useful for quotes.</td></tr>
<tr><td>&lt;ul&gt;...&lt;/ul&gt;</td><td width=20><td>An un-ordered list. You can also pass a type argument to define the bullet style. The default is <tt>type=disc</tt>,  other types are <tt>circle</tt> and <tt>square</tt>.</td></tr>
<tr><td>&lt;ol&gt;...&lt;/ol&gt;</td><td width=20><td>An ordered list. You can also pass a type argument to define the enumeration label style. The default is <tt>type="1"</tt>, other types are <tt>"a"</tt> and <tt>"A"</tt>.</td></tr>
<tr><td>&lt;li&gt;...&lt;/li&gt;</td><td width=20><td>A list item. This tag can only be used within the context of <tt>ol</tt> or <tt>ul</tt>.</td></tr>
<tr><td>&lt;pre&gt;...&lt;/pre&gt;</td><td width=20><td>For larger chunks of code. Whitespaces in the contents are preserved. For small bits of code, use the inline-style <tt>code</tt>.</td></tr>
<tr><td>&lt;a&gt;...&lt;/a&gt;</td><td width=20><td>An anchor or link. It understands the following attributes:
<ul>
<li><tt>href</tt> - The reference target as in <tt>&lt;a href="target.html"&gt;...&lt;/a&gt;</tt>. You can also specify an additional anchor within the specified target document, for example <tt>&lt;a href="target.html#123"&gt;...&lt;/a&gt;</tt>.
                    If you want to link to a local file that has a blank in its name, you need to prepend the file name with <tt>file:</tt>, as in <tt>&lt;a href="file:/path with blanks/target.html"&gt;...&lt;/a&gt;</tt>.
<li><tt>name</tt> - The anchor name, as in <tt>&lt;a name="123"&gt;...&lt;/a&gt;</tt>.
</ul>
</td></tr>
<tr><td>&lt;em&gt;...&lt;/em&gt;</td><td width=20><td>Emphasized (same as <tt>&lt;i&gt;...&lt;/i&gt;</tt>).</td></tr>
<tr><td>&lt;strong&gt;...&lt;/strong&gt;</td><td width=20><td>Strong (same as <tt>&lt;b&gt;...&lt;/b&gt;</tt>).</td></tr>
<tr><td>&lt;i&gt;...&lt;/i&gt;</td><td width=20><td>Italic font style.</td></tr>
<tr><td>&lt;b&gt;...&lt;/b&gt;</td><td width=20><td>Bold font style.</td></tr>
<tr><td>&lt;u&gt;...&lt;/u&gt;</td><td width=20><td>Underlined font style.</td></tr>
<tr><td>&lt;big&gt;...&lt;/big&gt;</td><td width=20><td>A larger font size.</td></tr>
<tr><td>&lt;small&gt;...&lt;/small&gt;</td><td width=20><td>A smaller font size.</td></tr>
<tr><td>&lt;code&gt;...&lt;/code&gt;</td><td width=20><td>Indicates Code. (same as <tt>&lt;tt&gt;...&lt;/tt&gt;</tt>. For larger chunks of code, use the block-tag <tt>pre</tt>.</td></tr>
<tr><td>&lt;tt&gt;...&lt;/tt&gt;</td><td width=20><td>Typewriter font style.</td></tr>
<tr><td>&lt;font&gt;...&lt;/font&gt;</td><td width=20><td>Customizes the font size, family and text color. The tag understands the following attributes:
<ul>
<li><tt>color</tt> - The text color, for example <tt>color="red"</tt> or <tt>color="#FF0000"</tt>.
<li><tt>size</tt> - The logical size of the font. Logical sizes 1 to 7 are supported. The value may either be absolute, for example <tt>size=3,</tt> or relative like <tt>size=-2</tt>. In the latter case, the sizes are simply added.
<li><tt>face</tt> - The family of the font, for example <tt>face=times</tt>.
</ul>
</td></tr>
<tr><td>&lt;img...&gt;</td><td width=20><td>An image. This tag understands the following attributes:
<ul>
<li><tt>src</tt> - The image name, for example <tt>&lt;img src="image.png"&gt;</tt>.<br>
The URL of the image may be external, as in <tt>&lt;img src="http://web.cadsoft.de/cslogo.gif"&gt;</tt>.
<li><tt>width</tt> - The width of the image. If the image does not fit to the specified size, it will be scaled automatically.
<li><tt>height</tt> - The height of the image.
<li><tt>align</tt> - Determines where the image is placed. Per default, an image is placed inline, just like a normal character. Specify <tt>left</tt> or <tt>right</tt> to place the image at the respective side.
</ul>
</td></tr>
<tr><td>&lt;hr&gt;</td><td width=20><td>A horizonal line.</td></tr>
<tr><td>&lt;br&gt;</td><td width=20><td>A line break.</td></tr>
<tr><td>&lt;nobr&gt;...&lt;/nobr&gt;</td><td width=20><td>No break. Prevents word wrap.</td></tr>
<tr><td>&lt;table&gt;...&lt;/table&gt;</td><td width=20><td>A table definition.
The default table is frameless. Specify the boolean attribute
<tt>border</tt> in order to get a frame. Other attributes are:
<ul>
<li><tt>bgcolor</tt> - The background color.
<li> <tt>width</tt> - The table width. This is either absolute in pixels or relative in percent of the column width, for example <tt>width=80%</tt>.
<li> <tt>border</tt> - The width of the table border. The default is 0 (= no border).
<li> <tt>cellspacing</tt> - Additional space around the table cells. The default is 2.
<li> <tt>cellpadding</tt> - Additional space around the contents of table cells. Default is 1.
</ul>
</td></tr>
<tr><td>&lt;tr&gt;...&lt;/tr&gt;</td><td width=20><td>A table row. Can only be used within <tt>table</tt>. Understands the attribute
<ul>
<li><tt>bgcolor</tt> - The background color.
</ul>
</td></tr>
<tr><td>&lt;td&gt;...&lt;/td&gt;</td><td width=20><td>A table data cell. Can only be used within <tt>tr.</tt> Understands the attributes
<ul>
<li><tt>bgcolor</tt> - The background color.
<li> <tt>width</tt> - The cell width. This is either absolute in pixels or relative in percent of the entire table width, for example <tt>width=50%</tt>.
<li> <tt>colspan</tt> - Defines how many columns this cell spans. The default is 1.
<li> <tt>rowspan</tt> - Defines how many rows this cell spans. The default is 1.
<li> <tt>align</tt> - Alignment, possible values are <tt>left</tt>, <tt>right</tt> and <tt>center</tt>. The default is left-aligned.
</ul>
</td></tr>
<tr><td>&lt;th&gt;...&lt;/th&gt;</td><td width=20><td>A table header cell. Like <tt>td</tt> but defaults to center-alignment and a bold font.</td></tr>
<tr><td>&lt;author&gt;...&lt;/author&gt;</td><td width=20><td>Marks the author of this text.</td></tr>
<tr><td>&lt;dl&gt;...&lt;/dl&gt;</td><td width=20><td>A definition list.</td></tr>
<tr><td>&lt;dt&gt;...&lt;/dt&gt;</td><td width=20><td>A definition tag. Can only be used within <tt>dl</tt>.</td></tr>
<tr><td>&lt;dd&gt;...&lt;/dd&gt;</td><td width=20><td>Definition data. Can only be used within <tt>dl</tt>.</td></tr>
</table>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td><b>Tag</b></td><td width=20><td><b>Meaning</b></td></tr>
<tr><td>&amp;lt;</td><td width=20><td>&lt;</td></tr>
<tr><td>&amp;gt;</td><td width=20><td>&gt;</td></tr>
<tr><td>&amp;amp;</td><td width=20><td>&amp;</td></tr>
<tr><td>&amp;nbsp;</td><td width=20><td>non-breaking space</td></tr>
<tr><td>&amp;auml;</td><td width=20><td>&auml;</td></tr>
<tr><td>&amp;ouml;</td><td width=20><td>&ouml;</td></tr>
<tr><td>&amp;uuml;</td><td width=20><td>&uuml;</td></tr>
<tr><td>&amp;Auml;</td><td width=20><td>&Auml;</td></tr>
<tr><td>&amp;Ouml;</td><td width=20><td>&Ouml;</td></tr>
<tr><td>&amp;Uuml;</td><td width=20><td>&Uuml;</td></tr>
<tr><td>&amp;szlig;</td><td width=20><td>&szlig;</td></tr>
<tr><td>&amp;copy;</td><td width=20><td>&copy;</td></tr>
<tr><td>&amp;deg;</td><td width=20><td>&deg;</td></tr>
<tr><td>&amp;micro;</td><td width=20><td>&micro;</td></tr>
<tr><td>&amp;plusmn;</td><td width=20><td>&plusmn;</td></tr>
<tr><td>&amp;quot;</td><td width=20><td>&quot;</td></tr>
</table>


<a name=404>
<h1>Automatic Backup</h1>
<h2>Maximum backup level</h2>
The WRITE command creates backup copies of the saved files.
These backups have the same name as the original file, with a
modified extension that follows the pattern
<pre>
.x#n
</pre>
In this pattern <tt>'x'</tt> is replaced by the character
<p>
<tt>'b'</tt> for board files<br>
<tt>'s'</tt> for schematic files<br>
<tt>'l'</tt> for library files<br>
<tt>'d'</tt> for designblock files
<p>
<tt>'n'</tt> stands for a single digit number in
the range 1..9. Higher numbers indicate older files.
<p>
The fixed '#' character makes it easy to delete all backup files
from the operating system, using <b><tt>*.?#?</tt></b> as a wildcard.
<p>
Note that backup files with the same number 'n' do not necessarily
represent consistent combinations of board and schematic files!
<p>
The maximum number of backup copies can be set in the
<a href=#16>backup dialog</a>.
<h2>Auto backup interval</h2>
If a drawing has been modified a safety backup copy will be automatically
created after at most the given <i>Auto backup interval</i>.
<p>
This safety backup file will have a name that follows the pattern
<pre>
.x##
</pre>
In this pattern <tt>'x'</tt> is replaced by the character
<p>
<tt>'b'</tt> for board files<br>
<tt>'s'</tt> for schematic files<br>
<tt>'l'</tt> for library files<br>
<tt>'d'</tt> for designblock files
<p>
The safety backup file will be deleted after a successful regular save
operation. If the drawing has not been saved with the WRITE command
(e.g. due to a power failure) this file can be renamed and loaded as a
normal board, schematic, library or designblock file, repectively.
<p>
The auto backup interval can be set in the <a href=#16>backup dialog</a>.


<a name=405>
<h1>File Locking</h1>
EAGLE supports a simple file locking mechanism.
All files loaded in an EAGLE drawing editor or the text editor are locked for writing by default.
The lock is released as soon as the editor is closed or another file is loaded.
<p>
The locking mechanism uses a lock file named <i>.file.lck</i>
where <i>file</i> is the name of the file to be locked.
<p>
If an already locked file should be loaded, EAGLE offers several choices how to proceed,
like save the file with a different name, retry to load, delete or ignore the lock.
<p>
Retry can be used after the lock owner has closed the file.
<p>
Deleting the lock may fail depending on the file access rights you have for the lock file.
It's advisable to inform the lock owner in case you deleted his lock.
The delete option is also useful, if the lock file remained, for example after an unintended power failure.
<p>
If you decide to ignore the lock, you can edit the file, but you have to save it with a different
name. This option is convenient, if you do not intend to change the file but just want to
try or check something.
<p>
Locking is not applicable for the CAM processor and for read-only files loaded.
<p>
Locking can be switched off in the Control Panel menu Options / 'Backup / Locking' or with the
<a href=#116>SET</a> command.
If the locking is switched off, EAGLE respects locks from other users with locking enabled
(and reports this if necessary). It just doesn't create own locks.
The setting is stored in the eaglerc user file.


<a name=406>
<h1>Forward&amp;Back Annotation</h1>
A schematic and board file are logically interconnected through automatic
Forward&amp;Back Annotation. Normally there are no special things to be
considered about Forward&amp;Back Annotation. This section, however, lists all of the
details about what exactly happens during f/b activities:
<ul>
<li>When adding a new part to a schematic, the part's footprint is added
to the board at the lower left corner of the drawing.
If the part contains power pins (pins with Direction "Pwr") the related
pads will be automatically connected to their power signals.
<li>When deleting a part from a schematic drawing, the part's footprint is
deleted from the board. Any wires that were connected to that footprint
are left unchanged. This may require additional vias to be set in
order to keep signals connected. These vias will <b>not</b> be set automatically!
The ratsnest will be re-calculated for those signals that were connected
to the removed footprint.
<li>When deleting a part from a board drawing, all of the gates contained
in that part will be deleted from the schematic. Note that this may
affect more than one sheet, if the gates were placed on different
sheets!
<li>After an operation that removes a pad from a signal (or adds it to a
signal) that has a polygon, the display of the connections to that polygon
may be incorrect. In such a case the <a href=#104>RATSNEST</a>
command will recalculate the polygon to show the correct Thermal/Annulus symbols.
The same applies to Undo/Redo operations that involve pads connected
to signals with polygons.
<li>A PinSwap or GateSwap operation in the schematic will make all the
necessary changes to the wires of the board. However, after this
operation the wires may overlap or violate minimum distance rules.
Therefore the user should take a look at these wires and modify them
with Move, Split, Change Layer etc.
<li>To make absolutely sure that a board and schematic belong to each
other (and are therefore connected via Forward&amp;Back Annotation)
the two files must have the same file name (with extensions .brd and .sch)
and must be located in the same directory!
<li>The Replace command checks whether all pads in the old footprint which
have been assigned to pins will also be present in the new footprint,
regardless whether they are connected to a signal or not.
<li>When the pins of two parts in the schematic are directly overlapping
(and thus connected without a visible net wire), a net wire will be
generated when these parts are moved away from each other.
This is done to avoid unnecessary ripup of signal wires in the board.
</ul>


<a name=407>
<h1>Consistency Check</h1>
In order to use Forward&amp;Back Annotation a board and schematic
must be consistent, which means they must contain an equivalent set of
parts/elements and nets/signals.
<p>
Normally a board and schematic will always be consistent as long as they
have never been edited separately (in which case the message
<i>"No Forward&amp;Back Annotation will be performed!"</i>
will have warned you).
<p>
When loading a pair of board and schematic files the program will check
some consistency markers in the data files to see if these two files are
still consistent. If these markers indicate an inconsistency, you will be
offered to run an <a href=#55>Electrical Rule Check</a> (ERC),
which will do a detailed cross-check on both files.
<p>
If this check turns out positive, the two files are marked as consistent
and Forward&amp;Back Annotation will be activated.
<p>
If the two files are found to be inconsistent the ERC protocol file will
be brought up in a dialog and Forward&amp;Back Annotation will
<b>not</b> be activated.
<p>
<b>Please do not be alarmed if you get a lot
of inconsistency messages. In most cases fixing one error (like renaming
a part or a net) will considerably reduce the number of error messages you get in the next
ERC run.</b>
<h2>Making a Board and Schematic consistent</h2>
To make an inconsistent pair of board and schematic files consistent, you
have to manually fix any inconsistency listed in the ERC protocol.
This can be done by applying editor commands like
<a href=#84>NAME</a>,
<a href=#136>VALUE</a>,
<a href=#97>PINSWAP</a>,
<a href=#110>REPLACE</a> etc.
After fixing the inconsistencies you must use the
<a href=#55>ERC</a> command again to check the files and
eventually activate Forward&amp;Back Annotation.
<h3>Note on Attributes:</h3>
Use <a href=#36>ATTRIBUTE</a> for creating consistent names and values again.
If there are attributes that are defined in the library, it might be helpful to use the
<a href=#110>REPLACE</a> command in order to replace such components and update
the attribute information.
<h3>Note on Package variants:</h3>
Several approaches:
<ul>
<li>Use the <a href=#110>REPLACE</a> command in the layout editor in order to
exchange the package with a definition that matches the package used in the schematic.</li>
<li>Exchange of a whole device in the schematic editor with the <a href=#110>REPLACE</a>
command or replacement of the components with a package definition used in the layout editor.
Please take care on attributes, as well (see above).</li>
<li>Change the package variant, if any, with <a href=#41>CHANGE PACKAGE</a>
in the schematic editor.</li>
</ul>
<h3>Tolerated part/element and net/signal deviations</h3>
Beside elements without Pads or Smds EAGLE tolerates also additional elements with Pads/Smds
as long as they are not connected to any signal.
Signals without net counterpart are tolerated as long as they have no connection to a Pad/Smd
(this is useful for wires in a copper layer without electrical meaning).


<a name=408>
<h1>Limitations</h1>
The following actions are not allowed in a board when Back Annotation
is active (i.e. the schematic is loaded, too):
<ul>
<li>adding or copying an element that contains Pads or Smds
<li>deleting an airwire
<li>defining connections with the Signal command
<li>pasting from a board into a board, if the pasted objects contain
elements with Pads or Smds, or Signals with connections
</ul>
If you try to do one of the above things, you will receive a message
telling you that this operation cannot be backannotated. In such a
case please do the necessary operations in the schematic (they will
then be forward annotated to the board). If you absolutely have to
do it in the board, you can close the schematic window and then do
anything you like inside the board. In that case, however, you risk loosing consistency.


<a name=409>
<h1>EAGLE Editions - License</h1>
EAGLE is available in different editions to fit various user requirements.<br><br>
See this page for details: <a href="https://www.autodesk.com/compare/eagle-vs-eagle-premium">
    www.autodesk.com/compare/eagle-vs-eagle-premium</a>

</body>
</html>
