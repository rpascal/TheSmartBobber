#usage "<qt>nobr><b>Exports the board to Ansys Neutral File Format (.ANF)</b><p>"
       "* SiWave.ULP Written by Burak Kelleci<br>"
       "* Based on HyprLynx.ULP Written by Frank Hoffman of LLOYD I/O INC<br>"
       "* Copyright (c) 2017<br>"
       "<author>kellecib@hotmail.com</author>"
       "<p>"
       "*  1 sided boards use layer 16<br>"
       "*  2 sided boards use layers 1 and 16<br>"
       "*  4 layer boards use layers 1,2 and 15, 16<br>"
       "*  6 layer boards use layers 1,2,3 and 14,15,16<br>"
       "*  8 layer boards use layers 1,2,3,4 and 13,14,15,16<br>"
       "* 10 layer boards use layers 1,2,3,4,5 and 12,13,14,15,16<br>"
       "* 12 layer boards use layers 1,2,3,4,5,6 and 11,12,13,14,15,16<br>"
       "* 14 layer boards use layers 1,2,3,4,5,6,7 and 10,11,12,13,14,15,16<br>"
       "* 16 layer boards use layers 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16<br>"
       "* <br>";


// Version 1.0  : Initial Version

string Version    = "Version 1.00 2017";

string headerline = "# Exports the board to Ans Neutral File Format (.ANF)";
string authorline = "# SiWave.ULP Written by Burak Kelleci Copyright (c) 2017";

//***********************************************
// Definitions of yes and no!  Do not modify!
char yes = 1;  // yes must be different from no.
char no  = 0;  // no must be zero (0)
//********************************************************************************************
//********************************************************************************************
//********************************************************************************************
// USER MODIFYABLE DATA

// Generate Files Options:
char GenerateComponentFile = yes;    // Generate the Component File  ('yes'/'no')
char GenerateSiWaveFile = yes;       // Generate the SiWave File  ('yes'/'no')

// Generate Component Types Options:
char UseComponentTypes = yes;        // Devices Q, T, U, IC, C, D, L, R, BD, etc. ('yes'/'no')
char IncludePinPlateComponents = no;	// Devices except IC, U, C, R, L, D, Q are also listed ('yes'/'no')

// Generate Unconnected Component Pins:
char GenerateNCPins = no;       // Generate the Unconnected Component Pins  ('yes'/'no')
char ConnectNCPinstoDUMMY = yes; // Connect to all unconnected component pinds to the "DUMMY" node
string dummyNet = "DUMMY";

// Component Value Change Options:
char TruncateComponentValues = yes;   // Truncate ".1uf 50v" to ".1uf" ('yes'/'no')

// Board Thickness AND Stack Up Options:
char UseBoardStackUp = yes;         // Use board thickness data   ('yes'/'no')
real board_thickness = 1.6000;      // Board Thickness, if 0: use fixed layer sizes else calc layer thicknesses in mm

// NETS that aren't signals but are copper are exported as a net named ComNet
string ComNet = "N$ComNet";

// Copper Value Options:
real zerooz = 0.0000;               // zero copper thickness in mm
real halfoz = 0.0175;               // 0.5 oz copper thickness in mm
real oneoz  = 0.0350;               // 1.0 oz copper thickness in mm
real twooz  = 0.0700;               // 2.0 oz copper thickness in mm
// Copper Layer Thickness for Each Layer of Copper
real copper_thickness[] = {0.0,  halfoz,halfoz,halfoz,halfoz,halfoz,halfoz,
                                 halfoz,halfoz,halfoz,halfoz,halfoz,halfoz,
                                 halfoz,halfoz,halfoz,halfoz}; // 1st number is not used (no layer 0)
// Copper Layer Plating Thickness for Each Layer of Copper.
// Top and Bottom are used most often.
real copper_plating[]  = {0.0,  halfoz,zerooz,zerooz,zerooz,zerooz,zerooz,
                                zerooz,zerooz,zerooz,zerooz,zerooz,zerooz,
                                zerooz,zerooz,zerooz,halfoz}; // 1st number is not used (no layer 0)
string metal_material = "copper";								

// Dielectric Value Options:
real dicons = 4.8;           // default dielectric constant
real dit1ly = 1.5500;        // dielectric thickness for 1 sided board
real dit2ly = 1.5200;        // dielectric thickness for 2 sided board
real ditmly = 0.5000;        // dielectric thickness for multilayered boards
real dielectric_constant[]  = {  dicons,dicons,dicons,dicons,dicons,dicons,dicons,dicons,dicons};
real dielectric_thickness[] = {  dit1ly,dit2ly,ditmly,ditmly,ditmly,ditmly,ditmly,ditmly,ditmly};
string dielectric_material = "FR4_epoxy";
real dielectric_conductivity = 0.0;
real dielectric_permittivity = 0.0;
real dielectric_permeability = 0.0;


// Special Wire Width Options:
real RectOutlineWireWidth = 0.001;  // Rectangle outline wire width in inches
real HoleOutlineWireWidth = 0.001;  // Holes outline wire width in inches

// Precision of board components to accurately draw and locate.
//  (After the decimal '.' point.)
int precision_of_perimeter = 5;     // board perimeter dimension precision
int precision_of_layers = 6;        // layer thickness precision
int precision_of_pads = 4;          // pad/smd size precision
int precision_of_nets = 5;          // pin/via/segment/width precision


//********************************************************************************************
//********************************************************************************************
//********************************************************************************************
// DO NOT MODIFY ANYTHING BELOW THIS LINE //

int index[];                // sorting index array (indirect)

// pad info
int ISAPAD = 0;                   // through hole pad
int ISASMD = 1;                   // surface mount device pad
int ISAVIA = 18;                  //

// *** SiWave pad shapes ***
int OVALROUND  = 0;  // '0' means oval or round (pad_sx=pad_sy if round)
int RECTSQUARE = 1;  // '1' means rectangular or square (pad_sx=pad_sy if square)
int OBLONG     = 2;  // '2' means oblong (oblong shape is a rectangular with rounded corners)

string PadShapes[];               // list of hyp's pad shapes
int    Total_Pads = 0;            // total pads
int    pad_type[];                // pad types (ISAPAD,ISASMD)
int    pad_layer[];               // 0 = Pad, 1 or 16 = SMD, 18 = Via
int    pad_shape_Top_rnds[];      // hyperlynx type OVALROUND, RECTSQUARE, OBLONG
int    pad_shape_Inner[];         // hyperlynx type OVALROUND, RECTSQUARE, OBLONG
int    pad_shape_Bott[];          // hyperlynx type OVALROUND, RECTSQUARE, OBLONG
real   pad_angle_end[];           // Pad rotation or Via End layer (Vias can not rotate!)
int    pad_diameter_Top_or_dx[];
int    pad_diameter_Inner[];
int    pad_diameter_Bott[];
int    pad_dy_elong_start[]; // SMD-dy, Pad-Elongation, Via Stack-Start
int    pad_drill[];

string padStackList = "#\ttype\tlayer\tTop_rnd\tInner\tBott\tang_end\tdx_T\tdx_I\tdx_B\tdy_el\tdril\n";

// copper layer info
string LayerNames[];        // layer names
int copp_lookup[]     = {0, 1,16, 2,15, 3,14, 4,13, 5,12, 6,11, 7,10, 8,9 };
int copp_used_layer[];
int Total_Layers;           // total number of used layers
int layer_counter;          // layer counter
real Total_Board_Thickness; // calculated total board thickness
real elevation;		 	 	// Calculated Elevation
int LayerInx[];
int LayerInxCounter;

string SignalNames[];        // signal names
int TotalSignalNumber;

string ComponentInfo[];      // Component Pad Connection Information
string ComponentInfoName[];  // Component Pad Connection Information
string ComponentTemp;
int ComponentCounter = 1;
int ComponentCounterInx = 1;

/* -----  Eagle HELP --------------------------------
PAD_SHAPE_SQUARE       square
PAD_SHAPE_ROUND        round
PAD_SHAPE_OCTAGON      octagon
PAD_SHAPE_LONG         long
PAD_SHAPE_OFFSET       offset
PAD_SHAPE_ANNULUS      annulus (only in Supply-Layer)
PAD_SHAPE_THERMAL      thermal (only in Supply-Layer)
-------------------------------------------------- */

// define the HyperLynx Pad Shapes
PadShapes[ PAD_SHAPE_SQUARE ]       = "R";       // anf's square and rectangle shape
PadShapes[ PAD_SHAPE_ROUND ]        = "E";       // anf's round and oval shape
PadShapes[ PAD_SHAPE_OCTAGON ]      = "E";       // anf's octagon is a round shape
PadShapes[ PAD_SHAPE_LONG ]         = "O";       // anf's oblong, rectangle with rounded corners
PadShapes[ PAD_SHAPE_OFFSET ]       = "E";       // anf's round and oval shape


// ***************************************************************************
// layers

// This routine counts visible layers and stores the name in an internal table
// Layer names beginning with '$' have the leading '$' striped.
// This routine is called from a loop
void CountLayers(UL_LAYER L) {
  if ( ( L.number >= 1 ) && ( L.number <= 16  ) ) {
    if ( strchr( L.name, '$' ) == 0 ) {
      LayerNames[L.number] = strsub( L.name, 1 );
    }
    else {
      LayerNames[L.number] = L.name;
    }
    if (L.visible) {
      layer_counter++;
      if (L.used) copp_used_layer[L.number] = 1;
    }
  }
}

// This routine writes out the layer names as signal layers or power planes
// It also writes out the dielectric layer info when needed
// This routine is called from a loop
string layernam; // layer name buffer
void PrintLayer(UL_LAYER L) {
  real diele_thickness;   // calculated dielectric thickness
  real copp_thickness;    // calculated total copper thickness
  int i;                  // loop counter
  if (L.visible) {
    if ( L.number >= 1 && L.number <= 16 ) {
/*
	<Layer Number> <Layer Name> METAL/DIELECTRIC/WIREBOND <Thickness in Mils> "<Type>" <Elevation> <Color>
	
	<Type> : air, copper, FR4_epoxy
	
*/
      if (board_thickness) {
        Total_Board_Thickness = board_thickness;
        copp_thickness = 0.0;
        for (int i = 1; i <= Total_Layers; i++ ) {
           copp_thickness += copper_thickness[copp_lookup[i]] + copper_plating[copp_lookup[i]];
        }
        if (Total_Layers <= 2 )  diele_thickness = ( board_thickness - copp_thickness );
        else                     diele_thickness = ( board_thickness - copp_thickness ) / ( real(Total_Layers) - 1.00 );
      }
      else {
        diele_thickness = dielectric_thickness[Total_Layers/2];
        copp_thickness = 0.0;
        for (int i = 1; i <= Total_Layers; i++ ) {
          copp_thickness += copper_thickness[copp_lookup[i]] + copper_plating[copp_lookup[i]];
        }
        if (Total_Layers <= 2 ) Total_Board_Thickness = copp_thickness + diele_thickness;
        else                    Total_Board_Thickness = copp_thickness + (diele_thickness * ( real(Total_Layers) - 1.00 ));
      }
	  
	  if ( L.number == 1){
		elevation = Total_Board_Thickness;
        printf("%d `UNNAMED_1` DIELECTRIC 0.0000000000000000e+00 \"air\" %6.*f 0xc0c0c0x\n",1,precision_of_layers, elevation);
		LayerInxCounter = 2;
	  }
	  if ( L.number <= 16){
		elevation -= copper_thickness[L.number] + copper_plating[L.number];
	  }
	  
		LayerInx[L.number] = LayerInxCounter;
        printf("%d `%s` METAL %6.*f \"%s\" %4.*f 0x%08x\n",
			  LayerInx[L.number], L.name,
              precision_of_layers, copper_thickness[L.number] + copper_plating[L.number],
			  metal_material,
			  precision_of_layers, elevation,
			  palette(L.color));

	  if ( L.number < 16){
		elevation -= diele_thickness;
		
        printf("%d `D%d` DIELECTRIC %6.*f \"%s\" %4.*f 0xc0c0c0\n",
			  LayerInx[L.number]+1, L.number,
              precision_of_layers, diele_thickness,
			  dielectric_material,
			  precision_of_layers, elevation);
			  LayerInxCounter=LayerInxCounter+2;
	  }
	  if ( L.number == 16){
		printf("%d `UNNAMED_1` DIELECTRIC 0.0000000000000000e+00 \"air\" %6.*f 0xc0c0c0x\n",LayerInx[L.number]+2,precision_of_layers, elevation);
	  }
      layer_counter++;
    }
  }
}



// ***************************************************************************
// pads

int search_A_Pad( int apad_type, int apad_layer,
                  int apad_shape_Top_rnds, int apad_shape_Inner, int apad_shape_Bott,
                  real apad_angle_end,
                  int apad_dx_Top, int apad_dx_Inner, int apad_dx_Bott,
                  int apad_dy_elong_start,
                  int apad_dril ) {
  int found = 0;
  for ( int i = 1; i <= Total_Pads; i++ ) {
    if ( pad_type[i]                == apad_type &&
         pad_layer[i]               == apad_layer &&
         pad_shape_Top_rnds[i]      == apad_shape_Top_rnds &&
         pad_shape_Inner[i]         == apad_shape_Inner &&
         pad_shape_Bott[i]          == apad_shape_Bott &&
         pad_angle_end[i]           == apad_angle_end &&
         pad_diameter_Top_or_dx[i]  == apad_dx_Top &&
         pad_diameter_Inner[i]      == apad_dx_Inner &&
         pad_diameter_Bott[i]       == apad_dx_Bott &&
         pad_dy_elong_start[i]      == apad_dy_elong_start&&
         pad_drill[i]               == apad_dril )
      {
      found = i;
      break;
    }
  }
 return( found);
}

// Search Signal Number
int search_Signal_Number( string netname ) {
  int found = 0;
  for ( int i = 1; i <= TotalSignalNumber; i++ ) {
    if ( strstr( SignalNames[i],netname )  != -1)
      {
      found = i;
      break;
    }
  }
 return(found);
}

// This routine inserts a pad of known type and size into the pad table
// The returned value reflects the current number of pads in the table
// If the pad size already exists, the pad is not inserted

void Insert_A_Pad( int apad_type, int apad_layer,
                  int apad_shape_Top_rnds, int apad_shape_Inner, int apad_shape_Bott,
                  real apad_angle_end,
                  int apad_dx_Top, int apad_dx_Inner, int apad_dx_Bott,
                  int apad_dy_elong_start,
                  int apad_dril ) {

  int fnd = search_A_Pad( apad_type, apad_layer, apad_shape_Top_rnds, apad_shape_Inner, apad_shape_Bott, apad_angle_end, apad_dx_Top, apad_dx_Inner, apad_dx_Bott, apad_dy_elong_start, apad_dril);
  if (fnd == 0) {
    Total_Pads++;
    pad_type[Total_Pads]               = apad_type;
    pad_layer[Total_Pads]              = apad_layer;
    pad_shape_Top_rnds[Total_Pads]     = apad_shape_Top_rnds;
    pad_shape_Inner[Total_Pads]        = apad_shape_Inner;
    pad_shape_Bott[Total_Pads]         = apad_shape_Bott;
    pad_angle_end[Total_Pads]          = apad_angle_end;
    pad_diameter_Top_or_dx[Total_Pads] = apad_dx_Top;
    pad_diameter_Inner[Total_Pads]     = apad_dx_Inner;
    pad_diameter_Bott[Total_Pads]      = apad_dx_Bott;
    pad_dy_elong_start[Total_Pads]     = apad_dy_elong_start;
    pad_drill[Total_Pads]              = apad_dril;
  }
  return;
}

// This routine finds a pad of a known type and size and returns the ID
// of the pad (internal number) that is used to identify the pad.

int Find_A_Pad( int apad_type, int apad_layer,
                int apad_shape_Top_rnds, int apad_shape_Inner, int apad_shape_Bott,
                real apad_angle_end,
                int apad_dx_Top, int apad_dx_Inner, int apad_dx_Bott,
                int apad_dy_elong_start,
                int apad_dril ) {
  int fnd = search_A_Pad( apad_type, apad_layer, apad_shape_Top_rnds, apad_shape_Inner, apad_shape_Bott, apad_angle_end, apad_dx_Top, apad_dx_Inner, apad_dx_Bott, apad_dy_elong_start, apad_dril);
  return( fnd );
}

// This routine finds the HyperLynx shape form of eagle shape
int SmdRoundness(int r, int dx, int dy) {
  if (r == 100 && dx == dy)	return 1;   // round
  if (r == 100 && dx != dy)	return 0;   // oval
  if (r == 0) return 0;   // rect or square
  return 2;                 // oblong
}


// Insert a pin on in a list of associated connected contacts
int AssPinCount = 0;  // Number of associated Contacts
string AssTabEname[];  // Element Name
string AssTabCname[];  // Contact Name
int AssTabLenEname[];  // Element Name Length
int AssTabLenCname[];  // Contact Name Length
int InsertAssocatedPin( string ename, string cname ) {
  int lenofename,lenofcname;
  lenofename = strlen(ename);
  lenofcname = strlen(cname);
  if ( AssPinCount > 0 ) {
    for ( int i = 0; i < AssPinCount; i++ ) {
      if ( lenofename == AssTabLenEname[i] )
        if ( lenofcname == AssTabLenCname[i] )
          if ( strstr( AssTabEname[i], ename ) != -1 )
            if ( strstr( AssTabCname[i], cname ) != -1 ) return( AssPinCount );
    }
  }
  AssTabEname[AssPinCount] = ename;
  AssTabCname[AssPinCount] = cname;
  AssTabLenEname[AssPinCount] = lenofename;
  AssTabLenCname[AssPinCount] = lenofcname;
  AssPinCount++;
  return( AssPinCount );
}

int FindAssocatedPin( string ename, string cname ) {
  int lenofename,lenofcname;
  lenofename = strlen(ename);
  lenofcname = strlen(cname);
  if ( AssPinCount > 0 ) {
    for ( int i = 0; i < AssPinCount; i++ ) {
      if ( lenofename == AssTabLenEname[i] )
        if ( lenofcname == AssTabLenCname[i] )
          if ( strstr( AssTabEname[i], ename ) != -1 )
            if ( strstr( AssTabCname[i], cname ) != -1 ) return( AssPinCount );
    }
  }
  return( 0 );
}

// write a divider
void printdivider( void ) {
  printf("#**********************************************************************\n");
  return;
}

// write a section header with dividers
void printheader(string hs) {
  printdivider();
  printf("# %s\n#\n",hs);
  return;
}

// truncate trailing zeros and print value
void TruncateTrailingZeros( real value, int prec ) {
  string num;
  int nlen;
  sprintf( num, "%1.*f", prec, value );
  nlen = strlen( num );
  if ( nlen > 0 ) {
    while ( num[ nlen-1 ] == '0' ) {
      // truncate with a null
      num[ nlen-1 ] = 0;
      // recalc string length
      nlen = strlen( num );
      if ( nlen == 0 )  break;
    }
  }
  printf("%s",num);
  return;
}

// ***************************************************************************
// board
//
// This is the MAIN() function of this ULP

if (board) board(B) {

  int ispolyfill = 0;
  int cntpol = 0;
  int cntsignal = 1;
  B.signals(S) {
    S.polygons(P) {
      cntpol++;
      if (!ispolyfill) {
        P.fillings(F) {
          ispolyfill = 1;
          break;
        }
      }
      else break;
    }
  }
  if (!ispolyfill && cntpol) {
    dlgMessageBox("!Polygons not filled, start RATSNEST.", "OK");
    string h;
    sprintf(h, "RATSNEST;\nRUN '%s'", argv[0]);
    exit(h);
  }

  if ( GenerateSiWaveFile == no ) {
    exit( EXIT_SUCCESS );
  }
  output( filesetext( B.name, ".ANF" ) ) {
    printdivider();
    printf("%s\n", headerline); 
    printf("# %s\n#\n", Version);
    printf("%s\n", authorline); 
    printf("# %s\n#\n", EAGLE_SIGNATURE);
    printf("# Ansys SiWave Board exported from:\n");
    printf("# %s\n", B.name);
    printf("# At %s\n#\n", t2string(time()));

    if (project.schematic) {
      printf("# Schematic is loaded.\n");
    }
    else {
      printf("# Schematic NOT is loaded.\n");
    }
	
    printf("# ---- BEGIN ANSOFT NEUTRAL FILE ----\n");
    printf("NAME `%s`\n",filesetext(filename(B.name),""));
	// UNITS <Normalization to meter> <Unit used by SiWave>
	// <Unit used by SiWave>: mm/mil/inch
    printf("UNITS 0.001 mm\n");

    // LAYER INFORMATION
    printheader("Thickness of Copper and Dielectric Layer Data");
    if ( UseBoardStackUp == yes ) {
      printf("B_LAYERS\n");
      layer_counter = 0;
      B.layers(L) CountLayers(L);
      Total_Layers = layer_counter; // remember active layers
      layer_counter = 0;
      B.layers(L) PrintLayer(L);
      printf("E_LAYERS\n");
      // TOTAL BOARD THICKNESS
      printf("# Total Board Thickness %6.4f mm\n\n",Total_Board_Thickness);
    }
    else {
      printf("# No PCB Thickness Data Generated !!! \n*\n\n");
    }
	
    int Pad_ID, Xpad, Ypad, EpadX, EpadY, TLaylimit, Blaylimit, AnglePad;
	string signalName;
	
    // handle all net contacts and vias
    B.signals(S) {
      S.vias(V) {
        Insert_A_Pad( ISAPAD, ISAVIA,
                      V.shape[1], V.shape[2], V.shape[16],
                      V.end,
                      V.diameter[1], V.diameter[2], V.diameter[16],
                      V.start,
                      V.drill );
      }
    }
    // handle all package pins
    B.elements(E) {
      E.package.contacts(C) {
        if (C.pad) {
          Insert_A_Pad( ISAPAD, ISAPAD,
                        C.pad.shape[1], C.pad.shape[2], C.pad.shape[16],
                        C.pad.angle,
                        C.pad.diameter[1], C.pad.diameter[2], C.pad.diameter[16],
                        C.pad.elongation,
                        C.pad.drill );
        }
        else if (C.smd) {
          if ( !C.smd.dx || !C.smd.dy) {
            string h;
            sprintf(h, "!<qt><nobr>Found a SMD-Pad with <b>dx</b> or <b>dy</b> = 0 (Zerro)<br>Pad <b>%s</b>'<br>Layer <b>%d</b><br>Coordinate <b>(%.4f %.4f)</b> mil<br>Package <b>%s.PAC</b><br>Element <b>%s</b><br>Library <b>%s.lbr</b><p><b>ULP aborted.</b></nobr></qt>",
                       C.name,
                       C.smd.layer,
                       u2mil(C.x), u2mil(C.y),
                       E.package.name,
                       E.name,
                       E.package.library
                   );
            dlgMessageBox( h, "OK");
            exit(0);
          }
          else {
            Insert_A_Pad( ISASMD, C.smd.layer,
                        SmdRoundness(C.smd.roundness,C.smd.dx,C.smd.dy), 0, 0,
                        C.smd.angle,
                        C.smd.dx, 0, 0,
                        C.smd.dy,
                        0 );
          }
        }
      }
    }
	

	// WRITE NETS
	/*
	<Net Number> <Net Name> 0 0:SignalNet/1:PowerNet <Net Color> 0
	Since Eagle does not differentiate power signals set to 0.
	*/
    printheader("Net Information");
    printf("B_NETS\n");
	cntsignal = 1;	
	 B.signals(S) {
		SignalNames[cntsignal] = S.name; // Signal Name

		if ( strstr( S.name,"GND" ) != -1 ) {
			printf(" %d %s 0 1 0x0493ff 0\n",cntsignal,S.name);
		}else if ( strstr( S.name,"VDD" ) != -1 ) {
			printf(" %d %s 0 1 0x0493ff 0\n",cntsignal,S.name);
		}else if ( strstr( S.name,"VCC" ) != -1 ) {
			printf(" %d %s 0 1 0x0493ff 0\n",cntsignal,S.name);
		}else{
			printf(" %d %s 0 0 0x0493ff 0\n",cntsignal,S.name);
		}
	  cntsignal++;
	}
	// Write unconnected Nets
    int AnyNets = no;
if (GenerateNCPins == yes){

	
if (ConnectNCPinstoDUMMY == yes){
	signalName = dummyNet;
	SignalNames[cntsignal] = signalName; // Signal Name
	printf(" %d %s 0 0 0x0493ff 0\n",cntsignal,signalName);
	cntsignal++;
}
else{
	B.elements(E) {
		  E.package.contacts(C) {
			if ( strlen(C.signal) == 0 ) {
			  if (C.pad) {
				Pad_ID = Find_A_Pad( ISAPAD, 0,
									 C.pad.shape[1], C.pad.shape[2], C.pad.shape[16],
									 C.pad.angle,
									 C.pad.diameter[1], C.pad.diameter[2], C.pad.diameter[16],
									 C.pad.elongation,
									 C.pad.drill );
				if ( Pad_ID ) {
				  if ( FindAssocatedPin( E.name, C.pad.name ) == 0 ) {
					sprintf(signalName,"NC_%s_%s",E.name,C.pad.name);
					SignalNames[cntsignal] = signalName; // Signal Name
					printf(" %d %s 0 0 0x0493ff 0 #%s\n",cntsignal,signalName,C.pad.signal);
					cntsignal++;
				  }
				  else {
					printf("# PIN %s.%s is part of an internal package net.\n",E.name,C.pad.name);
				  }
				}
				else {
				  printf("# Unregistered Pin Size!\n");
				}
			  }
			  if (C.smd) {
				Pad_ID = Find_A_Pad( ISASMD, C.smd.layer,
									 SmdRoundness(C.smd.roundness,C.smd.dx,C.smd.dy), 0, 0,
									 C.smd.angle,
									 C.smd.dx, 0, 0,
									 C.smd.dy,
									 0 );
				if ( Pad_ID ) {
				  if ( FindAssocatedPin( E.name, C.smd.name ) == 0 ) {
					sprintf(signalName,"NC_%s_%s",E.name,C.smd.name);
					SignalNames[cntsignal] = signalName; // Signal Name
					printf(" %d %s 0 0 0x0493ff 0 #%s\n",cntsignal,signalName,C.smd.signal);
					cntsignal++;
				  }
				  else {
					printf("# PIN %s.%s is part of an internal package net.\n",E.name,C.name);
				  }
				}
				else {
				  printf("# Unregistered Smd Size!\n");
				}
			  }
			}
		  }
		}
}
	
    // B.arcs(A) if ( ( A.layer >= 1 ) && ( A.layer <= 16 ) ) AnyNets = yes;
    B.circles(C) if ( ( C.layer >= 1 ) && ( C.layer <= 16 ) ) AnyNets = yes;
    B.rectangles(R) if ( ( R.layer >= 1 ) && ( R.layer <= 16 ) ) AnyNets = yes;
    B.wires(W) if ( ( W.layer >= 1 ) && ( W.layer <= 16 ) ) AnyNets = yes;

    if ( AnyNets == yes ) {
				SignalNames[cntsignal] = ComNet; // Signal Name
				printf(" %d %s 0 0 0x0493ff 0\n",cntsignal,SignalNames[cntsignal]);
	  }	
}
	TotalSignalNumber = cntsignal;
    printf("E_NETS\n");


    // PADSTACK CREATION OF PADS, SMDS, AND VIAS
    // create list of all the different pads and smds (vias are pads)
    printheader("Pads, Smds, and Via Library");
    
    // write out sorted list of the pads and smds
    if (Total_Pads) {
      printf("B_PADSTACKS\n");

	  /*
		<PadNumber> <PadName> "<Material>" <ViaPlating Ratio in percentage> 0 0 0 0
		B_PADSTACK_GEOM
			<Layer Number> E/R/O/
		  2 R 7.5000000000000000e+01 7.0000000000000000e+01 3.5000000000000000e+01 REGULAR 0.0000000000000000e+00 0.0000000000000000e+00
		E_PADSTACK_GEOM

		E: Circle <Diameter> <Diameter> 0 REGULAR/ANTI/THERMAL 0 0
		R: Rectangle <Width> <Length> 0 REGULAR/ANTI/THERMAL 0 0
		O: Oblong <Width> <Length> 0 REGULAR/ANTI/THERMAL 0 0
	  */
	  
	  
      string s;
      for (int i = 1; i <= Total_Pads; i++) {
        if (pad_layer[i] == 0) s = "ISAPAD";
        if (pad_layer[i] == 1 || pad_layer[i] == 16) s = "ISASMD";
        if (pad_layer[i] == 18) s = "ISAVIA";
        if (pad_type[i] == ISASMD) {
          printf("%d `SMD%03d` \"%s\" 0.2 0 0 0 0\n",i,i,metal_material);
          // smds are square, round or oblong

		  printf(" B_PADSTACK_GEOM\n");
          printf("  %d %s %5.*f %5.*f 0 REGULAR 0 0\n",
				   LayerInx[pad_layer[i]],PadShapes[pad_shape_Top_rnds[i]],
                   precision_of_pads, u2mm(pad_diameter_Top_or_dx[i]),
                   precision_of_pads, u2mm(pad_dy_elong_start[i])
                   );
		  printf(" E_PADSTACK_GEOM\n");
        }
        else if (pad_type[i] == ISAPAD) {
          printf("%d `THR%03d` \"%s\"  0.2 0 0 0 0\n", i, i,metal_material);  // *** 17.08.2005 count from 1 ***
		  printf(" B_PADSTACK_GEOM\n");
          // pads are on all layers, and have various shapes
          if (pad_layer[i] == ISAPAD) {

            // Pad layer Top
            if (pad_shape_Top_rnds[i] == OBLONG) {
              printf("  %d %s %5.*f %5.*f 0 REGULAR 0 0\n",
					  LayerInx[1],PadShapes[pad_shape_Top_rnds[i]],
                      precision_of_pads,u2mm(pad_diameter_Top_or_dx[i]),
                      precision_of_pads,u2mm(pad_diameter_Top_or_dx[i])
                      );
            }
            else {  // OVALROUND or RECTSQUARE
              printf("  %d %s %5.*f %5.*f 0 REGULAR 0 0\n",
					  LayerInx[1],PadShapes[pad_shape_Top_rnds[i]],
                      precision_of_pads,u2mm(pad_diameter_Top_or_dx[i]),
                      precision_of_pads,u2mm(pad_diameter_Top_or_dx[i])
                      );
            }

            // Pad layer Inner
			printf("  %d %s %5.*f %5.*f 0 REGULAR 0 0\n",
					LayerInx[pad_shape_Inner[i]]+1,PadShapes[pad_shape_Inner[i]],
					precision_of_pads,u2mm(pad_drill[i]),
					precision_of_pads,u2mm(pad_drill[i])
					);

            // Pad layer Bottom
            if (pad_shape_Bott[i] == OBLONG) {
              printf("  %d %s %5.*f %5.*f 0 REGULAR 0 0\n",
					  LayerInx[16],PadShapes[pad_shape_Top_rnds[i]],
                      precision_of_pads,u2mm(pad_diameter_Top_or_dx[i]),
                      precision_of_pads,u2mm(pad_diameter_Top_or_dx[i])
                      );
            }
            else {  // OVALROUND or RECTSQUARE
              printf("  %d %s %5.*f %5.*f 0 REGULAR 0 0\n",
					  LayerInx[16],PadShapes[pad_shape_Top_rnds[i]],
                      precision_of_pads,u2mm(pad_diameter_Top_or_dx[i]),
                      precision_of_pads,u2mm(pad_diameter_Top_or_dx[i])
                      );
            }
          }

          else if (pad_layer[i] == ISAVIA) {
            // Top - Inner - Bottom
            for (int vlay = pad_dy_elong_start[i]; vlay <= pad_angle_end[i]; vlay++) {
              // layer used and allowed?
              if (copp_used_layer[vlay]) {    // layer used for copper an visible
                if (vlay == 1){
                  printf("  %d %s %5.*f %5.*f 0 REGULAR 0 0\n",
                          LayerInx[vlay],PadShapes[pad_shape_Top_rnds[i]],
                          precision_of_pads,u2mm(pad_diameter_Top_or_dx[i] * pad_dy_elong_start[i]),
                          precision_of_pads,u2mm(pad_diameter_Top_or_dx[i])
                          );
                  printf("  %d %s %5.*f %5.*f 0 REGULAR 0 0\n",
                          LayerInx[vlay]+1,PadShapes[pad_shape_Top_rnds[i]],
                          precision_of_pads,u2mm(pad_drill[i]),
                          precision_of_pads,u2mm(pad_drill[i])
                          );
				}
                else if (vlay == 16)
                  printf("  %d %s %5.*f %5.*f 0 REGULAR 0 0\n",
                          LayerInx[vlay],PadShapes[pad_shape_Bott[i]],
                          precision_of_pads,u2mm(pad_diameter_Top_or_dx[i] * pad_dy_elong_start[i]),
                          precision_of_pads,u2mm(pad_diameter_Top_or_dx[i])
                          );

                else { // Always round inner layers
                  printf("  %d E %5.*f %5.*f 0 REGULAR 0 0\n",
                          LayerInx[vlay],
                          precision_of_pads,u2mm(pad_diameter_Inner[i]),
                          precision_of_pads,u2mm(pad_diameter_Inner[i])
                          );
                  printf("  %d E %5.*f %5.*f 0 REGULAR 0 0\n",
                          LayerInx[vlay]+1,
                          precision_of_pads,u2mm(pad_drill[i]),
                          precision_of_pads,u2mm(pad_drill[i])
                          );
				}
              }
            }
          }
		  printf(" E_PADSTACK_GEOM\n");
        }
      }
        printf("E_PADSTACKS\n");
    }
	

    // SIGNALS
    printheader("Nets");
    printf("B_GEOMETRY\n");
	int TotalPolyContour,PolyCount;
	int i = 1;
	int k = 1,l;
	int active;
	int x0, y0, first = 1, cutout;
	int partialPosPolyContourNum[];
	int partialNegPolyContourNum[];
	int partialPolyNum[];
	int partialNegPolyTotalNum[];
	int TotalNegPolyNum,TotalPosPolyNum,TotalPoly;
	int PolygonIndex;
	int x0Pos[],y0Pos[],x0Neg[],y0Neg[],x0Vec[],y0Vec[];
	int partialPolyType[];
	
    B.signals(S) {

    printf("# Begin of NET: %s\n",S.name);
		
	// Write Traces and Polygons
	
	/*
		T <Signal Number> <Layer> 2 <End Cap Style> ~ <Show Layer(0)/Net(1) Color>
			<x1> <y1> <width> <arc center x1> <arc center y1> <cw>
			<x2> <y2> <width>

		cw=0 : Counterclockwise cw=1 : Clockwise
		End Cap Style : R: Round F: Flat
	*/
      S.wires(W) {
        if (W.layer >= 1 && W.layer <= 16 ) {
          if (W.curve) {
			if (W.curve > 0) { // Arc is drawn counterclockwise
				printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f %5.*f %5.*f 0\n   %5.*f %5.*f %5.*f\n",
						search_Signal_Number(S.name), LayerInx[W.layer],
						precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),precision_of_nets,u2mm(W.width),
						precision_of_nets,u2mm(W.arc.xc), precision_of_nets,u2mm(W.arc.yc),
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2),precision_of_nets,u2mm(W.width)
						);
            }else{	// Arc is drawn clockwise
				printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f %5.*f %5.*f 1\n   %5.*f %5.*f %5.*f\n",
						search_Signal_Number(S.name), LayerInx[W.layer],
						precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),precision_of_nets,u2mm(W.width),
						precision_of_nets,u2mm(W.arc.xc), precision_of_nets,u2mm(W.arc.yc),
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2),precision_of_nets,u2mm(W.width)
						);
			}
          }
          else {
            printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f\n   %5.*f %5.*f %5.*f\n",
					search_Signal_Number(S.name), LayerInx[W.layer],
                    precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),precision_of_nets,u2mm(W.width),
                    precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2),precision_of_nets,u2mm(W.width)
                    );
          }
        }
      }
	  
	  PolygonIndex = 0;
      S.polygons(P) {
		  /*
			P <Signal Number> <Layer Number> <Number of Points> <Number of Cutouts> <Color Mode> <Polygon Index>

			Color Mode
				Layer Color : 0
				Net Color : 1
		*/
		//	Write Polygon Information
        printf("# Polygon Isolate=%5.*f Spacing=%5.*f Width=%5.*f Orphans=%s Pour=%s Thermals=%s Layer=%s Net=%s\n",
                precision_of_nets,u2mm(P.isolate),precision_of_nets,u2mm(P.spacing),
                precision_of_nets,u2mm(P.width),P.orphans ? "On" : "Off",
                P.pour == POLYGON_POUR_SOLID ? "SOLID" : "HATCH",
                P.thermals ? "On" : "Off",LayerNames[P.layer],S.name);

		// Check Polygon Fill
		if (P.pour == POLYGON_POUR_SOLID){
			// Count wire numbers for every positive partial polygon
			i = 1;
			do {
				TotalPolyContour = 0;
				active = 0;
				first = 1;
				P.contours(W, i) {
					active = 1;
					TotalPolyContour++;
					if (first){
						first = 0;
						x0Pos[i] = W.x1;
						y0Pos[i] = W.y1;
					}
				}
				partialPosPolyContourNum[i]=TotalPolyContour;
				i++;
				} while (active);

				TotalPosPolyNum = i - 1;
			// Count wire numbers for every negative partial poligon

			i = -1;
			do {
				TotalPolyContour = 0;
				active = 0;
				first = 1;
				P.contours(W, i) {
					active = 1;
					TotalPolyContour++;
					if (first){
						first = 0;
						x0Neg[-1*i] = W.x1;
						y0Neg[-1*i] = W.y1;
					}
				}
				partialNegPolyContourNum[-1*i]=TotalPolyContour;
				i--;
				} while (active);
			TotalNegPolyNum = (-1*i)-1;
			
			first = 1;
			i = 1;
			P.contours(W) {
			if (first) {
				// a new partial polygon is starting
				TotalPolyContour = 0;
				x0 = W.x1;
				y0 = W.y1;
				x0Vec[i] = W.x1;
				y0Vec[i] = W.y1;
				i++;
			}
			TotalPolyContour++;
			if (first)
				first = 0;
			else if (W.x2 == x0 && W.y2 == y0) {
				first = 1;
				partialPolyNum[i-1]=TotalPolyContour;
				}
			}
			TotalPoly = i - 1;
			
			// Determine Polygon Type
			for (i = 1; i <= TotalPoly; i++)
			{
				partialPolyType[i] = 0;
				for (k = 1; k <= TotalNegPolyNum; k++)
				{
					if(x0Vec[i]==x0Neg[k] && y0Vec[i]==y0Neg[k] ){
						partialPolyType[i] = 1;
					}				
				}
			}

			// Count negative polygons for every positive polygon
			k = 1;
			for (i = 1; i <= TotalPoly; i++)
			{
				partialNegPolyTotalNum[i] = 0;
				k=i+1;
				while(partialPolyType[k]!=0 && k <= TotalPoly)
				{
					partialNegPolyTotalNum[i]++;
					k++;
				}
				i=k-1;
			}
			
			first = 1;
			i = 1;
			cutout = 0;
			P.contours(W) {
			if (first) {
				// a new partial polygon is starting
				if (partialPolyType[i] == 0){
					if (cutout == 1){
						printf("   E_CUTOUTS\n");
						cutout = 0;
					}
					printf(" P %d %d %d %d 0 %d\n", search_Signal_Number(S.name), LayerInx[P.layer], partialPolyNum[i], partialNegPolyTotalNum[i], PolygonIndex);
					PolygonIndex++;
				}else{
					if (cutout == 0){
						printf("   B_CUTOUTS\n");
					}
					printf("     P %d\n",partialPolyNum[i]);
					cutout = 1;
				}
				x0 = W.x1;
				y0 = W.y1;
			}

			if (partialPolyType[i] == 0){
				printf("   %5.*f %5.*f #%d\n",precision_of_nets,u2mm(W.x1),precision_of_nets,u2mm(W.y1),i);
			}else{
				printf("       %5.*f %5.*f #%d\n",precision_of_nets,u2mm(W.x1),precision_of_nets,u2mm(W.y1),i);
			}
			if (first)
				first = 0;
			else if (W.x2 == x0 && W.y2 == y0) {
				first = 1;
				i++;
				}
			}
			if (cutout == 1){
				printf("   E_CUTOUTS\n");
				cutout = 0;
			}
			// Draw Wire Through Contours
			P.contours(W) {
				printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f\n   %5.*f %5.*f %5.*f\n",
						search_Signal_Number(S.name), LayerInx[W.layer],
						precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),precision_of_nets,u2mm(W.width),
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2),precision_of_nets,u2mm(W.width)
						);
			}
		}else{ // Hatch filling
			P.fillings(W) {
				printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f\n   %5.*f %5.*f %5.*f\n",
						search_Signal_Number(S.name), LayerInx[W.layer],
						precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),precision_of_nets,u2mm(W.width),
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2),precision_of_nets,u2mm(W.width)
						);
			}
			
		}
	}

	  // Write Vias
		// V <NetNumber> 1 <LayerNumber> <PadStackNumber> <x1> <y1> 0 (NULL) (NULL) (NULL) ~ 0 0
      S.vias(V) {
        Pad_ID = Find_A_Pad( ISAPAD, 18,
                             V.shape[1], V.shape[2], V.shape[16],
                             V.end,
                             V.diameter[1], V.diameter[2], V.diameter[16],
                             V.start,
                             V.drill );

        if ( Pad_ID ) {
          printf(" V %d 1 %d %d %5.*f %5.*f 0 (NULL) (NULL) (NULL) ~ 0 0\n",
                  search_Signal_Number(S.name),LayerInx[V.start],Pad_ID,
				  precision_of_nets,u2mm(V.x), precision_of_nets, u2mm(V.y)
                  );
          printf(" V %d 1 %d %d %5.*f %5.*f 0 (NULL) (NULL) (NULL) ~ 0 0\n",
                  search_Signal_Number(S.name),LayerInx[V.end],Pad_ID,
				  precision_of_nets,u2mm(V.x), precision_of_nets, u2mm(V.y)
                  );
        }
        else {
          printf("Unregistered Via Size!\n");
        }
      }
		
      S.contactrefs(C) {

	  //   X <NetNumber> 1 <LayerNumber> <PadStackNumber> <x1> <y1> <angle> <Name> <Designator> <PinNumber> ~ 0 0

        if (C.contact.pad) {
          Pad_ID = Find_A_Pad( ISAPAD, 0,
                              C.contact.pad.shape[1], C.contact.pad.shape[2], C.contact.pad.shape[16],
                              C.contact.pad.angle,
                              C.contact.pad.diameter[1], C.contact.pad.diameter[2], C.contact.pad.diameter[16],
                              C.contact.pad.elongation,
                              C.contact.pad.drill );
          if ( Pad_ID ) {
            Xpad = C.contact.pad.x;
            EpadX = Xpad;
            Ypad = C.contact.pad.y;
            EpadY = Ypad;
            TLaylimit = 1;
            Blaylimit = 16;
			AnglePad = C.contact.pad.angle;
			printf(" X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
                  search_Signal_Number(S.name),1,LayerInx[TLaylimit],Pad_ID,
				  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
				  C.element.package.name,C.element.name,C.contact.pad.name
                  );
			printf(" X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
                  search_Signal_Number(S.name),1,LayerInx[Blaylimit],Pad_ID,
				  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
				  C.element.package.name,C.element.name,C.contact.pad.name
                  );

			// Save Pin Information for CMP File
			sprintf(ComponentTemp," X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
                  search_Signal_Number(S.name),LayerInx[TLaylimit],LayerInx[TLaylimit],Pad_ID,
				  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
				  C.element.package.name,C.element.name,C.contact.pad.name
                  );
			ComponentInfo[ComponentCounter] = ComponentTemp;
			sprintf(ComponentTemp,"%s",C.element.name);
			ComponentInfoName[ComponentCounter] = ComponentTemp;
			ComponentCounter++;
          }
          else {
            printf("Unregistered Pin Size!\n");
          }
        }
        if (C.contact.smd) {
          Pad_ID = Find_A_Pad( ISASMD, C.contact.smd.layer,
                               SmdRoundness(C.contact.smd.roundness,C.contact.smd.dx,C.contact.smd.dy), 0, 0,
                               C.contact.smd.angle,
                               C.contact.smd.dx, 0, 0,
                               C.contact.smd.dy,
                               0 );
          if ( Pad_ID ) {
            Xpad = C.contact.smd.x;
            EpadX = Xpad;
            Ypad = C.contact.smd.y;
            EpadY = Ypad;
            TLaylimit = C.contact.smd.layer;
            Blaylimit = C.contact.smd.layer;
			AnglePad = C.contact.smd.angle;
			printf(" X %d 1 %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
                  search_Signal_Number(S.name),LayerInx[TLaylimit],Pad_ID,
				  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
				  C.element.package.name,C.element.name,C.contact.smd.name
                  );
				  
			// Save Pin Information for CMP File
			sprintf(ComponentTemp," X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
                  search_Signal_Number(S.name),LayerInx[TLaylimit],LayerInx[TLaylimit],Pad_ID,
				  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
				  C.element.package.name,C.element.name,C.contact.smd.name
                  );   // ** correct number while listing count from 1
			ComponentInfo[ComponentCounter] = ComponentTemp;
			sprintf(ComponentTemp,"%s",C.element.name);
			ComponentInfoName[ComponentCounter] = ComponentTemp;
			ComponentCounter++;

          }
          else {
            printf("Unregistered Smd Size!\n");
          }
        }
        // if a pad/smd was located for this contact
        // and a copper segment starts at this contact's x,y location,
        // then the copper segment is included on this net.
        if ( Pad_ID ) {
          // Package element copper information
          // circles
          C.element.package.circles(A) {
            if ( ( A.layer >= 1 ) && ( A.layer <= 16 ) ) {
                printf("# %s has metal circles or isolation circles\n",C.element.name);
            }
          }
          // polygons
          C.element.package.polygons(P) {
            if ( ( P.layer >= 1 ) && ( P.layer <= 16 ) ) {
               printf("# %s has metal polygons\n",C.element.name);
            }
          }
          // rectangles
          C.element.package.rectangles(R) {
            if ( ( R.layer >= 1 ) && ( R.layer <= 16 ) ) {
              printf("# %s has metal rectangles\n",C.element.name);
            }
          }
          // Find any wires that connect to this pin/pad that are internal to the package
          // 1. build a table of all wires on the accepted layer
          int AnyPackageWiresCount = 0;
          int Wx1[], Wy1[], Wx2[], Wy2[], Wwid[], Wusedflag[],
              Wcurve[], Warcx1[], Warcx2[], Warcxc[], Warcy1[], Warcy2[], Warcyc[], Warcradius[],
              Wlayer ;
          C.element.package.wires(W) {
            // find all wires on the correct layer.
            if ( ( W.layer >= TLaylimit ) && ( W.layer <= Blaylimit ) ) {
              Wx1[AnyPackageWiresCount] = W.x1;
              Wy1[AnyPackageWiresCount] = W.y1;
              Wx2[AnyPackageWiresCount] = W.x2;
              Wy2[AnyPackageWiresCount] = W.y2;
              Wwid[AnyPackageWiresCount] = W.width;
              Wcurve[AnyPackageWiresCount] = W.curve;
              if (W.curve) {
                Warcx1[AnyPackageWiresCount] = W.arc.x1;
                Warcx2[AnyPackageWiresCount] = W.arc.x2;
                Warcxc[AnyPackageWiresCount] = W.arc.xc;
                Warcy1[AnyPackageWiresCount] = W.arc.y1;
                Warcy2[AnyPackageWiresCount] = W.arc.y2;
                Warcyc[AnyPackageWiresCount] = W.arc.yc;
                Warcradius[AnyPackageWiresCount] = W.arc.radius;
              }
              Wusedflag[AnyPackageWiresCount] = no;
              TLaylimit = W.layer;    // fix layer to first found layer on an accepted first layer
              Blaylimit = W.layer;    // fix layer to first found layer on an accepted first layer
              Wlayer = W.layer;       // fix the layer
              AnyPackageWiresCount++; // count one segment
            }
          }
          // 2. search for physically connected copper segments, even if out of order
          if ( AnyPackageWiresCount != 0 ) {
            for ( int woi = 0; woi < AnyPackageWiresCount; woi++ ) {
              if ( Wusedflag[woi] == no ) {
                // check either end of the segment
                if ( ( Wx1[woi] == Xpad ) && ( Wy1[woi] == Ypad ) ) {
                  Xpad = Wx2[woi]; // remember the end of this segment
                  Ypad = Wy2[woi]; // which must be the start of the next segment
                  Wusedflag[woi] = yes;
                  woi = 0; // start searching list from the beginning again
                }
                else if ( ( Wx2[woi] == Xpad ) && ( Wy2[woi] == Ypad ) ) {
                  Xpad = Wx1[woi]; // remember the end of this segment
                  Ypad = Wy1[woi]; // which must be the start of the next segment
                  Wusedflag[woi] = yes;
                  woi = 0; // start searching list from the beginning again
                }
              }
            }
          }
          // 3. write out all segments attached to the contact
          if ( AnyPackageWiresCount != 0 ) {
            for ( int woi = 0; woi < AnyPackageWiresCount; woi++ ) {
              if ( Wusedflag[woi] == yes ) {
                // write the segment
                if ( Wlayer >= 1 && Wlayer <= 16 ) {
				  if (Wcurve[woi]) {
					if (Wcurve[woi] > 0) { // Arc is drawn counterclockwise
						printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f %5.*f %5.*f 0\n   %5.*f %5.*f %5.*f\n",
								search_Signal_Number(S.name), LayerInx[Wlayer],
								precision_of_nets,u2mm(Warcx1[woi]), precision_of_nets,u2mm(Warcy1[woi]),precision_of_nets,u2mm(Wwid[woi]),
								precision_of_nets,u2mm(Warcxc[woi]), precision_of_nets,u2mm(Warcyc[woi]),
								precision_of_nets,u2mm(Warcx2[woi]), precision_of_nets,u2mm(Warcy2[woi]),precision_of_nets,u2mm(Wwid[woi])
								);
					}else{	// Arc is drawn clockwise
						printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f %5.*f %5.*f 1\n   %5.*f %5.*f %5.*f\n",
								search_Signal_Number(S.name), LayerInx[Wlayer],
								precision_of_nets,u2mm(Warcx1[woi]), precision_of_nets,u2mm(Warcy1[woi]),precision_of_nets,u2mm(Wwid[woi]),
								precision_of_nets,u2mm(Warcxc[woi]), precision_of_nets,u2mm(Warcyc[woi]),
								precision_of_nets,u2mm(Warcx2[woi]), precision_of_nets,u2mm(Warcy2[woi]),precision_of_nets,u2mm(Wwid[woi])
								);
					}
				  }
				  else {
					printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f\n   %5.*f %5.*f %5.*f\n",
							search_Signal_Number(S.name), LayerInx[Wlayer],
							precision_of_nets,u2mm(Wx1[woi]), precision_of_nets,u2mm(Wy1[woi]),precision_of_nets,u2mm(Wwid[woi]),
							precision_of_nets,u2mm(Wx2[woi]), precision_of_nets,u2mm(Wy2[woi]),precision_of_nets,u2mm(Wwid[woi])
							);
				  }
                }
                // write any contact pins or smds
                int OtherPad_ID;
                C.element.package.contacts(Q) {
                  // don't write out contacts at the original element contact location
                  if ( ( Q.x != EpadX ) || ( Q.y != EpadY ) ) {
                    // check if this element contact is at either end of the wire segment
                    if ( ( ( Q.x == Wx1[woi] ) && ( Q.y == Wy1[woi] ) ) ||
                         ( ( Q.x == Wx2[woi] ) && ( Q.y == Wy2[woi] ) ) ) {
                      // if a through hole pad
                      if (Q.pad) {
                        // find a pad on any layer
                        OtherPad_ID = Find_A_Pad( ISAPAD, 0,
                                                  Q.pad.shape[1], Q.pad.shape[2], Q.pad.shape[16],
                                                  Q.pad.angle,
                                                  Q.pad.diameter[1], Q.pad.diameter[2], Q.pad.diameter[16],
                                                  Q.pad.elongation,
                                                  Q.pad.drill );
                        if ( OtherPad_ID ) {
							printf(" X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
								  search_Signal_Number(S.name),1,LayerInx[TLaylimit],OtherPad_ID,
								  precision_of_nets,u2mm(Q.pad.x), precision_of_nets, u2mm(Q.pad.y),precision_of_nets, real(Q.pad.angle),
								  C.element.package.name,C.element.name,Q.pad.name
								  );
							printf(" X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
								  search_Signal_Number(S.name),1,LayerInx[Blaylimit],Pad_ID,
								  precision_of_nets,u2mm(Q.pad.x), precision_of_nets, u2mm(Q.pad.y),precision_of_nets, real(Q.pad.angle),
								  C.element.package.name,C.element.name,Q.pad.name
								  );
							InsertAssocatedPin( C.element.name, Q.pad.name );
                        }
                        else {
                          printf("# Unregistered Internal Package Pin Size!\n");
                        }
                      }
                      // if a smd pad
                      if (Q.smd) {
                        // smd pad must be on this layer
                        if ( Q.smd.layer == Wlayer ) {
                          // find a smd that matches
                          OtherPad_ID = Find_A_Pad( ISASMD, Q.smd.layer,
                                                    SmdRoundness(Q.smd.roundness,Q.smd.dx,Q.smd.dy), 0, 0,
                                                    Q.smd.angle,
                                                    Q.smd.dx, 0, 0,
                                                    Q.smd.dy,
                                                    0 );
                          if ( OtherPad_ID ) {
							printf(" X %d 1 %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
								  search_Signal_Number(S.name),LayerInx[TLaylimit],Pad_ID,
								  precision_of_nets,u2mm(Q.smd.x), precision_of_nets, u2mm(Q.smd.y),precision_of_nets, real(Q.smd.angle),
								  C.element.package.name,C.element.name,Q.smd.name
								  );
                            InsertAssocatedPin( C.element.name, Q.smd.name );
                          }
                          else {
                            printf("# Unregistered Smd Size!\n");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
	  

      printf("# End of Net: %s\n",S.name);
    }

if (GenerateNCPins== yes){
      printf("# Begin of Unconnected Nets\n");
    // Unconnected Component Pins are on their own special net

    // handle all unconnected package pins
    B.elements(E) {
      E.package.contacts(C) {
        if ( strlen(C.signal) == 0 ) {
          if (C.pad) {
            Pad_ID = Find_A_Pad( ISAPAD, 0,
                                 C.pad.shape[1], C.pad.shape[2], C.pad.shape[16],
                                 C.pad.angle,
                                 C.pad.diameter[1], C.pad.diameter[2], C.pad.diameter[16],
                                 C.pad.elongation,
                                 C.pad.drill );
            if ( Pad_ID ) {
              if ( FindAssocatedPin( E.name, C.pad.name ) == 0 ) {
                Xpad = C.pad.x;
                Ypad = C.pad.y;
				AnglePad = C.pad.angle;
				if(ConnectNCPinstoDUMMY == yes){
					signalName = dummyNet;
				}
				else{
					sprintf(signalName,"NC_%s_%s",E.name,C.pad.name);
				}
				printf(" X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
					  search_Signal_Number(signalName),1,LayerInx[TLaylimit],Pad_ID,
					  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
					  E.package.name,E.name,C.pad.name
					  );
				printf(" X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
					  search_Signal_Number(signalName),1,LayerInx[Blaylimit],Pad_ID,
					  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
					  E.package.name,E.name,C.pad.name
					  );
					  
				// Save Pin Information for CMP File
				sprintf(ComponentTemp," X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
					  search_Signal_Number(signalName),LayerInx[TLaylimit],LayerInx[TLaylimit],Pad_ID,
					  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
					  E.package.name,E.name,C.pad.name
					  );   // ** correct number while listing count from 1,
				ComponentInfo[ComponentCounter] = ComponentTemp;
				sprintf(ComponentTemp,"%s",E.name);
				ComponentInfoName[ComponentCounter] = ComponentTemp;
				ComponentCounter++;
              }
              else {
                printf("# PIN %s.%s is part of an internal package net.\n",E.name,C.pad.name);
              }
            }
            else {
              printf("# Unregistered Pin Size!\n");
            }
          }
          if (C.smd) {
            Pad_ID = Find_A_Pad( ISASMD, C.smd.layer,
                                 SmdRoundness(C.smd.roundness,C.smd.dx,C.smd.dy), 0, 0,
                                 C.smd.angle,
                                 C.smd.dx, 0, 0,
                                 C.smd.dy,
                                 0 );
            if ( Pad_ID ) {
              if ( FindAssocatedPin( E.name, C.smd.name ) == 0 ) {
                Xpad = C.smd.x;
                Ypad = C.smd.y;
				AnglePad = C.smd.angle;
				if(ConnectNCPinstoDUMMY == yes){
					signalName = dummyNet;
				}
				else{
					sprintf(signalName,"NC_%s_%s",E.name,C.smd.name);
				}
				printf(" X %d 1 %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
					  search_Signal_Number(signalName),LayerInx[TLaylimit],Pad_ID,
					  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
					  E.package.name,E.name,C.smd.name
					  );
					  
				// Save Pin Information for CMP File
				sprintf(ComponentTemp," X %d %d %d %d %5.*f %5.*f %5.*f %s %s %s ~ 0 0\n",
					  search_Signal_Number(signalName),LayerInx[TLaylimit],LayerInx[TLaylimit],Pad_ID,
					  precision_of_nets,u2mm(Xpad), precision_of_nets, u2mm(Ypad),precision_of_nets, real(AnglePad),
					  E.package.name,E.name,C.smd.name
					  );   // ** correct number while listing count from 1
				ComponentInfo[ComponentCounter] = ComponentTemp;
				sprintf(ComponentTemp,"%s",E.name);
				ComponentInfoName[ComponentCounter] = ComponentTemp;
				ComponentCounter++;
              }
              else {
                printf("# PIN %s.%s is part of an internal package net.\n",E.name,C.smd.name);
              }
            }
            else {
              printf("# Unregistered Smd Size!\n");
            }
          }
        }
      }
    }
	printf("# End of Unconnected Nets\n");
	
	
    // NETS that aren't signals but are copper are exported as a net named ComNet
    // Search for any common nets
    AnyNets = no;
    // B.arcs(A) if ( ( A.layer >= 1 ) && ( A.layer <= 16 ) ) AnyNets = yes;
    B.circles(C) if ( ( C.layer >= 1 ) && ( C.layer <= 16 ) ) AnyNets = yes;
    B.rectangles(R) if ( ( R.layer >= 1 ) && ( R.layer <= 16 ) ) AnyNets = yes;
    B.wires(W) if ( ( W.layer >= 1 ) && ( W.layer <= 16 ) ) AnyNets = yes;

    if ( AnyNets == yes ) {
    printf("# Begin of NET: %s\n",ComNet);

      // CIRCLES
      B.circles(C) {
        if ( ( C.layer >= 1 ) && ( C.layer <= 16 ) ) {
				printf(" P %d %d %d %d 0 %d\n", search_Signal_Number(ComNet), LayerInx[C.layer], 2, 0, PolygonIndex);
				PolygonIndex++;
				// <Start x> <Start y> <Center x> <Center y> <cw>
				printf("   %5.*f %5.*f %5.*f %5.*f 0\n",precision_of_nets,u2mm(C.x + C.radius),precision_of_nets,u2mm(C.y),
						precision_of_nets,u2mm(C.x),precision_of_nets,u2mm(C.y));
				printf("   %5.*f %5.*f\n",precision_of_nets,u2mm(C.x + C.radius),precision_of_nets,u2mm(C.y));

        }
      }

      // RECTANGLES
      B.rectangles(R) {
        if ( ( R.layer >= 1 ) && ( R.layer <= 16 ) ) {
				printf(" P %d %d %d %d 0 %d\n", search_Signal_Number(ComNet), LayerInx[R.layer], 4, 0, PolygonIndex);
			printf("   %5.*f %5.*f\n",precision_of_nets,u2mm(R.x1),precision_of_nets,u2mm(R.y1));
			printf("   %5.*f %5.*f\n",precision_of_nets,u2mm(R.x2),precision_of_nets,u2mm(R.y1));
			printf("   %5.*f %5.*f\n",precision_of_nets,u2mm(R.x2),precision_of_nets,u2mm(R.y2));
			printf("   %5.*f %5.*f\n",precision_of_nets,u2mm(R.x1),precision_of_nets,u2mm(R.y2));
        }
      }

      // WIRES
      B.wires(W) {
        if ( ( W.layer >= 1 ) && ( W.layer <= 16 ) ) {
          if (W.curve) {
            // ARCS
			if (W.curve > 0) { // Arc is drawn counterclockwise
				printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f %5.*f %5.*f 0\n   %5.*f %5.*f %5.*f\n",
						search_Signal_Number(ComNet), LayerInx[W.layer],
						precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),precision_of_nets,u2mm(W.width),
						precision_of_nets,u2mm(W.arc.xc), precision_of_nets,u2mm(W.arc.yc),
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2),precision_of_nets,u2mm(W.width)
						);
            }else{	// Arc is drawn clockwise
				printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f %5.*f %5.*f 1\n   %5.*f %5.*f %5.*f\n",
						search_Signal_Number(ComNet), LayerInx[W.layer],
						precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),precision_of_nets,u2mm(W.width),
						precision_of_nets,u2mm(W.arc.xc), precision_of_nets,u2mm(W.arc.yc),
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2),precision_of_nets,u2mm(W.width)
						);
			}
          }
          else {
            printf(" T %d %d 2 R ~ 0\n   %5.*f %5.*f %5.*f\n   %5.*f %5.*f %5.*f\n",
					search_Signal_Number(ComNet), LayerInx[W.layer],
                    precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),precision_of_nets,u2mm(W.width),
                    precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2),precision_of_nets,u2mm(W.width)
                    );
          }
        }
      }
      printf("# End of Net: %s\n",ComNet);
    } // end of copper as common net
	}
    printf("E_GEOMETRY\n");

    // BOARD OVERALL AREA DIMENSIONS
    // Writes the board dimensions found on layer 20
	
	int FaceNum = 0; // Number of Faces
	int NumPointsFace[]; // Number of points for every Face
	int NumPoints;
	string FaceCommand[];	// Output Commands
	int TotalCommand = 0;
	string tmpFace;
	
    // wires on the dimension layer
    B.wires(W) {
	if (W.layer == 20 ) {
		FaceNum++;
		NumPoints = 0;
        if (W.curve) {
          // arcs in the dimension layer
			if (W.curve > 0) { // Arc is drawn counterclockwise
				TotalCommand++;
				NumPoints++;
				sprintf(tmpFace,"  %5.*f %5.*f %5.*f %5.*f 0\n",
						precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),
						precision_of_nets,u2mm(W.arc.xc), precision_of_nets,u2mm(W.arc.yc)
						);
				FaceCommand[TotalCommand]=tmpFace;
				TotalCommand++;
				NumPoints++;
				sprintf(tmpFace,"  %5.*f %5.*f\n",
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2)
						);
				FaceCommand[TotalCommand]=tmpFace;
            }else{	// Arc is drawn clockwise
				TotalCommand++;
				NumPoints++;
				sprintf(tmpFace,"  %5.*f %5.*f %5.*f %5.*f 1\n",
						precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),
						precision_of_nets,u2mm(W.arc.xc), precision_of_nets,u2mm(W.arc.yc)
						);
				FaceCommand[TotalCommand]=tmpFace;
				TotalCommand++;
				NumPoints++;
				sprintf(tmpFace,"  %5.*f %5.*f\n",
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2)
						);
				FaceCommand[TotalCommand]=tmpFace;
			}
       }
        else {
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f\n",
				precision_of_perimeter,u2mm(W.x1),precision_of_perimeter,u2mm(W.y1));
			FaceCommand[TotalCommand]=tmpFace;
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f\n",
					precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2)
					);
			FaceCommand[TotalCommand]=tmpFace;
        }
		NumPointsFace[FaceNum]=NumPoints;
	  }
    }
    // rectangles on the dimension layer
    B.rectangles(R) {
      if (R.layer == 20 ) {
		FaceNum++;
		NumPoints = 0;
		TotalCommand++;
		NumPoints++;
		sprintf(tmpFace,"  %5.*f %5.*f\n",
				precision_of_nets,u2mm(R.x1), precision_of_nets,u2mm(R.y1)
				);
		FaceCommand[TotalCommand]=tmpFace;
		TotalCommand++;
		NumPoints++;
		sprintf(tmpFace,"  %5.*f %5.*f\n",
				precision_of_nets,u2mm(R.x2), precision_of_nets,u2mm(R.y1)
				);
		FaceCommand[TotalCommand]=tmpFace;
		TotalCommand++;
		NumPoints++;
		sprintf(tmpFace,"  %5.*f %5.*f\n",
				precision_of_nets,u2mm(R.x2), precision_of_nets,u2mm(R.y2)
				);
		FaceCommand[TotalCommand]=tmpFace;
		TotalCommand++;
		NumPoints++;
		sprintf(tmpFace,"  %5.*f %5.*f\n",
				precision_of_nets,u2mm(R.x1), precision_of_nets,u2mm(R.y2)
				);
		FaceCommand[TotalCommand]=tmpFace;
      }
    }
    // polygons on the dimension layer
    B.polygons(P) {
      if (P.layer == 20 ) {
		FaceNum++;
		NumPoints = 0;
        P.wires(W) {
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f\n",
					precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y1)
					);
			FaceCommand[TotalCommand]=tmpFace;
			x0=W.x2;
			y0=W.y2;
        }
		TotalCommand++;
		NumPoints++;
		sprintf(tmpFace,"  %5.*f %5.*f\n",
				precision_of_nets,u2mm(x0), precision_of_nets,u2mm(y0)
				);
		FaceCommand[TotalCommand]=tmpFace;
      }
    }
    // circles in the dimension layer
    B.circles(C) {
    if (C.layer == 20 ) {
		FaceNum++;
		NumPoints = 0;
		TotalCommand++;
		NumPoints++;
		sprintf(tmpFace,"  %5.*f %5.*f %5.*f %5.*f 0\n",
				precision_of_nets,u2mm(C.x + C.radius), precision_of_nets,u2mm(C.y),
				precision_of_nets,u2mm(C.x), precision_of_nets,u2mm(C.y)
				);
		FaceCommand[TotalCommand]=tmpFace;
		TotalCommand++;
		NumPoints++;
		sprintf(tmpFace,"  %5.*f %5.*f\n",
				precision_of_nets,u2mm(C.x + C.radius), precision_of_nets,u2mm(C.y)
				);
		FaceCommand[TotalCommand]=tmpFace;
      }
    }
    // package wires on the dimension layer
    B.elements(E) {
      E.package.wires(W) {
		if (W.layer == 20 ) {
			FaceNum++;
			NumPoints = 0;
			if (W.curve) {
			  // arcs in the dimension layer
				if (W.curve > 0) { // Arc is drawn counterclockwise
					TotalCommand++;
					NumPoints++;
					sprintf(tmpFace,"  %5.*f %5.*f %5.*f %5.*f 0\n",
							precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),
							precision_of_nets,u2mm(W.arc.xc), precision_of_nets,u2mm(W.arc.yc)
							);
					FaceCommand[TotalCommand]=tmpFace;
					TotalCommand++;
					NumPoints++;
					sprintf(tmpFace,"  %5.*f %5.*f\n",
							precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2)
							);
					FaceCommand[TotalCommand]=tmpFace;
				}else{	// Arc is drawn clockwise
					TotalCommand++;
					NumPoints++;
					sprintf(tmpFace,"  %5.*f %5.*f %5.*f %5.*f 1\n",
							precision_of_nets,u2mm(W.x1), precision_of_nets,u2mm(W.y1),
							precision_of_nets,u2mm(W.arc.xc), precision_of_nets,u2mm(W.arc.yc)
							);
					FaceCommand[TotalCommand]=tmpFace;
					TotalCommand++;
					NumPoints++;
					sprintf(tmpFace,"  %5.*f %5.*f\n",
							precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2)
							);
					FaceCommand[TotalCommand]=tmpFace;
				}
		   }
			else {
				TotalCommand++;
				NumPoints++;
				sprintf(tmpFace,"  %5.*f %5.*f\n",
					precision_of_perimeter,u2mm(W.x1),precision_of_perimeter,u2mm(W.y1));
				FaceCommand[TotalCommand]=tmpFace;
				TotalCommand++;
				NumPoints++;
				sprintf(tmpFace,"  %5.*f %5.*f\n",
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y2)
						);
				FaceCommand[TotalCommand]=tmpFace;
			}
			NumPointsFace[FaceNum]=NumPoints;
		  }
    }
      // package rectangles on the dimension layer
      E.package.rectangles(R) {
		  if (R.layer == 20 ) {
			FaceNum++;
			NumPoints = 0;
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f\n",
					precision_of_nets,u2mm(R.x1), precision_of_nets,u2mm(R.y1)
					);
			FaceCommand[TotalCommand]=tmpFace;
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f\n",
					precision_of_nets,u2mm(R.x2), precision_of_nets,u2mm(R.y1)
					);
			FaceCommand[TotalCommand]=tmpFace;
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f\n",
					precision_of_nets,u2mm(R.x2), precision_of_nets,u2mm(R.y2)
					);
			FaceCommand[TotalCommand]=tmpFace;
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f\n",
					precision_of_nets,u2mm(R.x1), precision_of_nets,u2mm(R.y2)
					);
			FaceCommand[TotalCommand]=tmpFace;
		  }
      }
      // package polygons on the dimension layer
      E.package.polygons(P) {
		  if (P.layer == 20 ) {
			FaceNum++;
			NumPoints = 0;
			P.wires(W) {
				TotalCommand++;
				NumPoints++;
				sprintf(tmpFace,"  %5.*f %5.*f\n",
						precision_of_nets,u2mm(W.x2), precision_of_nets,u2mm(W.y1)
						);
				FaceCommand[TotalCommand]=tmpFace;
				x0=W.x2;
				y0=W.y2;
			}
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f\n",
					precision_of_nets,u2mm(x0), precision_of_nets,u2mm(y0)
					);
			FaceCommand[TotalCommand]=tmpFace;
		  }
      }
      // package circles in the dimension layer
      E.package.circles(C) {
       if (C.layer == 20 ) {
		if (C.layer == 20 ) {
			FaceNum++;
			NumPoints = 0;
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f %5.*f %5.*f 0\n",
					precision_of_nets,u2mm(C.x + C.radius), precision_of_nets,u2mm(C.y),
					precision_of_nets,u2mm(C.x), precision_of_nets,u2mm(C.y)
					);
			FaceCommand[TotalCommand]=tmpFace;
			TotalCommand++;
			NumPoints++;
			sprintf(tmpFace,"  %5.*f %5.*f\n",
					precision_of_nets,u2mm(C.x + C.radius), precision_of_nets,u2mm(C.y)
					);
			FaceCommand[TotalCommand]=tmpFace;
		  }
      }
    }
}
	// Write Board Dimensions
	if (FaceNum > 0){	// Check if there is any data to write
		printheader("Board Dimensions");
		printf("B_BOARD_OUTLINES\n");
		// Number of Faces
		printf("%d\n",FaceNum);
		l=1;
		for (i=1;i<=FaceNum;i++){
			// FACE <Number of Points> 0
			printf("FACE %d 0\n",NumPointsFace[i]);
			for (k=1;k<=NumPointsFace[i];k++){
				printf("%s",FaceCommand[l]);
				l++;
			}
		}
		printf("E_BOARD_OUTLINES\n");
	}
    // END OF RUN
    printheader("End of data");
  }
  
  if ( GenerateComponentFile == yes ) {
    output( filesetext( B.name, ".CMP" ) ) {
      printdivider();
      printf("%s\n", headerline);
      printf("# %s\n#\n", Version);
      printf("# %s\n#\n", EAGLE_SIGNATURE);
      printf("# SiWave Board exported from:\n");
      printf("# %s\n", B.name);
      printf("# At %s\n#\n", t2string(time()));
      if (project.schematic) {
        printf("# Schematic is loaded.\n");
      }
      else {
        printf("# Schematic NOT is loaded.\n");
      }
      printf("#\n*\n");

    // PACKAGES ON THE BOARD
    printheader("Components");
    int pincount, componentspace;
    string componentname;
    string componentpackage;
    string componentvalue;
	int first = 1;
    B.elements(E) {
      // get the number of pins
      pincount = 0;
      E.package.contacts(C) {
        pincount++;
      }
      // remember component reference designator
      componentname = E.name;
      // remember component packagename
	  componentpackage = E.package.name;
      // truncate component values at the first space
      componentvalue = E.value;
      if ( TruncateComponentValues == yes )
        if ( ( componentspace = strchr( componentvalue, ' ' ) ) != -1 )
           componentvalue = strsub( componentvalue, 0, componentspace );
      // parse reference designators ?
      if ( UseComponentTypes == yes ) {
		if ( strstr( componentname, "IC" ) == 0) {
			printf("B_IC \"%s\" \"%s\" \n",componentname,componentpackage);
			// Print Comment
			printf("#  Angle=%03.0f X=%5.*f Y=%5.*f : ",E.angle,precision_of_nets,u2mm(E.x), precision_of_nets,u2mm(E.y) );
			printf(" Lib: %s : %s : ", E.package.library, E.package.name);
			printf("Pins %d", pincount);
			printf("\n");
			for ( int ComponentCounterInx = 1; ComponentCounterInx < ComponentCounter; ComponentCounterInx++ ) {
				ComponentTemp = ComponentInfoName[ComponentCounterInx];
				if ( strstr( componentname, ComponentTemp ) == 0 && strstr( ComponentTemp, componentname ) == 0){
					printf(ComponentInfo[ComponentCounterInx]);
				}
			}
			printf("\"???\"\n");
			printf("E_IC\n");
		}
		else if ( strchr( componentname, 'U' ) == 0 ) {
			printf("B_IC \"%s\" \"%s\" \n",componentname,componentpackage);
			// Print Comment
			printf("#  Angle=%03.0f X=%5.*f Y=%5.*f : ",E.angle,precision_of_nets,u2mm(E.x), precision_of_nets,u2mm(E.y) );
			printf(" Lib: %s : %s : ", E.package.library, E.package.name);
			printf("Pins %d", pincount);
			printf("\n");
			for ( int ComponentCounterInx = 1; ComponentCounterInx < ComponentCounter; ComponentCounterInx++ ) {
				ComponentTemp = ComponentInfoName[ComponentCounterInx];
				if ( strstr( componentname, ComponentTemp ) == 0 && strstr( ComponentTemp, componentname ) == 0){
					printf(ComponentInfo[ComponentCounterInx]);
				}
			}
			printf("\"???\"\n");
			printf("E_IC\n");
		}
		else if ( strchr( componentname, 'C' ) == 0 ) {
			if ( ( componentspace = strchr( componentvalue, 'F' ) ) != -1 ) //Remove F if present
			   componentvalue = strsub( componentvalue, 0, componentspace );
			if ( ( componentspace = strchr( componentvalue, ',' ) ) != -1 ) //Remove , if present
			   componentvalue = strsub( componentvalue, 0, componentspace );
			printf("B_CAP \"%s\" \"%s\" \n",componentname,componentpackage);
			// Print Comment
			printf("#  Angle=%03.0f X=%5.*f Y=%5.*f : ",E.angle,precision_of_nets,u2mm(E.x), precision_of_nets,u2mm(E.y) );
			printf(" Lib: %s : %s : ", E.package.library, E.package.name);
			printf("Pins %d", pincount);
			printf("\n");
			for ( int ComponentCounterInx = 1; ComponentCounterInx < ComponentCounter; ComponentCounterInx++ ) {
				ComponentTemp = ComponentInfoName[ComponentCounterInx];
				if ( strstr( componentname, ComponentTemp ) == 0 && strstr( ComponentTemp, componentname ) == 0){
					printf(ComponentInfo[ComponentCounterInx]);
				}
			}
			printf("\"%sF\" \"0.0nF\" \"0nH\" \"0ohms\"\n",componentvalue);
			printf("E_CAP\n");
		}
		else if ( strchr( componentname, 'R' ) == 0 ) {
			if ( ( componentspace = strchr( componentvalue, 'R' ) ) != -1 ) //Remove R if present
			   componentvalue = strsub( componentvalue, 0, componentspace );
			if ( ( componentspace = strchr( componentvalue, ',' ) ) != -1 ) //Remove , if present
			   componentvalue = strsub( componentvalue, 0, componentspace );

			printf("B_RES \"%s\" \"%s\" \n",componentname,componentpackage);
			// Print Comment
			printf("#  Angle=%03.0f X=%5.*f Y=%5.*f : ",E.angle,precision_of_nets,u2mm(E.x), precision_of_nets,u2mm(E.y) );
			printf(" Lib: %s : %s : ", E.package.library, E.package.name);
			printf("Pins %d", pincount);
			printf("\n");
			printf("# ComponentCounter=%d componentnam=%s\n",ComponentCounter,componentname);
			for ( int ComponentCounterInx = 1; ComponentCounterInx < ComponentCounter; ComponentCounterInx++ ) {
				ComponentTemp = ComponentInfoName[ComponentCounterInx];
				if ( strstr( componentname, ComponentTemp ) == 0 && strstr( ComponentTemp, componentname ) == 0){
					printf(ComponentInfo[ComponentCounterInx]);
				}
			}
			printf("\"%sohms\" \"0.0nF\" \"0nH\" \"0ohms\"\n",componentvalue);
			printf("E_RES\n");
		}
		else if ( strchr( componentname, 'L' ) == 0 ) {
			if ( ( componentspace = strchr( componentvalue, 'H' ) ) != -1 ) //Remove H if present
			   componentvalue = strsub( componentvalue, 0, componentspace );
			if ( ( componentspace = strchr( componentvalue, ',' ) ) != -1 ) //Remove , if present
			   componentvalue = strsub( componentvalue, 0, componentspace );
			printf("B_IND \"%s\" \"%s\" \n",componentname,componentpackage);
			// Print Comment
			printf("#  Angle=%03.0f X=%5.*f Y=%5.*f : ",E.angle,precision_of_nets,u2mm(E.x), precision_of_nets,u2mm(E.y) );
			printf(" Lib: %s : %s : ", E.package.library, E.package.name);
			printf("Pins %d", pincount);
			printf("\n");
			for ( int ComponentCounterInx = 1; ComponentCounterInx < ComponentCounter; ComponentCounterInx++ ) {
				ComponentTemp = ComponentInfoName[ComponentCounterInx];
				if ( strstr( componentname, ComponentTemp ) == 0 ){
					printf(ComponentInfo[ComponentCounterInx]);
				}
			}
			printf("\"%sH\" \"0.0nF\" \"0nH\" \"0ohms\"\n",componentvalue);
			printf("E_IND\n");
		}
		else if ( strchr( componentname, 'D' ) == 0 ) {
			printf("B_IC \"%s\" \"%s\" \n",componentname,componentpackage);
			// Print Comment
			printf("#  Angle=%03.0f X=%5.*f Y=%5.*f : ",E.angle,precision_of_nets,u2mm(E.x), precision_of_nets,u2mm(E.y) );
			printf(" Lib: %s : %s : ", E.package.library, E.package.name);
			printf("Pins %d", pincount);
			printf("\n");
			for ( int ComponentCounterInx = 1; ComponentCounterInx < ComponentCounter; ComponentCounterInx++ ) {
				ComponentTemp = ComponentInfoName[ComponentCounterInx];
				if ( strstr( componentname, ComponentTemp ) == 0 ){
					printf(ComponentInfo[ComponentCounterInx]);
				}
			}
			printf("\"???\"\n");
			printf("E_IC\n");
		}
		else if ( strchr( componentname, 'Q' ) == 0 ) {
			printf("B_IC \"%s\" \"%s\" \n",componentname,componentpackage);
			// Print Comment
			printf("#  Angle=%03.0f X=%5.*f Y=%5.*f : ",E.angle,precision_of_nets,u2mm(E.x), precision_of_nets,u2mm(E.y) );
			printf(" Lib: %s : %s : ", E.package.library, E.package.name);
			printf("Pins %d", pincount);
			printf("\n");
			for ( int ComponentCounterInx = 1; ComponentCounterInx < ComponentCounter; ComponentCounterInx++ ) {
				ComponentTemp = ComponentInfoName[ComponentCounterInx];
				if ( strstr( componentname, ComponentTemp ) == 0 && strstr( ComponentTemp, componentname ) == 0){
					printf(ComponentInfo[ComponentCounterInx]);
				}
			}
			printf("\"???\"\n");
			printf("E_IC\n");
		}
		else if(IncludePinPlateComponents == yes ){
			printf("B_PINPLATE \"%s\" \"%s\" \n",componentname,componentpackage);
			// Print Comment
			printf("#  Angle=%03.0f X=%5.*f Y=%5.*f : ",E.angle,precision_of_nets,u2mm(E.x), precision_of_nets,u2mm(E.y) );
			printf(" Lib: %s : %s : ", E.package.library, E.package.name);
			printf("Pins %d", pincount);
			printf("\n");
			for ( int ComponentCounterInx = 1; ComponentCounterInx < ComponentCounter; ComponentCounterInx++ ) {
				ComponentTemp = ComponentInfoName[ComponentCounterInx];
				if ( strstr( componentname, ComponentTemp ) == 0 && strstr( ComponentTemp, componentname ) == 0){
					printf(ComponentInfo[ComponentCounterInx]);
				}
			}
			printf("\"???\"\n");
			printf("E_PINPLATE\n");
		  }
		}
		
    }

		if(IncludePinPlateComponents == no ){
			printheader("Following Components are not included in the CMP file");
			B.elements(E) {				
				// remember component reference designator
				componentname = E.name;
				if ( UseComponentTypes == yes ) {
					if ( strstr( componentname, "IC" ) == 0){}
					else if ( strchr( componentname, 'U' ) == 0 ){}
					else if ( strchr( componentname, 'C' ) == 0 ){}
					else if ( strchr( componentname, 'R' ) == 0 ){}
					else if ( strchr( componentname, 'L' ) == 0 ){}
					else if ( strchr( componentname, 'D' ) == 0 ){}
					else if ( strchr( componentname, 'Q' ) == 0 ){}
					else{
						printf("# Ref=%s  Angle=%03.0f X=%5.*f Y=%5.*f : ",componentname,E.angle,precision_of_nets,u2mm(E.x), 
						precision_of_nets,u2mm(E.y) );
						printf(" Lib: %s : %s : ", E.package.library, E.package.name);
						printf("Pins %d", pincount);
						printf("\n");
					}
				}
			}
			
		}
	
	
  }
 }

  string ex;
  sprintf(ex, "Data exported to:\n\n%s\n%s", filesetext( B.name, ".CMP" ), filesetext( B.name, ".ANF" ));
  dlgMessageBox(ex, "OK");
} // end of board() {}


